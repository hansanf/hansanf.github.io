<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python_cpp_interaction</title>
    <link href="/2024/09/21/cpp/py_cpp_interaction/"/>
    <url>/2024/09/21/cpp/py_cpp_interaction/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Python调用C">1. Python调用C++</h2><p>python调用C++需要编译出 python 的 module so，是一种区别于普通依赖库的动态库，可以通过pybind11 中的cmake 函数进行生成。</p><ul><li>step 1<br>首先要配置好pybind11 的依赖，其是纯头文件库，在CMakeLists.txt 中可以通过CPM 拉取，除此之外还需要依赖的 eigen, pybind11中有一些矩阵计算需要用到的。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">CPMAddPackage(<br>  NAME pybind11<br>  GIT_TAG v2.<span class="hljs-number">9</span><br>  GIT_REPOSITORY https://github.com/pybind/pybind11.git<br>)<br><br>CPMAddPackage(<br>  NAME eigen<br>  URL https://gitlab.com/libeigen/eigen/-/archive/<span class="hljs-number">3.4</span>.<span class="hljs-number">0</span>/eigen-<span class="hljs-number">3.4</span>.<span class="hljs-number">0</span>.tar.gz<br>)<br></code></pre></td></tr></table></figure><p>除了通过CPM 拉取源码外，也可以通过编译源码然后install 到 /usr 的方式；应该也可以通过apt 安装。</p><ul><li>step 2<br>生成扩展包格式的动态库需要使用pybind11 提供的 pybind11_add_module 函数，然后去链接pybind11、和 python 库，以及引用头文件</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pybind11_add_module(cpp2py_binding src/cpp2py_binding.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(cpp2py_binding PUBLIC python3.<span class="hljs-number">8</span>)<br><span class="hljs-keyword">target_include_directories</span>(cpp2py_binding<br>    PRIVATE <span class="hljs-variable">$&#123;pybind11_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>    PRIVATE <span class="hljs-variable">$&#123;eigen_SOURCE_DIR&#125;</span><br>    PRIVATE /usr/<span class="hljs-keyword">include</span>/python3.<span class="hljs-number">8</span><br>)<br></code></pre></td></tr></table></figure><ul><li>step 3<br>编写 src/cpp2py_binding.cpp，其中实现提供给python 调用的接口。如果有C++中定义的结构体需要传递给python，则需要实现类型转换器，示例如下，get_lane_instance_from_cpp 是暴漏给 python 的接口，type_caster 是python 接收到 c++ 中的 LaneInstance 类型时进行的转换，其由解释器调用，无需用户操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LaneInstance</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-built_in">LaneInstance</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lane ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">LaneInstance <span class="hljs-title">get_lane_instance_from_cpp</span><span class="hljs-params">()</span> </span>&#123;<br>    LaneInstance lane;<br>    <span class="hljs-comment">// 填充 lane 对象的数据</span><br>    lane.id = <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">return</span> lane;<br>&#125;<br><br><span class="hljs-comment">// 自定义类型转换器</span><br><span class="hljs-keyword">namespace</span> pybind11 &#123; <span class="hljs-keyword">namespace</span> detail &#123;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">type_caster</span>&lt;LaneInstance&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PYBIND11_TYPE_CASTER</span>(LaneInstance, _(<span class="hljs-string">&quot;LaneInstance&quot;</span>));<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">load</span><span class="hljs-params">(handle src, <span class="hljs-type">bool</span> convert)</span> </span>&#123;<br>        <span class="hljs-comment">// 从 Python 对象转换到 C++ 对象（这里不实现，因为我们只关心从 C++ 到 Python 的转换）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> handle <span class="hljs-title">cast</span><span class="hljs-params">(<span class="hljs-type">const</span> LaneInstance &amp;src, return_value_policy policy, handle parent)</span> </span>&#123;<br>        <span class="hljs-comment">// 将 C++ 对象转换为 Python 字典</span><br>        pybind11::dict dict;<br>        dict[<span class="hljs-string">&quot;id&quot;</span>] = src.id;<br>        <span class="hljs-keyword">return</span> dict.<span class="hljs-built_in">release</span>();<br>    &#125;<br>&#125;;<br>&#125;&#125; <span class="hljs-comment">// namespace pybind11::detail</span><br><br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(cpp2py_binding, m) &#123;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;get_lane_instance&quot;</span>, &amp;get_lane_instance_from_cpp, <span class="hljs-string">&quot;Get a LaneInstance object from C++&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>step 4<br>编译后会有生成一个 cpp2py_binding.cpython-38-x86_64-linux-gnu.so 的东西，其作为python 的扩展包由 python 使用，需要在启动 python 前将 .so 的目录路径放在 PYTHONPATH 环境变量中，然后就可以在 python 中调用 get_lane_instance 了。注意 get_lane_instance 是python 中的接口，其背后的实现是c++ 中的get_lane_instance_from_cpp。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cpp2py_binding <span class="hljs-keyword">as</span> cpp<br>lane_instance = cpp.get_lane_instance()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;id: &quot;</span>lane_instance.<span class="hljs-built_in">id</span>)<br></code></pre></td></tr></table></figure><ul><li>note</li></ul><ol><li>如果是C++中的自定义数据类型，一定要有类型转换器，不然就会报 TypeError: Unregistered type</li><li>cpp文件中定义的 PYBIND11_MODULE 名称 一定要和 CMakeLists.txt pybind11_add_module 名称一致，不然会报 ImportError: dynamic module does not define module export function</li></ol><h2 id="2-C-调用Python">2. C++调用Python</h2><p>简单来说，就是通过pybind11中的数据类型，将C++类型转化为python 类型，比如 pybind11::dict、pybind11::list，也有一些cast 操作</p><ul><li>step 1</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># c++ call python script</span><br><span class="hljs-keyword">add_executable</span>(pyprocess src/pyprocess.cpp)<br><span class="hljs-keyword">target_include_directories</span>(pyprocess<br>    PRIVATE <span class="hljs-variable">$&#123;pybind11_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>    PRIVATE <span class="hljs-variable">$&#123;eigen_SOURCE_DIR&#125;</span><br>    PRIVATE /usr/<span class="hljs-keyword">include</span>/python3.<span class="hljs-number">8</span><br>)<br><span class="hljs-keyword">target_link_libraries</span>(pyprocess PUBLIC python3.<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><ul><li>step 2</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pybind11/embed.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LaneInstance</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-built_in">LaneInstance</span>() : <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lane ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">py_get_lane_instances</span><span class="hljs-params">(LaneInstance lane)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">time_cost</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>, [start_time](<span class="hljs-type">void</span>* p) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;py_get_valid_other_instances time cost: &quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</span></span><br><span class="hljs-params"><span class="hljs-function">                     end_time - start_time).count()</span></span><br><span class="hljs-params"><span class="hljs-function">              &lt;&lt; <span class="hljs-string">&quot; us&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br>  <span class="hljs-type">static</span> py::scoped_interpreter py_interpreter_init = []() &#123;<br>    py::scoped_interpreter guard &#123;&#125;;<br>    <span class="hljs-keyword">return</span> guard;<br>  &#125;();<br><br>  <span class="hljs-comment">// 准备参数</span><br>  <span class="hljs-comment">// py::dict py_lane_instance = cpp2py_lane_instance(lane);</span><br>  py::dict py_lane_instance;<br>  py_lane_instance[<span class="hljs-string">&quot;id&quot;</span>] = lane.id; <span class="hljs-comment">// py::dict 的key 只支持字符串类型</span><br><br>  py::int_ out_ret = <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">// 调用 Python 函数</span><br>  out_ret = py::module_::<span class="hljs-built_in">import</span>(<span class="hljs-string">&quot;callee&quot;</span>).<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;get_lane_instances&quot;</span>)(<br>      py_lane_instance<br>  );<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;in c++, out_ret: &quot;</span> &lt;&lt; out_ret.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">int</span>&gt;() &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  LaneInstance lane;<br>  lane.id = <span class="hljs-number">999</span>;<br>  <span class="hljs-built_in">py_get_lane_instances</span>(lane);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>step 3</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_lane_instances</span>(<span class="hljs-params">lane_instance</span>):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in python, lane_instance: &quot;</span>, lane_instance)<br>  out_ret = <span class="hljs-number">999</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in python out_ret: &quot;</span>, out_ret)<br>  <span class="hljs-keyword">return</span> out_ret<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda_call_once</title>
    <link href="/2024/09/13/cpp/lambda_function/"/>
    <url>/2024/09/13/cpp/lambda_function/</url>
    
    <content type="html"><![CDATA[<h2 id="作为局部静态变量只初始化一次">作为局部静态变量只初始化一次</h2><p>lambda函数可以作为局部静态变量，而局部静态变量只会初始化一次，因此该lammbda函数只会执行一次，因而具有 call_once 的语义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> init = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;only init once&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>;i++) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>    <span class="hljs-built_in">func</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aligned_storage</title>
    <link href="/2024/09/13/cpp/aligned_storage/"/>
    <url>/2024/09/13/cpp/aligned_storage/</url>
    
    <content type="html"><![CDATA[<h2 id="aligned-storage">aligned_storage</h2><p>通过union 将存储和访问分开，并将存储数据的内存作为整体进行对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Vec = std::vector&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GetAlignedData</span> &#123;<br>  <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> std::aligned_storage&lt;<span class="hljs-built_in">sizeof</span>(T) * N, <span class="hljs-built_in">sizeof</span>(T) * N&gt;::type;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">using</span> AlignedType = <span class="hljs-keyword">typename</span> GetAlignedData&lt;T, N&gt;::type;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">size_t</span> N&gt;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">PackData</span> &#123;<br>  AlignedType&lt;T, N&gt; storage;<br>  T elem[N];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  PackData&lt;<span class="hljs-type">int</span>, <span class="hljs-number">4</span>&gt; data;<br>  <span class="hljs-type">int</span> x[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>  data.storage = *(<span class="hljs-keyword">reinterpret_cast</span> &lt;AlignedType&lt;<span class="hljs-type">int</span>, <span class="hljs-number">4</span>&gt;* &gt;(x));<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> z : data.elem) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string_view vs string &amp;</title>
    <link href="/2024/09/03/cpp/string_view/"/>
    <url>/2024/09/03/cpp/string_view/</url>
    
    <content type="html"><![CDATA[<h2 id="标准">标准</h2><p>string_view 在C++17 才被支持</p><h2 id="性能方面">性能方面</h2><p><a href="https://stackoverflow.com/questions/40127965/how-exactly-is-stdstring-view-faster-than-const-stdstring">https://stackoverflow.com/questions/40127965/how-exactly-is-stdstring-view-faster-than-const-stdstring</a></p><p>string_view 在某些情况下可以避免内存分配，比如这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( std::string_view bob )</span> </span>&#123;<br>  std::cout &lt;&lt; bob &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span>*<span class="hljs-type">const</span>* argv)</span> </span>&#123;<br>  <span class="hljs-built_in">foo</span>( <span class="hljs-string">&quot;This is a string long enough to avoid the std::string SBO&quot;</span> );<br>  <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">foo</span>( argv[<span class="hljs-number">1</span>] );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果foo 函数接收的参数类型是 const std::string &amp; ，那么在传递参数的时候需要先构造出一个string，而 string_view不需要</p><p>除此之外，更重要的场景是需要用到子串时，string_view的substr 是在原字符串的基础上读取，而string 的 substr 是返回一个新的字符串</p><h2 id="生存周期方面">生存周期方面</h2><p>string_view 的生存周期是和原 string 一样的，因此在局部string不要能用在string_view上</p><h2 id="空字符">空字符</h2><p>string_view 尾部不包含空字符，除非是用字符常量构造的；而 string 尾部是含有空字符的，虽然size 不包含空字符位</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节对齐</title>
    <link href="/2024/08/12/cpp/byte_alignment/"/>
    <url>/2024/08/12/cpp/byte_alignment/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要字节对齐">为什么要字节对齐</h2><p><a href="https://www.jb51.net/article/84553.htm">https://www.jb51.net/article/84553.htm</a></p><ol><li>不同硬件兼容性。一些平台对某些特定类型的数据只能从某些特定地址开始存取</li><li>避免内存需要两次访问才能把一个数据完整的读写</li></ol><h2 id="alignas-关键字-实现结构体字节对齐">alignas 关键字 实现结构体字节对齐</h2><ul><li>直接用在struct 关键字的后面加上 alignas(N), N 表示整个结构体中所有变量的最大对齐值, 如果N 小于各个变量的实际大小, 那么 alignas 将被忽略</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">8</span>) Base &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">char</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><span class="hljs-comment">// size = 16</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">2</span>) Base &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">char</span> b;<br>  <span class="hljs-type">int</span> c;<br>&#125;;<br><span class="hljs-comment">// size = 12</span><br></code></pre></td></tr></table></figure><ul><li>用在结构体中的单个变量上, 表示该变量的对齐值。如果前面的变量使用了 alignas, 后面的变量没使用或者使用对齐值更小，那么都以前面的对齐值为准, 并且在对齐范围内包含后面的变量；如果后面对齐值比前面大，那么则从新开始计算对齐地址</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseSep</span> &#123;<br>  <span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">char</span> b;<br>&#125;;<br><span class="hljs-comment">// size = 64</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseSep</span> &#123;<br>  <span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) <span class="hljs-type">int</span> a;<br>  <span class="hljs-built_in">alignas</span>(<span class="hljs-number">32</span>) <span class="hljs-type">char</span> b;<br>&#125;;<br><span class="hljs-comment">// size = 64</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseSep</span> &#123;<br>  <span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) <span class="hljs-type">int</span> a;<br>  <span class="hljs-built_in">alignas</span>(<span class="hljs-number">64</span>) <span class="hljs-type">char</span> b;<br>&#125;;<br><span class="hljs-comment">// size = 128</span><br></code></pre></td></tr></table></figure><h2 id="attribute-aligned-n-方式的"><strong>attribute</strong>((aligned (n))) 方式的</h2><h2 id="pack-N-方式">pack(N) 方式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numa</title>
    <link href="/2024/08/09/numa/"/>
    <url>/2024/08/09/numa/</url>
    
    <content type="html"><![CDATA[<h2 id="jetson-是否支持-numa">jetson 是否支持 numa</h2><p>NUMA 技术的主要思想是将 CPU 进行分组，Node 即是分组的抽象，一个 Node 表示一个分组，一个分组可以由多个 CPU 组成。每个 Node 都有自己的本地资源，包括内存、IO 等。每个 Node 之间通过互联模块（QPI）进行通信，因此每个 Node 除了可以访问自己的本地内存之外，还可以访问远端 Node 的内存，只不过性能会差一些，一般用 distance 这个抽象的概念来表示各个 Node 之间互访资源的开销。</p><p>NUMA 是将 CPU 分组，也是将 内存 分组，而 jetson 平台是上的硬件设计上，内存控制器只有一个，因此 jetson 是无法支持NUMA 的: <a href="https://forums.developer.nvidia.com/t/numa-support-in-jetson-nano/184604">https://forums.developer.nvidia.com/t/numa-support-in-jetson-nano/184604</a></p><p>numa 主要是为支持服务器上有几十个、上百个cpu 的场景而设计的</p><h2 id="numa-的硬件设计">numa 的硬件设计</h2><p><a href="https://www.cnblogs.com/aozhejin/p/15955554.html">https://www.cnblogs.com/aozhejin/p/15955554.html</a></p><h2 id="numa-的作用">numa 的作用</h2><h3 id="SMP">SMP</h3><p>SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU</p><h3 id="numa">numa</h3><p>由于 SMP 在扩展能力上的限制，人们开始探究如何进行有效地扩展从而构建大型系统的技术， NUMA 就是这种努力下的结果之一。利用 NUMA 技术，可以把几十个 CPU( 甚至上百个 CPU) 组合在一个服务器内。<br>NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。由于其节点之间可以通过互联模块 ( 如称为 Crossbar Switch) 进行连接和信息交互，问本地内存的速度将远远高于访问远地内存 ( 系统内其它节点的内存 ) 的速度，这也是非一致存储访问 NUMA 的由来。由于这个特点，为了更好地发挥系统性能，开发应用程序时需要尽量减少不同 CPU 模块之间的信息交互。<br><img src="image-5.png" alt="alt text"></p><p><a href="https://draveness.me/whys-the-design-numa-performance/">https://draveness.me/whys-the-design-numa-performance/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>成员指针</title>
    <link href="/2024/08/08/cpp/member_pointer/"/>
    <url>/2024/08/08/cpp/member_pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="参考">参考</h2><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointers-to-members?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/pointers-to-members?view=msvc-170</a></p><h2 id="总结">总结</h2><p>成员指针与普通指针的区别在于，其能够标志该类所有实例的成员变量或成员函数，而常规指针只能标识内存中的一个对象或只具有其地址</p><h2 id="示例">示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">float</span> b;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;func&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  A a;<br>  a.a = <span class="hljs-number">100</span>;<br>  a.b = <span class="hljs-number">123.99</span>;<br>  <span class="hljs-keyword">auto</span> pa = &amp;A::a; <span class="hljs-comment">//指向所有实例的成员变量 a</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;a.a=&quot;</span> &lt;&lt; a.*pa &lt;&lt; std::endl;<br>  <span class="hljs-keyword">auto</span> pf = &amp;A::func; <span class="hljs-comment">//指向所有实例的成员函数 func</span><br>  (a.*pf)();<br>  <span class="hljs-built_in">void</span> (A::*ppf)() = &amp;A::func;<br>  (a.*ppf)();<br><br>  A x;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;x.a=&quot;</span> &lt;&lt; a.*pa &lt;&lt; std::endl;  <span class="hljs-comment">// 用相同的指针标识不同实例中的相同成员变量</span><br>  (x.*pf)();<br>  (x.*ppf)();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch-notes</title>
    <link href="/2024/07/31/pytorch_notes/"/>
    <url>/2024/07/31/pytorch_notes/</url>
    
    <content type="html"><![CDATA[<h1>pytorch-notes</h1><h2 id="channles-last-内存格式">channles_last 内存格式</h2><p><a href="https://juejin.cn/post/7155302838636118047">https://juejin.cn/post/7155302838636118047</a></p><p>一般是NCHW 格式内存排列，当数据为 (10x3x16x16) 时，对应的 stride 为 (768, 256, 16, 1)，不同颜色的通道是分开的，一个颜色对应着一张图<br><img src="image-3.png" alt="alt text"></p><p>而 channels_last 是 NHWC 格式内存排列，对应的 stride 为 (768, 1, 48, 3)，channels last张量以通道为最密集维度的方式排序（也就是按像素存储图像），不同颜色的像素紧挨着<br><img src="image-4.png" alt="alt text"></p><h2 id="intrusive-ptr">intrusive_ptr</h2><p>侵入式指针，与std::shared_ptr的的区别：</p><ul><li>使用方式：侵入式表示需要访问指向对象的成员，intrusive_ptr<T> 中的 T 必须继承自 intrusive_ptr_target，因为intrusive_ptr_target 提供了引用引用计数 refcount_，intrusive_ptr 作为 intrusive_ptr_target的友元可以访问refcount_，这也是侵入式的含义</li><li>使用场景：极致性能场景; 与需要this 指针的场景(std::enable_shared_from_this已经解决)</li></ul><p>std::shared_ptr 的性能问题：因为引用计数需要在不同的 shared_ptr 对象之间共享，所以引用计数分配在堆上，其在构造时如果用new 的方式则需要两次堆内存分配，并且因为引用计数和数据对象的内存不在一起，因此会有缓存失效导致的性能问题。不过 std::make_shared 已解决了shared_ptr 的性能问题，其将引用计数内存和数据内存在一次内存申请中完成分配，但是新的问题是如果有weak_ptr，即使 shared_ptr 的作用域已经结束，其数据对象的内存也不会被释放，需要等着所有的 shared_ptr 和 weak_ptr 析构后，数据对象的内存才会释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// make_shared + weak_ptr 会使内存无法及时被释放</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 假设这里有一个很大的数据结构</span><br>    <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1MB 的数据</span><br><br>    ~<span class="hljs-built_in">LargeObject</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;LargeObject destructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::make_shared 创建一个 LargeObject 的 shared_ptr</span><br>    <span class="hljs-keyword">auto</span> sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;LargeObject&gt;();<br><br>    <span class="hljs-comment">// 创建一个 weak_ptr 指向同一个 LargeObject</span><br>    std::weak_ptr&lt;LargeObject&gt; weakPtr = sharedPtr;<br><br>    <span class="hljs-comment">// 销毁 shared_ptr，此时 LargeObject 的内存和控制块仍然不会被释放</span><br>    <span class="hljs-comment">// 因为 weakPtr 仍然指向它</span><br>    sharedPtr.<span class="hljs-built_in">reset</span>();<br><br>    <span class="hljs-comment">// 在这里，LargeObject 的内存和控制块仍然被保留</span><br>    <span class="hljs-comment">// 除非 weakPtr 也被销毁或过期</span><br><br>    <span class="hljs-comment">// 假设我们现在进行了一些其他操作...</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 当 weakPtr 离开作用域或被显式重置时，LargeObject 的析构函数才会被调用</span><br>    <span class="hljs-comment">// 并且其内存和控制块才会被释放</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;before weak_ptr&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 为了演示，我们可以将 weakPtr 显式地设置为空</span><br>    weakPtr.<span class="hljs-built_in">reset</span>();<br><br>    <span class="hljs-comment">// 现在 LargeObject 的内存被释放了</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 使用valgrind 检查内存，结果显示 make_shared&lt;LargeObject&gt; 的内存没有被释放</span><br><span class="hljs-comment">// valgrind --tool=memcheck --trace-children=yes --leak-check=full  --show-leak-kinds=all  --keep-debuginfo=yes ./a.out</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">==333562==</span><br><span class="hljs-comment">==333562== HEAP SUMMARY:</span><br><span class="hljs-comment">==333562==     in use at exit: 1,048,592 bytes in 1 blocks</span><br><span class="hljs-comment">==333562==   total heap usage: 3 allocs, 2 frees, 1,122,320 bytes allocated</span><br><span class="hljs-comment">==333562==</span><br><span class="hljs-comment">==333562== 1,048,592 bytes in 1 blocks are still reachable in loss record 1 of 1</span><br><span class="hljs-comment">==333562==    at 0x484B8F8: operator new(unsigned long) (vg_replace_malloc.c:483)</span><br><span class="hljs-comment">==333562==    by 0x10A063: __gnu_cxx::new_allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt;::allocate(unsigned long, void const*) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109EC3: std::allocator_traits&lt;std::allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt; &gt;::allocate(std::allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt;&amp;, unsigned long) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109C9B: std::__allocated_ptr&lt;std::allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt; &gt; std::__allocate_guarded&lt;std::allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt; &gt;(std::allocator&lt;std::_Sp_counted_ptr_inplace&lt;LargeObject, std::allocator&lt;LargeObject&gt;, (__gnu_cxx::_Lock_policy)2&gt; &gt;&amp;) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109B53: std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt;::__shared_count&lt;LargeObject, std::allocator&lt;LargeObject&gt;&gt;(LargeObject*&amp;, std::_Sp_alloc_shared_tag&lt;std::allocator&lt;LargeObject&gt; &gt;) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109A77: std::__shared_ptr&lt;LargeObject, (__gnu_cxx::_Lock_policy)2&gt;::__shared_ptr&lt;std::allocator&lt;LargeObject&gt;&gt;(std::_Sp_alloc_shared_tag&lt;std::allocator&lt;LargeObject&gt; &gt;) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x1098C3: std::shared_ptr&lt;LargeObject&gt;::shared_ptr&lt;std::allocator&lt;LargeObject&gt;&gt;(std::_Sp_alloc_shared_tag&lt;std::allocator&lt;LargeObject&gt; &gt;) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x1096D3: std::shared_ptr&lt;LargeObject&gt; std::allocate_shared&lt;LargeObject, std::allocator&lt;LargeObject&gt;&gt;(std::allocator&lt;LargeObject&gt; const&amp;) (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109527: std::shared_ptr&lt;LargeObject&gt; std::make_shared&lt;LargeObject&gt;() (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==    by 0x109203: main (in /mnt/data0/guoqing.feng/3d/output/a.out)</span><br><span class="hljs-comment">==333562==</span><br><span class="hljs-comment">==333562== LEAK SUMMARY:</span><br><span class="hljs-comment">==333562==    definitely lost: 0 bytes in 0 blocks</span><br><span class="hljs-comment">==333562==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="hljs-comment">==333562==      possibly lost: 0 bytes in 0 blocks</span><br><span class="hljs-comment">==333562==    still reachable: 1,048,592 bytes in 1 blocks</span><br><span class="hljs-comment">==333562==         suppressed: 0 bytes in 0 blocks</span><br><span class="hljs-comment">==333562==</span><br><span class="hljs-comment">==333562== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="hljs-comment">==333562== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>pytorch 中的 intusive_ptr 需要传递两个模板参数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTarget</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullType</span> = detail::intrusive_target_default_null_type&lt;TTarget&gt;&gt;<br><span class="hljs-keyword">class</span> intrusive_ptr;<br></code></pre></td></tr></table></figure><p>NullType 类型必须有一个返回值是 TTarget* 的 singleton() 方法。为什么不直接用 nullptr呢？</p><p>官方在IValue 的定义中有提到，这样做是想通过让Tensor和c10::intrusive_ptr路径生成相同的代码以优化析构和相关操作的性能。下面是AI 的回答：</p><p>为什么使用UndefinedTensorImpl::singleton():</p><p>传统的空指针（nullptr）表示一个指针不指向任何有效的对象。然而，在处理c10::intrusive_ptr时，由于它不拥有对象，仅仅使用nullptr可能不足以提供足够的上下文或优化机会。<br>UndefinedTensorImpl::singleton()是一个特殊的TensorImpl实例，它表示一个未定义或无效的Tensor。通过使用这个单例而不是nullptr，c10::intrusive_ptr可以保持其“侵入式”的特性（即依赖对象内部的计数器），同时提供一个明确的、非空的表示空状态的方式。<br>这种表示法可能允许编译器或运行时优化，因为所有空的c10::intrusive_ptr<TensorImpl>都会指向同一个对象（UndefinedTensorImpl::singleton()），这可能会减少或简化某些检查或逻辑。<br>性能优化:</p><p>通过让Tensor和c10::intrusive_ptr路径生成相同的代码，可以更容易地利用现代编译器的优化技术，如内联展开、循环展开等。<br>当两种表示法（Tensor和c10::intrusive_ptr）在底层以相似的方式处理空状态时，它们可以共享更多的优化策略，从而提高整体性能。</p><p>在所有与 Tensor 相关的 intrusive_ptr 中，其 NullType 都是 UndefinedTensorImpl，其继承了TensorImpl，会构造出一个标记为无法使用的 TensorImpl，TensorImpl(DispatchKey::Undefined, caffe2::TypeMeta(),std::nullopt) ，并且会对 has_storage、is_contiguous_custom 等函数进行重载，因此在Tensor 为空的情况下，依然可以调用Tensor 相关的操作，这是nullptr 所无法实现的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref-qualifier</title>
    <link href="/2024/07/31/cpp/rvalue_ref_qualifier/"/>
    <url>/2024/07/31/cpp/rvalue_ref_qualifier/</url>
    
    <content type="html"><![CDATA[<h1>ref-qualifier</h1><p><a href="https://en.cppreference.com/w/cpp/language/member_functions">https://en.cppreference.com/w/cpp/language/member_functions</a></p><h2 id="Member-functions-with-ref-qualifier">Member functions with ref-qualifier</h2><p>An implicit object member function can be declared with no ref-qualifier, with an lvalue ref-qualifier (the token &amp; after the parameter list) or the rvalue ref-qualifier (the token &amp;&amp; after the parameter list). During overload resolution, an implicit object member function with a cv-qualifier sequence of class X is treated as follows:</p><ul><li>no ref-qualifier: the implicit object parameter has type lvalue reference to cv-qualified X and is additionally allowed to bind rvalue implied object argument</li><li>lvalue ref-qualifier: the implicit object parameter has type lvalue reference to cv-qualified X</li><li>rvalue ref-qualifier: the implicit object parameter has type rvalue reference to cv-qualified X</li></ul><p>example</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> &amp;  </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> &amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>; &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    S s;<br>    s.<span class="hljs-built_in">f</span>();            <span class="hljs-comment">// prints &quot;lvalue&quot;</span><br>    std::<span class="hljs-built_in">move</span>(s).<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// prints &quot;rvalue&quot;</span><br>    <span class="hljs-built_in">S</span>().<span class="hljs-built_in">f</span>();          <span class="hljs-comment">// prints &quot;rvalue&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从示例中可以看出，成员函数用右值限定符修饰后只能通过右值对象调用，而左值限定符修饰的成员函数则可以通过左值对象和右值对象调用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>smart_ptr</title>
    <link href="/2024/07/26/smart-ptr/"/>
    <url>/2024/07/26/smart-ptr/</url>
    
    <content type="html"><![CDATA[<h2 id="std-shared-ptr">std::shared_ptr</h2><p>引用计数是原子的，<br>大多数解释是 shared_ptr 本身是线程安全的，但是对指向对象的读写不是线程安全的。</p><p>本身是线程安全的是什么意思呢，理解为在多线程中对shared_ptr 的读、复制和当引用计数大于 1 时的写是线程安全的。特别注意的引用计数大于 1 时的写，可以是该shared_ptr 本身的析构，也可以是赋值为其他的 shared_ptr，因为引用计数是线程安全的，其变化能够立刻被其他的 shared_ptr 感知到，因此当引用计数大于 1时，对shared_ptr 本身的写是不会影响指向对象的。但是当引用计数等于 1 时，其在多线程的写过程中，是会发生对指向对象的析构调用的，即发生了对指向对象的读写，因此该过程是线程不安全的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>image_preprocess</title>
    <link href="/2024/07/26/image-preprocess/"/>
    <url>/2024/07/26/image-preprocess/</url>
    
    <content type="html"><![CDATA[<h2 id="标准化和归一化">标准化和归一化</h2><ul><li>标准化（Standardization）：将一组数据变换为均值为0，标准差为1的分布（该分布并非一定符合正态分布）</li></ul><p>公式: (x - mean)/ std<br>bgr 图像常用的均值和标准差值为: mean=[123.675, 116.28, 103.53], std=[58.395, 57.12, 57.375]</p><ul><li>归一化（Normalization）：将一组数据变化到某个固定区间内，比较常见的如[0, 1]。广义来说可以是各种区间，比如在对图像进行处理是会经常映射到[0, 255]，也有映射到[-1, 1]的情况</li></ul><p>bgr 单字节深度图像也可以用标准化的公式进行归一化，令其均值和标准差设为 mean=[128, 128, 128], std=[128, 128, 128]</p><p>归一化公式为 (x - 128)/ 128，因为x 最大值为 255，最小值为 0，因此会归一化到 [-1, 1) 的范围</p>]]></content>
    
    
    
    <tags>
      
      <tag>图像预处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>network_communication</title>
    <link href="/2024/07/08/network-communication/"/>
    <url>/2024/07/08/network-communication/</url>
    
    <content type="html"><![CDATA[<h2 id="socket-编程">socket 编程</h2><h3 id="大端序和小端序">大端序和小端序</h3><p>PC 上是小端序（低位在低地址，高位在高地址，易于计算机处理）</p><p>网络传输是大端序（低位在高地址，高位在低地址，符合人类的阅读习惯）</p><p>发送端总是把要发送的数据转化为大端字节序数据后再发送</p><h3 id="socket-地址">socket 地址</h3><h4 id="通用socket-地址-sockaddr">通用socket 地址 sockaddr</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span> &#123;<br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="专用socket地址">专用socket地址</h4><p>UNIX本地协议族使用如下专用socket地址结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> &#123;<br>    <span class="hljs-type">sa_family_t</span> sin_family; <span class="hljs-comment">/* 地址族: AF_UNIX */</span><br>    <span class="hljs-type">char</span> sun_path[<span class="hljs-number">108</span>];     <span class="hljs-comment">/* 文件路径名 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>TCP/IP协议族有socket_in和sockaddr_in6两个专业socket地址结构体，它们分别用于IPv4和IPv6：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockadddr_in</span>&#123;<br>    <span class="hljs-type">sa_family_t</span> sun_family;        <span class="hljs-comment">/* 地址族: AF_INET */</span><br>    <span class="hljs-type">u_int16_t</span> sin_port;             <span class="hljs-comment">/* 端口号，要用网络字节序表示 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> sin_addr        <span class="hljs-comment">/* IPv4地址结构体 */</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> &#123;<br>    <span class="hljs-type">u_int32_t</span> s_addr;                    <span class="hljs-comment">/* IPv4地址，要用网络字节序号表示 */</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in6</span> &#123;<br>    <span class="hljs-type">sa_family_t</span> sin6_family;            <span class="hljs-comment">/* 地址族: AF_INET6 */</span><br>    <span class="hljs-type">u_int16_t</span> sin6_port;                    <span class="hljs-comment">/* 端口号，要用网络字节序表示 */</span><br>    <span class="hljs-type">u_int32_t</span> sin6_flowinfo;            <span class="hljs-comment">/* 流信息，应设置为0 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in6_addr</span> sin6_addr;        <span class="hljs-comment">/* IPv6地址结构体 */</span><br>    <span class="hljs-type">u_int32_t</span> sin6_scope_id;            <span class="hljs-comment">/* scope ID, 尚处于实验阶段 */</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in6_addr</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sa_addr[<span class="hljs-number">16</span>];         <span class="hljs-comment">/* IPv6地址，要用网络字节序表示 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket类型sockaddr(强制类型转换)，因为socket编程接口使用的地址参数的类型都是sockaddr。</p><h3 id="socket-api-调用流程">socket api 调用流程</h3><p>服务器端：<br>创建 socket: 指定网络层协议（ipv4 or ipv6）和传输层协议（tcp or udp）-&gt;</p><p>绑定 socket: 与具体的服务端地址绑定（ip and port） -&gt;</p><p>监听 socket: 创建一个监听队列存放待处理的客户端连接 -&gt;</p><p>接收连接: 从监听队列中取出就绪的连接</p><p>客户端：<br>创建 socket -&gt;</p><p>发起连接: 向指定地址的服务端发起连接请求</p><p>参考: <a href="https://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/">https://swordandtea.github.io/2020/11/06/hight_performance_linux_coding/Linux网络编程基础API/</a></p><h3 id="IO-多路复用">IO 多路复用</h3><p>一个socket 就是一个文件，每个socket 都对应一个 socket fd，IO多路复用是指将多个 socket fd 同时进行监听，从而获取多个事件状态。具体来讲，我们有三个IO多路复用的系统调用可以使用：</p><h4 id="select">select</h4><p>将所有已连接的socket fd 放在一个文件描述符集合中，然后调用select 将文件描述符集合拷贝到内核中，内核中对集合进行轮训以检查是否有事件发生，当有事件产生后则将对应的文件描述符标记为可读或可写，然后再将集合从内核拷贝到用户态，然后用户再遍历集合以查找有有事件产生的文件描述符</p><p>所以通过select 实现IO多路复用需要对文件描述符集合进行两次拷贝和两次遍历。且select 使用固定长度BitMap 表示文件描述符集合，因此其所支持的复用路数是有限制的，默认最大值是1024</p><h3 id="poll">poll</h3><p>poll 和 select 的整体流程一样，只是在文件描述符集合的实现上由 BitMap 修改为了链表，因此其所支持的文件描述符个数不再受限制</p><h3 id=""></h3>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>taskflow-analysis</title>
    <link href="/2024/06/26/taskflow-analysis/"/>
    <url>/2024/06/26/taskflow-analysis/</url>
    
    <content type="html"><![CDATA[<h2 id="taskflow主要的类">taskflow主要的类</h2><h3 id="Executor">Executor</h3><p>An executor manages a set of worker threads to run one or multiple taskflows<br>using an efficient work-stealing scheduling algorithm.</p><p>顾名思义，taskflows 的执行实体，包括线程的创建和调度，默认创建cpu 核数量的线程。</p><p>Executor 构造的时候通过调用 _spawn(size_t N) 创建N个线程和Worker，每个线程中调用 _exploit_task 执行任务，调用 _wait_for_task等待任务到来</p><p>主要接口：<br>run* 系列，最终的实现都落到 run_until 里面，将 list<Taskflow> 中的 Taskflow 构造到 Topology 中，进行实际任务的执行。</p><p>主要成员变量：Worker, std::thread, Taskflow, Node, ObserverInterface</p><h3 id="Task">Task</h3><p>对Node 的封装，只有一个 Node* 成员变量</p><h3 id="Node">Node</h3><p>用于执行实际操作的实体，其中最重要的部分是把回调函数封装到 _handle 中，其次就是通过 _dependents 和 _successors 建立各个 Node 之间的关系</p><h3 id="Graph">Graph</h3><p>管理 Node，负责 Node 的创建和销毁，只有一个 std::vector&lt;Node*&gt; _nodes 成员变量，通过 _emplace_back 成员函数创建 Node，_emplace_back 是在 Taskflow 中创建 Task 的时候进行调用的</p><h3 id="Taskflow">Taskflow</h3><p>Graph 管理的是 Node，而 Taskflow 管理的是 Task，因此也可以把 Taskflow 看作是对 Graph 的封装。Taskflow 与 Excutor 进行直接的交互，Taskflow 是任务执行流的表示，而 Graph 只是对任务的载体，即 Graph 没有任务间的逻辑交互。</p><p>Taskflow 继承自 FlowBuilder，两者有意义的成员变量只有 _graph 、 _mutex 和 _topologies，可以看出 Graph 是维护在 Taskflow 里的</p><h3 id="SmallVector">SmallVector</h3><p>其作用和std::vector 一样，都是动态数组，区别在于 SmallVector 针对数据量小的情况和 POD 的情况做了特别的优化。</p><p>如 SmallVector&lt;int, 2&gt;() 形式的构造，其表示当元素数量小于等于 2 个元素时，其内存分配在栈上，而当元素数量大于 2 个时，其仍会在堆上分配内存，并且如果是中途扩充的容量，其会把栈上元素拷贝到堆上。</p><p>taskflow 中的 SmallVector 实现是从llvm 中搞过去的，类似的实现folly 和 boost中也有，参考：<a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/167">https://github.com/zhangyachen/zhangyachen.github.io/issues/167</a></p><p>继承关系:<br>SmallVector -&gt; SmallVectorImpl -&gt; SmallVectorTemplateBase -&gt; SmallVectorTemplateCommon -&gt; SmallVectorBase</p><p>基本实现:<br>其中关于vector 的操作方法都是在 SmallVectorImpl 和 SmallVectorTemplateBase 两个类中实现的。</p><p>只有 SmallVectorTemplateCommon 和 SmallVectorBase 有实际的成员变量，其中 SmallVectorTemplateCommon::FirstEl 用来标识栈上首元素，SmallVector::SmallVectorStorage&lt;T, N&gt; 用来表示栈上存储的元素，但是实际上其内部只有一个 SmallVectorTemplateCommon<T>::U InlineElts[N - 1], 其用来实例化 N-1 个栈上元素的空间。SmallVectorTemplateCommon<T>::U InlineElts[N - 1] 和 SmallVectorTemplateCommon::FirstEl 加一起是栈上N 个元素，从类对象的内存布局上看，两个成员变量是挨着的。为什么不直接初始化N 个元素，还要分成两部分去实现呢，好处没看出来，可能是 FirstEl 有什么特别的作用，必须要其保证栈上有一个元素吧。</p><p>除了 InlineElts[N - 1] 和 FirstEl 这两个成员变量外，还有三个指针变量，分别是 BeginX EndX 和 CapacityX，其和常规vector 就一致了，分别表示数组的头、尾和容量的地址</p><p><img src="image-2.png" alt="继承关系"></p><h3 id="DataPipeline">DataPipeline</h3><p>当多个节点之间存在数据依赖关系时使用<br>构造函数中调用 reset() 和 _build()</p><p>line 和 pipe 的关系是？乱七八糟</p><h3 id="Pipeflow">Pipeflow</h3><p>只有几个简单的成员变量: _line, _pipe, _token, _num_deferrals, _dependents</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vi_usage</title>
    <link href="/2024/04/24/vi-usage/"/>
    <url>/2024/04/24/vi-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="以普通用户身份打开，以-root-用户身份保存">以普通用户身份打开，以 root 用户身份保存</h2><p>:w !sudo tee %</p><p>:w - 这是写入命令。由于没有给出参数，vim 将把整个文件写入标准输出；</p><p>!sudo - 将 sudo 命令作为 shell 命令而不是 vim 命令运行；</p><p>tee - tee命令用于读取标准输入并将其写入标准输出或文件；</p><p>% - vim 将其替换为您正在编辑的当前文件的名称。</p><p>:w 命令将整个文件写入 STDOUT（标准输出）；然后，我们使用sudo命令（因为我们编辑的毕竟是一个系统文件）来获得临时权限。</p><p>百分号（%）表示文件名，tee 命令从 STDOUT 获取 vim 的输出并将其写入 % 文件。</p><h2 id="保存文件前显示差异">保存文件前显示差异</h2><p>:w !diff % -</p><p>:w  用于保存/写入，在这个特定场景中，如果命令中没有指定文件名，则输出将写入STDIN（标准输入）文件；</p><p>:!<command>  是执行 shell 命令的语法，在这个例子中，我们在 shell 中运行 diff 命令；</p><p>%  表示未修改的当前文件的名称；试试这个：:!echo %</p><ul><li>是 diff 命令的 STDIN 文件。</li></ul><p>因此，该命令首先将所有[未保存]内容写入STDIN文件。然后diff命令读取当前文件（%）并将其与STDIN（-）文件进行比较。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试磁盘读写速度</title>
    <link href="/2024/04/18/disk_io/"/>
    <url>/2024/04/18/disk_io/</url>
    
    <content type="html"><![CDATA[<h2 id="dd-测试硬盘写入速度">dd-测试硬盘写入速度</h2><p>dd bs=1M count=128 if=/dev/zero of=test conv=fdatasync</p><h2 id="iostat-查看设备IO">iostat 查看设备IO</h2><p><a href="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/iostat.html">参考链接</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cuda-notes</title>
    <link href="/2024/01/31/cuda-notes/"/>
    <url>/2024/01/31/cuda-notes/</url>
    
    <content type="html"><![CDATA[<h1>杂记</h1><p>1.可以在kernel 里设置同步点进行数据间的同步，__syncthreads()通常用于调整在相同块之间的线程通信<br>2.一个批处理中每一个多处理器可以处理多少个块，取决于每个线程中分配了多少个寄存器和已知内核中每<br>个时钟需要多少的共享内存</p><p>3.warp是硬件层面中SM对应执行线程的单位。</p><p>线程束Wrap是GPU的基本执行单元，目前cuda的warp的大小为32。</p><p>同在一个warp的线程执行同一指令。warp 本质上是一组被同时调用的线程组，符合SIMD（或叫 SIMT 单执行多线程）并行模型，所有线程中都执行相同的指令，每一条warp 包含数量相同的线程；warp周期性切换执行；关键要理解<strong>相同指令的执行</strong>，也就意味着如果出现不同的执行分支，同一 warp 中的一部分线程会阻塞等待一另部分执行完才能执行后面的相同指令</p><p>4.线程块是一个逻辑上的概念，其大小可以设置，其中的线程被分配一块<strong>共享内存</strong>，其线程数往往大于warp 大小（常规cuda 设计下，warp size为32），也就意味着一个块中的会划分出多个warp。线程块中的线程数量曾经受架构限制，每个线程块最多只有512个线程，但从2019年7月开始，线程块可以最多包含1024个线程。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%9D%97">wiki 线程块</a></p><p>与线程块对应的硬件是SM（stream multiprocessor）, 不同的 SM 之间无法进行同步，因此一个block 只能分配到一个SM 中，相反的，一个 SM 却可以承载多个block<br><a href="https://www.cvmart.net/community/detail/6020">设置block size 和 grid size</a></p><ol start="5"><li>一个块内的 warp 次序是未定义的，但可以通过协调全局或共享内存的读取进行同步；在一个栅格块内的块次序是未定义的，并且不存在同步机制</li></ol><p>6.内存模型<br>一条执行在设备上的线程，只允许通过如下的内存空间使用设备的DRAM 和On-Chip 内存，如图2-2 所<br>示：<br> 读写每条线程的寄存器，<br> 读写每条线程的本地内存，<br> 读写每个块的共享内存，<br> 读写每个栅格的全局内存，<br> 只读每个栅格的常量内存，<br> 只读每个栅格的纹理内存。</p><p><img src="image.png" alt="Alt text"><br>全局内存在设备的 DRAM 上；常量内存和纹理内存都是只读内存<br>全局内存不会被缓存；常量内存和纹理内存中的数据会被缓存；缓存是无法被直接访问的，cuda 中的缓存数据来源是常量内存和纹理内存</p><p>7.循环展开的： #pragma unroll 默认下，编译器为已知的行程计数展开小型循环。<br>#pragma unroll 5<br>For (int i = 0; i &lt; n; ++i)<br>循环将展开5 次。<br>如果#pragma unroll 后面没有附值，当行程计数（n）为常数时，循环完全展开，否则不会展<br>开。</p><p>8.-use_fast_math编译选项，将替换math 库中的标准标本为低准确性而更快速的版本</p><p>9.page-locked memory： 在cpu 内存中分配的内存，不会被换出，gpu 使用时通过PCIE 进行通信<br>10.unified memory(managed memory)： 可以翻译为托管内存，将分配的驻留位置移动到需要它的处理器，当gpu 需要访问时就会把该块内存数据移动到gpu 内存上，当 cpu 需要访问时就把这块内存数据移动到cpu 内存上。</p><p>11.以下操作在不同的流中也不能进行并发：page-locked 主机内存分配，设备内存的分配，设备内存的<br>设置，设备到设备的内存拷贝，或它们之间的事件纪录。<br>12.数据拷贝和数值计算、两个方向的拷贝（gpu-&gt;cpu 和 cpu-&gt;gpu，两个gpu-&gt;cpu 或者一个 gpu-&gt;cpu、一个cpu-&gt;gpu这种）可以同时进行。<br>13.cudaThreadSynchronize调用后可以确保前面所有的流都已完成。</p><p>12.设置CUDA_LAUNCH_BLOCKING 环境变量为1，强制cuda同步运行</p><p>13.为保证编译器生成最低数量的指令，对于结构体大于16 字节的，应该用__align__ (16)定义,例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__align</span>(<span class="hljs-number">16</span>)__ &#123;<br>  <span class="hljs-type">float</span> a;<br>  <span class="hljs-type">float</span> b;<br>  <span class="hljs-type">float</span> c<br>  <span class="hljs-type">float</span> d<br>  <span class="hljs-type">float</span> e;<br>&#125;;<br>被编译成为二个<span class="hljs-number">128</span>-bit 加载指令而不是五个<span class="hljs-number">32</span>-bit 加载指令。 <br></code></pre></td></tr></table></figure><p>14.bank 冲突分两种，一种是共享内存bank 冲突，共享内存在物理上被分为 32 个（刚好等于一个线程束中的线程数目，即内建变量 warpSize 的值）同样宽度的、能被同时访问的内存 bank，当同一个 warp 中的不同线程访问同一个 bank 中的不同的地址时（访问同一个地址则会发生广播），就会发生 bank 冲突；另一种是寄存器 bank 冲突，每个 SM 有独立的 register file，每个reigister file 被分为多个 bank，寄存器编号 id%4 即为该寄存器所属的 bank，如 R0 属于 Bank 0，R5 属于 Bank 1），当一条指令所需的源寄存器有两个以上来自于同一 bank则会产生 conflict，比如FFMA R1, R0, R4, R1 这样的指令就回产生寄存器 Bank conflict（同同访问了 R0 和 R4，同属于 bank 0 的寄存器）</p><p><a href="http://www.zh0ngtian.tech/posts/96744e8c.html">http://www.zh0ngtian.tech/posts/96744e8c.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tensorrt_tutorial</title>
    <link href="/2024/01/19/tensorrt-tutorial/"/>
    <url>/2024/01/19/tensorrt-tutorial/</url>
    
    <content type="html"><![CDATA[<h2 id="sample-编译">sample 编译</h2><p><a href="https://github.com/NVIDIA/TensorRT/tree/release/8.0?tab=readme-ov-file#prerequisites">https://github.com/NVIDIA/TensorRT/tree/release/8.0?tab=readme-ov-file#prerequisites</a></p><ol><li>github 上下载对应仓库，然后根据对应的 cuda 版本选择对应的tag进行下载。<br>比如选择 release/8.0，如果有 docker 环境，可以利用官方提供的 docker 镜像进行；裸机的话需要安装cuda、cudnn、tensorrt 三件套</li></ol><p>找到开发机中对应的 tensorrt lib 的路径，export TRT_LIBPATH=/usr/lib/aarch64-linux-gnu/</p><ol start="2"><li>拉取三方依赖库的repo：git submodule update --init --recursive</li></ol><p>一般需要 vpn 才能下载下来</p><ol start="3"><li>release/8.0版本需要修改两个地方</li></ol><p>在 CMakeLists.txt中</p><p>设置nvcc 路径：set(CMAKE_CUDA_COMPILER /usr/local/cuda-10.2/bin/nvcc)<br>设置cub 的路径：set(CUB_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party/cub CACHE STRING “directory of CUB installation”)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pod_trivial_stardard_layout</title>
    <link href="/2024/01/10/pod-trivial-stardard-layout/"/>
    <url>/2024/01/10/pod-trivial-stardard-layout/</url>
    
    <content type="html"><![CDATA[<h2 id="Plain-Old-Data-POD"><strong>Plain Old Data (POD)</strong></h2><p>pod 包含 trivial(普通)类型和standard layout</p><p>概念介绍：<br><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170</a></p><p>trivial 类型的结构体支持用memcpy来操作二进制，并对齐进行序列化和反序列，但不能被C程序调用</p><p>standard layout 类型的结构体支持被C 程序调用，但是不能用memcpy 进行二进制操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>include-what-you-see</title>
    <link href="/2023/12/27/include-what-you-see/"/>
    <url>/2023/12/27/include-what-you-see/</url>
    
    <content type="html"><![CDATA[<h1>简介</h1><h1>如何安装</h1><p>根据gitlab 首页的提示：<a href="https://github.com/include-what-you-use/include-what-you-use">https://github.com/include-what-you-use/include-what-you-use</a></p><p>找到 <strong>How to build standalone</strong>，首先要知道IWYS是基于clang 和 llvm 构建，所以如果环境中已经安装好了</p><h1>如何使用</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux_deps</title>
    <link href="/2023/12/27/linux-deps/"/>
    <url>/2023/12/27/linux-deps/</url>
    
    <content type="html"><![CDATA[<h3 id="libncurses5-dev">libncurses5-dev</h3><p>源码编译<br><a href="https://blog.51cto.com/liuzhenlife/1892078">https://blog.51cto.com/liuzhenlife/1892078</a><br>下载地址： <a href="http://ftp.gnu.org/gnu/ncurses/">http://ftp.gnu.org/gnu/ncurses/</a></p><p><a href="http://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz">http://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz</a></p><figure class="highlight autoit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># tar -zxvf ncurses-6.0.tar.gz</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># cd ncurses-6.0</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># ./configure --with-shared --without-debug --without-ada --enable-overwrite  </span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta">#  make</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta">#  make install</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>camera_params.md</title>
    <link href="/2023/10/09/camera-params-md/"/>
    <url>/2023/10/09/camera-params-md/</url>
    
    <content type="html"><![CDATA[<p>$$<br>E=mc^2<br>$$</p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h2 id="空间转换-坐标系转换">空间转换/坐标系转换</h2><p>图像是由相机采集而来，那么就有一个疑问了，三维物理世界下的物体是怎么映射到一张二维图像上的，是怎么映射到具体的像素点的。这个映射的过程，就涉及到了几个坐标系/空间的转换。</p><h2 id="相机参数">相机参数</h2><h3 id="去畸变">去畸变</h3><p>为什么去畸变</p><p>怎么去畸变</p>]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>doxygen-usage</title>
    <link href="/2023/09/18/doxygen-usage/"/>
    <url>/2023/09/18/doxygen-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="vscode生成doxygen注释">vscode生成doxygen注释</h2><h2 id="doxygen-生成类图">doxygen 生成类图</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>doxygen<br><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>graphviz<br>doxygen -g ConfigName<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>memory_check_tools</title>
    <link href="/2023/09/06/memory-check-tools/"/>
    <url>/2023/09/06/memory-check-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="ASan">ASan</h2><p>AddressSanitizer 的缩写。</p><blockquote><p>官方资料：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">https://github.com/google/sanitizers/wiki/AddressSanitizer</a></p></blockquote><h3 id="常规用法">常规用法</h3><p><strong>分为三步:</strong></p><ol><li>添加编译选项，配合-g使用效果更价</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"># set(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=address -fsanitize-recover=address -lasan&quot;</span>)<br>add<span class="hljs-constructor">_compile_options(-<span class="hljs-params">fno</span>-<span class="hljs-params">omit</span>-<span class="hljs-params">frame</span>-<span class="hljs-params">pointer</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">undefined</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">leak</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">address</span> -<span class="hljs-params">fsanitize</span>-<span class="hljs-params">recover</span>=<span class="hljs-params">address</span> -<span class="hljs-params">lasan</span>)</span><br></code></pre></td></tr></table></figure><p>支持</p><ol start="2"><li>目标程序运行前需要预加载 <a href="http://libasan.so">libasan.so</a></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export LD_PRELOAD=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc/</span>aarch64-linux-gnu<span class="hljs-regexp">/7/</span>libasan.so<br></code></pre></td></tr></table></figure><ol start="3"><li>通过环境变量对 asan 进行配置</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=halt_on_error=0   #和<span class="hljs-attribute">-fsanitize-recover</span>=address配合使用，遇到 <span class="hljs-built_in">error</span> 仍然向下执行<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=halt_on_error=0:verbosity=1     #设置多个选项<br></code></pre></td></tr></table></figure><h3 id="选项含义">选项含义</h3><h4 id="编译选项">编译选项</h4><blockquote><p>官方flag 文档：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</a></p></blockquote><h4 id="runtime选项">runtime选项</h4><p>ASAN_OPTIONS所支持的选项，通过help 查看</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=help=1    #查看帮助<br></code></pre></td></tr></table></figure><h3 id="asan-输出分析">asan 输出分析</h3><p><img src="image-1.png" alt="alt text"><br>chatgpt:<br>Addressable (可寻址的): 表示可以被访问和修改的内存区域。在这里用 “00” 表示。</p><p>Partially addressable (部分可寻址的): 表示只有部分字节可以被访问和修改。在这里用 “01” 到 “07” 表示。</p><p>Heap left redzone (堆左侧红区): 在堆分配的内存块的左侧，用于检测堆溢出。标记为 “fa”。</p><p>Freed heap region (已释放的堆区域): 表示已经被释放的堆内存。标记为 “fd”。</p><p>Stack left redzone (栈左侧红区): 在栈分配的内存块的左侧，用于检测栈溢出。标记为 “f1”。</p><p>Stack mid redzone (栈中间红区): 在栈分配的内存块的中间，用于检测栈溢出。标记为 “f2”。</p><p>Stack right redzone (栈右侧红区): 在栈分配的内存块的右侧，用于检测栈溢出。标记为 “f3”。</p><p>Stack after return (返回后的栈): 用于检测函数返回后对栈的访问。标记为 “f5”。</p><p>Stack use after scope (作用域结束后的栈使用): 表示在变量作用域结束后对栈的访问。标记为 “f8”。</p><p>Global redzone (全局变量红区): 用于检测对全局变量的溢出。标记为 “f9”。</p><p>Global init order (全局变量初始化顺序): 用于检测全局变量的初始化顺序问题。标记为 “f6”。</p><p>Poisoned by user (用户引起的中毒): 表示由用户引起的内存污染。标记为 “f7”。</p><p>Container overflow (容器溢出): 表示容器类型（比如数组、列表等）的溢出。标记为 “fc”。</p><p>Array cookie (数组饼干): 用于检测数组的越界访问。标记为 “ac”。</p><p>Intra object redzone (对象内红区): 在对象内部，用于检测对象成员之间的溢出。标记为 “bb”。</p><p>ASan internal (ASan 内部): ASan（AddressSanitizer）内部使用的标记。标记为 “fe”。</p><p>Left alloca redzone (alloca 左侧红区): 在使用 alloca 函数分配的内存块的左侧，用于检测溢出。标记为 “ca”。</p><p>Right alloca redzone (alloca 右侧红区): 在使用 alloca 函数分配的内存块的右侧，用于检测溢出。标记为 “cb”。</p><p>Shadow gap (影子间隙): 用于对齐。标记为 “cc”。</p><h2 id="valgrind">valgrind</h2><p>valgrind --tool=memcheck --trace-children=yes --leak-check=full  --show-leak-kinds=all  --keep-debuginfo=yes  --log-file=leak.log  bin_path</p><h3 id="源码编译-安装">源码编译 &amp; 安装</h3><p><a href="https://www.cnblogs.com/Kingfans/p/16594998.html">https://www.cnblogs.com/Kingfans/p/16594998.html</a></p><h3 id="执行时问题">执行时问题</h3><ul><li>Ubuntu: valgrind: failed to start tool ‘memcheck’ for platform ‘amd64-linux’: No such file or directory</li></ul><p><a href="https://stackoverflow.com/questions/64813183/ubuntu-valgrind-failed-to-start-tool-memcheck-for-platform-amd64-linux-no">https://stackoverflow.com/questions/64813183/ubuntu-valgrind-failed-to-start-tool-memcheck-for-platform-amd64-linux-no</a></p><p>解决方法：<br>export VALGRIND_LIB=“/usr/lib/valgrind”</p>]]></content>
    
    
    
    <tags>
      
      <tag>内存检查工具</tag>
      
      <tag>内存泄露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake_usgae</title>
    <link href="/2023/08/17/cmake-usgae/"/>
    <url>/2023/08/17/cmake-usgae/</url>
    
    <content type="html"><![CDATA[<h2 id="cmake-变量">cmake 变量</h2><h3 id="预定义变量">预定义变量</h3><h4 id="cmake-D-变量">cmake -D 变量</h4><p>cmake -D变量名=值 的形式</p><ol><li>CMAKE_BUILD_TYPE<br>=Release 或者 =Debug</li><li>CMAKE_INSTALL_PREFIX<br>=path<br>install 安装目录的前缀</li></ol><h4 id="环境变量">环境变量</h4><ol><li>CPM_SOURCE_CACHE<br>设置cmp 拉取依赖的保存路径<br>unset CPM_SOURCE_CACHE<br>set CPM_SOURCE_CACHE=/home/hans/_deps/</li><li></li></ol><h3 id="自定义变量">自定义变量</h3><h4 id="外部定义">外部定义</h4><p>变量类型有两种，bool类型和string 类型，在外部定义时，即通过命令行<code>cmake -DXXX -DYYY</code>的形式传递变量时，其并不区分变量类型，可在CMakeList.txt 和 .cmake文件进行使用，帮助进行<strong>条件编译和宏定义传递</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 判断 XXX 变量是否定义</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> XXX)  <br>  <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;XXX is defined, val=$&#123;XXX&#125;.&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> (<span class="hljs-keyword">DEFINED</span> XXX))<br>  <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;XXX is not defined.&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 判断 YYY 变量是否定义，一般 YYY 为字符串时判断是否DEFINED</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> YYY)<br>  <span class="hljs-keyword">add_definitions</span>(-DXXX=<span class="hljs-number">100</span>) <span class="hljs-comment"># cpp带值宏定义</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 判断 YYY 变量是否为OFF，一般 YYY 为布尔类型时判断是否为 ON/OFF</span><br><span class="hljs-keyword">if</span> (YYY) <span class="hljs-comment"># if (NOT YYY)</span><br>  <span class="hljs-keyword">add_definitions</span>(-DUSE_XXX) <span class="hljs-comment"># cpp不带值宏定义</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h4 id="内部定义">内部定义</h4><p>bool 类型通过 OPTION 命令进行定义</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 语法: </span><br>  <span class="hljs-keyword">OPTION</span>(var_name <span class="hljs-string">&quot;var comments&quot;</span> 初始值: <span class="hljs-keyword">OFF</span>/<span class="hljs-keyword">ON</span>)<br><span class="hljs-comment"># 示例: </span><br>  <span class="hljs-keyword">OPTION</span>(USE_GPU <span class="hljs-string">&quot;whether to use gpu&quot;</span> <span class="hljs-keyword">OFF</span>)<br></code></pre></td></tr></table></figure><p>string 类型通过 SET 命令进行定义</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><br><span class="hljs-keyword">SET</span>(var_name <span class="hljs-string">&quot;var_value&quot;</span>)<br><span class="hljs-keyword">SET</span>(BUILD_PLATFORM <span class="hljs-string">&quot;x86&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;select build cpu type&quot;</span>)<br><span class="hljs-comment"># 设置CXX_FLAGS, 如果options 太多, 可以分行写, \后面注意什么也不要加</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; \</span><br><span class="hljs-string">    -fno-omit-frame-pointer -fsanitize=undefined \</span><br><span class="hljs-string">    -fsanitize=leak -fsanitize=address -fsanitize-recover=address -lasan&quot;</span>)<br></code></pre></td></tr></table></figure><p>命令不区分大小写，变量区分大小写</p><p>gcc编译阶段打印宏定义的内容 <a href="https://www.cnblogs.com/suiyek/p/14164160.html">https://www.cnblogs.com/suiyek/p/14164160.html</a></p><h3 id="缓冲变量">缓冲变量</h3><p>语法如下：<br>set(<variable> <value>… CACHE <type> <docstring> [FORCE])<br>variable：变量名称<br>value：变量值列表<br>CACHE：cache变量的标志<br>type：变量类型，取决于变量的值。类型分为：BOOL、FILEPATH、PATH、STRING、INTERNAL<br>docstring：必须是字符串，作为变量概要说明<br>FORCE：强制选项，强制修改变量值，第一次定义后，后面的修改需要使用 FORCE 选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 示例</span><br><span class="hljs-keyword">set</span>(MY_GLOBAL_VAR_STRING <span class="hljs-string">&quot;abc&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;定义一个STRING缓存变量&quot;</span> FORCE)<br></code></pre></td></tr></table></figure><p>CMake中的缓存变量都会保存在CMakeCache.txt文件中, 也就是作为整个工程的全局变量</p><h3 id="message-打印信息">message 打印信息</h3><p>message(STATUS “”)</p><h2 id="编译选项">编译选项</h2><h3 id="isystem-和-I-的区别">-isystem 和 -I 的区别</h3><p>搜索顺序: -I &gt; -isystem -&gt; 系统默认路径<br>-isystem 会忽略警告</p><h3 id="include-directories-SYSTEM-xxx">include_directories(SYSTEM xxx)</h3><p>SYSTEM 选项的用途是告诉编译器，这些目录中的头文件应被视为“系统”头文件，即这些头文件不应被视为候选的警告来源。换句话说，如果编译器在这些系统头文件中发现了某些警告（如未使用的变量、类型不匹配等），则不会将这些警告报告给用户。</p><h3 id="设置nvcc-编译器C-版本和编译选项">设置nvcc 编译器C++版本和编译选项</h3><p>set(CMAKE_CUDA_STANDARD “14”)<br>set(CMAKE_CUDA_FLAGS “${CMAKE_CUDA_FLAGS} -Wall -Werror=return-type”)</p><h2 id="链接">链接</h2><h3 id="默认链接的是静态库还是动态库">默认链接的是静态库还是动态库</h3><p>CMake在查找库时默认会优先找动态库（如.so文件或.dll文件），如果找不到或者特别指定了静态库，它会链接到静态库（如.a或.lib文件）。你可以通过<code>find_library</code>等命令及其相关参数来控制链接到静态库或动态库，或者添加定义来指定链接库的类型。</p><h4 id="add-library-默认生成的静态库还是动态库">add_library 默认生成的静态库还是动态库</h4><p><code>cmake</code> 中 <code>add_library</code> 命令默认生成的是静态库还是动态库取决于项目设置和 CMake 版本。在 CMake 3.0 及以上版本中，如果未指定库类型，它将根据变量 <code>BUILD_SHARED_LIBS</code> 的设置来决定，默认情况下，此变量不设定时<code>add_library</code>生成的是静态库。如果<code>BUILD_SHARED_LIBS</code>被设置为 ON，那么<code>add_library</code>不带库类型的情况下将生成动态库。</p><p>可以这样设置来决定默认的库类型：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 默认生成动态库</span><br></code></pre></td></tr></table></figure><p>或者，在<code>add_library</code>时直接指定库的类型：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylibrary STATIC mysource.cpp) <span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(mylibrary SHARED mysource.cpp) <span class="hljs-comment"># 生成动态库</span><br></code></pre></td></tr></table></figure><p>在不指定<code>STATIC</code>或<code>SHARED</code>，并且没有设置<code>BUILD_SHARED_LIBS</code>变量时，<code>add_library()</code>会创建静态库。</p><h2 id="属性">属性</h2><h3 id="二进制依赖库能否传递宏定义">二进制依赖库能否传递宏定义</h3><ul><li><p><code>target_compile_definitions</code>：<br>这是传递宏定义的推荐方式。使用它时，可以设置私有（PRIVATE）宏，它们只会影响当前目标；接口（INTERFACE）宏，它们会影响链接了当前库的其他目标，但不会影响当前目标；或者是公共（PUBLIC）宏，它们既影响当前目标又影响链接了当前库的其他目标。</p></li><li><p><code>add_definitions</code>：这个指令会给当前目录下所有目标添加宏定义，但是它不会传递给依赖的目标。且它的作用范围是全局的，会影响到后续所有的目标。</p></li></ul><h2 id="自定义make-目标">自定义make 目标</h2><p>add_custom_target 可以定义一个 target，然后通过 <code>make target_name</code> 命令进行目标的构建，该目标也可以是命令，比如下面这样</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_target</span>(copy_file sh copy_file.sh)<br></code></pre></td></tr></table></figure><p>然后在终端中可以通过执行 make copy_file 命令来执行 copy_file.sh 脚本。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加解密简介</title>
    <link href="/2023/08/16/encrypt-introduce/"/>
    <url>/2023/08/16/encrypt-introduce/</url>
    
    <content type="html"><![CDATA[<h2 id="加解密相关算法介绍">加解密相关算法介绍</h2><h3 id="base64">base64</h3><h4 id="作用和目的">作用和目的</h4><p>Base64是一种将二进制数据转换为字符串表示的格式转换算法，其最初是为了解决电子邮件中无法直接使用非ASCII字符的问题。一段数据先经过Base64编码为ASCII字符串后，可以在接收端，通过Base64解码还原为原数据后，而<strong>无需担心二进制兼容</strong>问题，避免数据的歧义和失真。</p><p>由于base64的易存储性和易传输性，常常将其用到加密数据的存储和传输场景。</p><p>使用Base64编码后的字符串通过索引表可以直接还原为明文，因此严格意义上讲base64并不是一种加密方法。</p><h4 id="实现方式">实现方式</h4><p>base64 编码是<strong>基于64个可打印的字符来表示二进制的数据</strong>的一种方法，具体来讲是下面这 64 个字符。</p><figure class="highlight lasso"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-meta">[</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span><span class="hljs-meta">]</span> （26 + 26 + 10 + 2 = 64）<br></code></pre></td></tr></table></figure><p>编码过程中，将待编码二进制数据按照 3 个字节进行分组（6 和 8 的最小公倍数是24），24bit 的原始数据对应着 4 个base64 编码（2 的 6 次方=64，即每 6bit 对应一个base64字符），即将3 字节的原始数据映射为4 个base64 字符。</p><blockquote><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/268594663">密码学 | Base64是加密算法吗？</a><br><a href="https://juejin.cn/post/7013621623454433317">今天学到了什么｜终于搞明白base64编码了</a></p></blockquote><h3 id="sha-2">sha-2</h3><h4 id="作用">作用</h4><p>SHA-2 (Secure Hash Algorithm 2), 安全散列算法2</p><p>sha算法的作用就提现在名字上，其是一种hash 算法。sha-2具有不可逆行，即无法通过哈希序列获得原始编码明文。</p><h3 id="对称加密和非对称加密">对称加密和非对称加密</h3><p>对称加密是指加解密双方要用同样的密钥；而非对称加密就是指加解密双方所用密钥不同，在非对称加密中，一个密钥对分为公钥和私钥，<strong>公钥用来加密，私钥用来解密。</strong></p><p>假设通信双方为小明和小红，小明要发数据给小红，通过非对称加密的通信过程大体如下：</p><ol><li>数据<strong>接收方</strong>小红生成密钥对</li><li>数据接收方小红将<strong>公钥</strong>发送给小明</li><li>小明通过公钥对数据加密后将数据发送给小红</li><li>小红通过<strong>本地私钥</strong>对加密数据进行解密</li></ol><p>因为公钥只能用来加密，因此公钥即使在网络传输过程中被劫持盗用，也无法将实际发送的数据的进行破解。</p><p>计算量上非对称加密要远高于对称加密，因此常常将对称加密的密钥，通过非对称加密方式进行传输，以保证密钥的安全性。</p><h3 id="RSA">RSA</h3><p>RSA 三个发明人的名字缩写，一种非对称加密算法</p><h3 id="AES">AES</h3><p>AES(Advanced Encryption Standard), 一种对称加密算法</p><h3 id="硬件加解密">硬件加解密</h3><p>加解密都需要很大的计算量，很多处理器上都有专用的硬件用来进行加解密，可以通过使用<code>cat /proc/cpuinfo</code>命令查看打印页中Features项是否包含aes sha1 sha2来判断平台是否支持硬解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>machine_learning</title>
    <link href="/2023/08/04/machine-learning/"/>
    <url>/2023/08/04/machine-learning/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cuda_usage</title>
    <link href="/2023/08/04/cuda-usage/"/>
    <url>/2023/08/04/cuda-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="查看本机所支持的-nvidia-驱动">查看本机所支持的 nvidia 驱动</h3><p>ubuntu-drivers devices</p><p>recommend 可以直接用 apt 安装</p><div class="code-wrapper"><pre><code class="hljs">nvidia 驱动官网下载:https://www.nvidia.cn/Download/index.aspx?lang=cn#</code></pre></div><h3 id="安装cuda">安装cuda</h3><p>在nvidia官网选择需要的cuda版本下载<br><a href="https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal">https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal</a></p><p>安装方式选择runfile</p><p>安装后 cuda路径为/usr/local/cuda-XXXX</p><h3 id="安装cudnn">安装cudnn</h3><p>在nvidia官网选择需要的cudnn版本下载<br><a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>下载解压后，将文件夹内cuda/include/里的所有文件拷贝到/usr/local/cuda-10.2/include/文件夹内，将cuda/lib64/里的所有文件拷贝到/usr/local/cuda-10.2/lib64/文件夹内</p>]]></content>
    
    
    
    <tags>
      
      <tag>cuda</tag>
      
      <tag>tensorrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qiniu 图床配置</title>
    <link href="/2023/08/02/qn-image-host/"/>
    <url>/2023/08/02/qn-image-host/</url>
    
    <content type="html"><![CDATA[<h3 id="图床">图床</h3><p>搜素“好用的图床”，搜索结果中随机对比了下，qiniu个人用户可以免费享受每月 10GB的存储和流量，遂用之。</p><img src="http://qn.save.hansanf.space/qiniu_personal_count_free_credit.png" height="80%" width="80%"><p>qiniu 的账户申请和配置省略，有很多教程，官方也有详细的引导和教程。<br>因为已经通过 hexo + github page有自己的播客了，之前简单理解只要把图片传到图床上就可以通过url 访问的图片了，但是qiniu图床不提供域名，没有域名也就没有可以访问图片的外链，因此需要在qiniu 上额外提供一个域名。先是尝试了直接将xxx.github.io作为qiniu 外链域名，但是没法用。然后在阿里云上申请了个人域名，10 年才168。<br>下面介绍如何将个人域名绑定到github page，以及如何绑定图床的外链域名。</p><h3 id="准备工作">准备工作</h3><ol><li>github pages  xxx.github.io可访问</li><li>qiniu 图床，可以上传图像</li><li>阿里云个人域名申请完成</li></ol><h3 id="github-page-绑定个人域名">github page 绑定个人域名</h3><p>教程：<a href="https://segmentfault.com/a/1190000011203711">https://segmentfault.com/a/1190000011203711</a></p><p><strong>绑定域名需要在 域名解析服务商 和 github 两边都进行操作</strong></p><ol><li><p>在域名解析服务商进行个人域名解析，将域名绑定到个人 github pages。<br><img src="http://qn.save.hansanf.space/ali_domain_name_parse.jpeg" height="50%" width="50%"></p></li><li><p>github pages 配置 CNAME 文件重定向到阿里云域名<br><img src="http://qn.save.hansanf.space//github_cname.png" width="50%" height="50%"></p></li></ol><p>完成后，在浏览器中输入hansanf.space 即可访问原来的 <a href="http://hansanf.github.io">hansanf.github.io</a></p><h4 id="hexo-重新生成博客push到repo后-页面显示404">hexo 重新生成博客push到repo后 页面显示404</h4><p>github page 设置cname 后，重新生成博客的时候可能会将CNAME文件覆盖，浏览器访问博客会出现 404 错误，可以将CNAME文件放在 “博客目录/source目录” 下</p><blockquote><p>参考：<a href="https://blog.csdn.net/Belingda/article/details/100635572">https://blog.csdn.net/Belingda/article/details/100635572</a></p></blockquote><h3 id="提供域名给qiniu-作为图床外链">提供域名给qiniu 作为图床外链</h3><p>在左上角-》对象存储-》域名管理-》绑定域名<br>一定要在 <strong>自定义源站域名</strong> 栏绑定域名，一开始选择cdn 的搞了半天都白搞了。<br><img src="http://qn.save.hansanf.space//qiniu_cname.png" width="50%" height="50%"></p><p>输入域名前要先在阿里云域名解析处 <strong>添加记录</strong>，即添加一个新的 cname, 修改 <strong>主机记录</strong>(即添加域名前缀，比如qn.save)，然后将 qn.save.hansanf.space  添加到qiniu 的域名中。<br><img src="http://qn.save.hansanf.space/qn_input_parse_domain_name.png" width="50%" height="50%"></p><p>然后即可通过qiniu的外链访问到图像，即可以将外链作为博客图像的链接地址进行访问，本文的所有图像都是通过qiniu 的外链进行访问的。</p><h3 id="补充知识">补充知识</h3><ol><li>什么是cname:</li></ol><p>在计算机网络中，CNAME是Canonical Name的缩写，即规范名。CNAME是DNS（Domain Name System）中的一种资源记录类型，用于建立域名的别名关系。</p><p>通常，一个域名可以有多个资源记录类型，例如A记录（指向IPv4地址）、AAAA记录（指向IPv6地址）、MX记录（指向邮件服务器）、TXT记录（用于存储任意文本信息）等。而CNAME记录允许将一个域名指向另一个域名，而不是直接指向IP地址。</p><p>举个例子，假设有两个域名：</p><p><a href="http://www.example.com">www.example.com</a> - 一个网站的主要域名，其A记录指向服务器的IPv4地址。<br><a href="http://www.example.net">www.example.net</a> - 另一个域名，希望将其指向和访问www.example.com相同的内容。</p><p>这时候，<a href="http://xn--www-vs9dj4uqlf.example.net">可以在www.example.net</a> 的DNS配置中添加一个CNAME记录，<a href="http://xn--www-633ej45apwaw27a.example.com">将它指向www.example.com</a>。  这样，当用户访问www.example.net时， <a href="http://xn--DNSCNAMEwww-o68q04g06l7tec2swix56jb8dxu0abtrpuckr71akbj8px.example.com">DNS服务器会解析CNAME记录并将其转换为www.example.com</a>， <a href="http://xn--www-l01em8iwy3auuicxs.example.com">然后再查找www.example.com</a>  的A记录，最终将用户重定向到服务器的IPv4地址。</p><p>CNAME记录有一些限制和注意事项，例如不能在CNAME记录和其他记录（如MX记录、NS记录）之间共存。同时，CNAME记录的使用也可能会导致额外的DNS查询，稍微增加一些延迟，因为它需要进一步解析其他域名。因此，在使用CNAME记录时，需要仔细考虑其适用场景和潜在影响。</p><ol start="2"><li>什么是cdn</li></ol><p>CDN是Content Delivery Network（内容分发网络）的缩写。它是一种用于加速互联网内容传输的技术架构。</p><p>在传统的网络架构中，当用户访问一个网站或下载某个文件时，请求会直接发送到该网站或文件所在的服务器，然后服务器将相应的内容传送给用户。如果用户和服务器之间的距离较远，网络拥塞或服务器负载较高，可能会导致传输速度较慢，延迟较高，影响用户体验。</p><p>CDN通过在全球范围内部署大量的服务器节点（也称为边缘节点），将网站的静态资源（例如图片、CSS、JavaScript、视频等）缓存到这些节点上。当用户请求访问网站内容时，CDN会自动将用户的请求路由到距离最近的边缘节点，从而加快内容的传输速度和加载时间。</p><p>CDN的工作原理如下：</p><p>缓存：CDN将网站的静态资源缓存在多个边缘节点上。<br>路由：当用户发起请求时，CDN会智能地选择距离用户最近的边缘节点，将请求路由到该节点。<br>传输：边缘节点直接向用户提供所需的内容，从而避免了长距离传输和网络拥塞。</p><p>简单来讲cdn 是为了访问加速，在qiniu 中通过外链访问图片只需要提供一个可以访问的域名，而不是对所提供的域名进行访问加速，所以在提供域名给qiniu 的时候要选择 <strong>自定义源站域名</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>域名</tag>
      
      <tag>cname</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>core文件设置</title>
    <link href="/2023/07/29/core-file/"/>
    <url>/2023/07/29/core-file/</url>
    
    <content type="html"><![CDATA[<h2 id="core-文件设置">core 文件设置</h2><h3 id="常规core文件设置">常规core文件设置</h3><h4 id="core-文件大小">core 文件大小</h4><p>查看：ulimit -c<br>临时设置： ulimit -c unlimited （当前终端有效）</p><h4 id="修改core文件路径">修改core文件路径</h4><ol><li>临时修改（重启后失效）<br>修改 <code>/proc/sys/kernel/core_pattern</code></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&#x27;/corefile/core_%e.%p&#x27;</span> | sudo tee <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br></code></pre></td></tr></table></figure><ol start="2"><li>永久生效<br>修改 <code>/etc/sysctl.conf </code>, 在其中加入两行</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">kernel.core_pattern</span>=/corefile/core_%e.%p<br><span class="hljs-attr">kernel.core_uses_pid</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>kernel.core_uses_pid 表示在core 文件结尾不加 pid，因为已经有了%p，所以不需要再添加<br>执行<code>sudo sysctl -p /etc/sysctl.conf</code>, 使修改生效。</p><h3 id="apport-core-文件">apport core 文件</h3><p>在 /proc/sys/kernel/core_pattern 文件中写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E<br></code></pre></td></tr></table></figure><p>安装好apport 后可以通过apport对core 进行收集，core文件保存在/var/lib/apport/coredump/ 目录下 （应该可以设置，没找到在哪设置的）</p><p>注：<br>Apport 并不直接用于分析 core 文件。它主要用于收集和报告应用程序崩溃信息，并将其提交给开发人员或错误报告系统。<br>使用 Apport 收集 core 文件有以下优点：</p><ol><li><p>自动收集和报告：Apport 可以自动捕获应用程序的崩溃信息，并生成相应的崩溃报告。这样，你无需手动分析 core 文件，而是可以直接获得一个包含崩溃信息的报告。</p></li><li><p>附带环境信息：Apport 的崩溃报告通常会包含应用程序崩溃时的环境信息，如操作系统版本、软件包版本、硬件信息等。这些信息对于开发人员来说是非常有用的，可以帮助他们更好地理解和重现崩溃问题。</p></li><li><p>易于提交和跟踪：Apport 默认会将崩溃报告上传到错误报告系统（如 Launchpad），使开发人员能够轻松地接收和跟踪报告。这样，开发人员可以更快地了解和解决崩溃问题。</p></li><li><p>用户友好：Apport 的崩溃报告通常以用户友好的方式呈现，包含易于理解的错误消息、堆栈跟踪和其他相关信息。这使得用户能够更好地理解崩溃问题，并提供有用的反馈。</p></li></ol><h3 id="调试代码">调试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  *(<span class="hljs-type">int</span> *)<span class="hljs-number">0</span> = <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="gdb加载core文件">gdb加载core文件</h3><div class="code-wrapper"><pre><code class="hljs">gdb app corefile</code></pre></div><p>不需要加 app 的 args</p><h3 id="dmesg-查看内核日志">dmesg 查看内核日志</h3><p>情景回顾：程序启动后直接被kill掉，没有core dump 等报错信息，通过dmesg 查看内核日志发现是由于 OOM 被系统直接杀掉了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>core dump</tag>
      
      <tag>core file</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template_meta_program</title>
    <link href="/2023/02/14/template-meta-program/"/>
    <url>/2023/02/14/template-meta-program/</url>
    
    <content type="html"><![CDATA[<h2 id="常用方法">常用方法</h2><h3 id="enable-if">enable_if</h3><p><a href="https://www.cnblogs.com/3d-gis/articles/14392648.html">https://www.cnblogs.com/3d-gis/articles/14392648.html</a></p><p>std::enable_if&lt;&gt;是一种类型萃取（type trait），<br>它会根据一个作为其（第一个）模 板参数的编译期表达式决定其行为：</p><ul><li>如果这个表达式结果为 true，它的 type 成员会返回一个类型：<br>– 如果没有第二个模板参数，返回类型是 void。<br>– 否则，返回类型是其第二个参数的类型。</li><li>如果表达式结果 false，则其成员类型是未定义的。根据模板的一个叫做 SFINAE （substitute failure is not an error，替换失败不是错误）的规则， 这会导致包含 std::enable_if&lt;&gt;表达式的函数模板被忽略掉</li></ul><h2 id="基础">基础</h2><ol><li><p>模板函数和模板成员函数只有在被调用的时候才会实例化，从而允许只使用部分模版</p></li><li><p>两段编译检查：</p></li></ol><ul><li>模板定义阶段：语法检查，未定义类型检查，与模板参数无关部分的检查</li><li>模板实例化阶段：与模板参数相关的检查</li></ul><p>3.a template declaration cannot appear at block scope<br>通常模板（包含 Alias Templates）只可以被声明和定义在 global/namespace 作用域， 或者在一个类的声明中。</p><ol start="4"><li>推断指引（Deduction Guides）是C++17语法。作用是当创建一个模板类时，可以通过 “推断指引  来提供额外地模板参数推断规则，或者修正已有的模板参数推断规则。<br><a href="https://www.cnblogs.com/GEEK-ZHAO/p/15766331.html">https://www.cnblogs.com/GEEK-ZHAO/p/15766331.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>readthedoc_usage</title>
    <link href="/2023/02/14/readthedoc-usage/"/>
    <url>/2023/02/14/readthedoc-usage/</url>
    
    <content type="html"><![CDATA[<p>电子书搭建教程：<br><a href="https://zhuanlan.zhihu.com/p/388640347">https://zhuanlan.zhihu.com/p/388640347</a></p><p>read the docs 官网：<br><a href="https://readthedocs.org/?utm_source=testingpai.com">https://readthedocs.org/?utm_source=testingpai.com</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>compile_runtime_error</title>
    <link href="/2023/02/14/compile-runtime-error/"/>
    <url>/2023/02/14/compile-runtime-error/</url>
    
    <content type="html"><![CDATA[<h3 id="编译时报错">编译时报错</h3><h4 id="找不到依赖库的头文件">找不到依赖库的头文件</h4><p>找不到依赖库的头文件，找不到依赖库中头文件所包含的头文件<br>bcloud 引用依赖库时，头文件需要 HEADER 标签发布到output 中。</p><p>发布到output 的头文件，如果包含了库中的其他头文件，也需要一起发布到output 中</p><p>为什么之前没有注意这个问题呢？因为一般头文件不会引用自己所不需要的头文件，只有其需要被引用时，才进行 include。而如果将库中的头文件引用操作放在 .cc 文件，其所include 的头文件的内容直接就编译到库中，在其他库所引用该库时，也就不会存头文件找不到另外一个头文件的问题了。</p><h4 id="undefined-reference-to-atan2-finite’">undefined reference to `__atan2_finite’</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-literal">[ERROR]</span> fail <span class="hljs-keyword">to</span> compile baidu/adu-lab/framework/output/bin/radar_fusion_app ip:<span class="hljs-number">10.61</span>.<span class="hljs-number">192.37</span><br> err:bc_out/baidu/adu-lab/framework/app/radar_fusion/baidu_adu-lab_framework_radar_fusion_app_app_radar_fusion.cpp.o: In <span class="hljs-keyword">function</span> `v2x::sensor::radar::radar_fusion::radar<span class="hljs-constructor">_msg_proc(<span class="hljs-params">int</span>, <span class="hljs-params">std</span>::<span class="hljs-params">shared_ptr</span>&lt;<span class="hljs-params">os</span>::<span class="hljs-params">v2x</span>::<span class="hljs-params">device</span>::RadarObstacles <span class="hljs-params">const</span>&gt; <span class="hljs-params">const</span>&amp;)</span>&#x27;:<br>/home/bcloud/bcloud_data/EE/BCLOUD_PROTOBUF/CompileServer/Task/bb84d71b78676b10f34e635275115abf/baidu/adu-lab/framework/app/radar_fusion/radar_fusion.cpp:<span class="hljs-number">118</span>: undefined reference <span class="hljs-keyword">to</span> `__atan2_finite&#x27;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/google/filament/issues/2875">https://github.com/google/filament/issues/2875</a><br><a href="https://stackoverflow.com/questions/62334452/fast-math-cause-undefined-reference-to-pow-finite">https://stackoverflow.com/questions/62334452/fast-math-cause-undefined-reference-to-pow-finite</a><br><a href="https://github.com/google/filament/issues/2146">https://github.com/google/filament/issues/2146</a></p><p>1、去掉 fast-math<br>2、或加上 -fno-builtin +#include&lt;tgmath.h&gt;</p><h3 id="运行时报错">运行时报错</h3><h4 id="undefined-symbol">undefined symbol</h4><p>1、运行时报 undefined symbol，可能是编译该so 时没有实际链接依赖库，只是使用了头文件，比如编libmsf_Ucommon_Umath.so时没有链接libopencv_core.so，但还是能编译通过，因为其在系统目录下找到了头文件，有些情况仅使用头文件就编译通过了。。</p><p>TODO：具体什么情况只需要头文件</p><p>2、<br>E1219 23:24:25.009349  7549 class_loader_utility.cc:218] [mainboard]LibraryLoadException: /home/caros/work/airos_fusion/baidu/adu-lab/airos/output/3rd/libmodules_Sperception-fusion_Salgorithm_Sfusion_Utracker_Stracker_Sprocess_Slibmsf_Utracker_Uprocess.so: undefined symbol: _ZN9algorithm2ft5track14StateContainer9frequent_E</p><p>也是运行期间报 undefined symbol 问题，但 <em>ZN9algorithm2ft5track14StateContainer9frequent_E 这个符号在libmsf_Utracker_Uprocess.so 这个动态库里的，是作为其中一个类的    静态成员变量， 其使用形式为这种：<br>StateContainer() : vx_mean_filter</em>(frequent_), vy_mean_filter_(frequent_){};<br>其使用静态成员变量在初始化列表中对成员变量进行初始化，因此报错，这种形式应该在一些编译参数的设置下是允许的。</p><p>3、undefined symbol 也可能是因为编译链接的库和运行时链接的库版本不一致</p><h3 id="undefined-reference-google-isGoogleLoggingInited">undefined reference google::isGoogleLoggingInited()</h3><p>从baidu/adu-3rd/glog 引用了glog库<br>但是本地也有glog库，</p><p>笨方法：<br>删掉本地库后就ok了</p><p>卸载glog的方法：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//安装</span><br>sudo apt-<span class="hljs-built_in">get</span> install libgoogle-glog-<span class="hljs-built_in">dev</span><br><span class="hljs-comment">//卸载</span><br>sudo apt-<span class="hljs-built_in">get</span> remove libgoogle-glog-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>聪明方法：</p><p>使用 ldd命令 查看当前所链接的库是哪一个，是否是想要链接的库，使用export命令把想要链接的库放在前面</p><h3 id="cpplint-报错">cpplint 报错</h3><h4 id="static-extern-typedef等要放在声明前">static extern typedef等要放在声明前</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">select_npy_type</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> NPY_TYPES type = NPY_NOTYPE;<br>&#125;;  <span class="hljs-comment">// Default</span><br></code></pre></td></tr></table></figure><p>3行 : Storage-class specifier (static, extern, typedef, etc) should be at the beginning of the declaration</p><p>static 放在 const 前面即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译报错</tag>
      
      <tag>运行报错</tag>
      
      <tag>cpplint报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv_usage</title>
    <link href="/2023/02/14/opencv-usage/"/>
    <url>/2023/02/14/opencv-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="保存图片">保存图片</h3><figure class="highlight zephir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs zephir">cv::Mat m(<span class="hljs-number">1080</span>, <span class="hljs-number">1920</span>, CV_8UC3);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* m_ptr = m.ptr&lt;<span class="hljs-keyword">uchar</span>&gt;(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fgq_n = <span class="hljs-number">0</span>;<br>memcpy((void*)m_ptr, image_blob-&gt;cpu_data(), <span class="hljs-number">1080</span> * <span class="hljs-number">1920</span> * <span class="hljs-number">3</span>);<br>cv::imwrite(<span class="hljs-string">&quot;/home/caros/work/tmp/&quot;</span> + std::to_string(fgq_n++) + <span class="hljs-string">&quot;.png&quot;</span>, m);<br></code></pre></td></tr></table></figure><h3 id="cv-Mat">cv::Mat</h3><h4 id="基础概念">基础概念</h4><p><a href="https://zhuanlan.zhihu.com/p/507103729">OpenCV:Mat中的step、elemSize、channel和任意内存访问</a></p><h4 id="判断是否连续">判断是否连续</h4><p>isContinuous() 方法可以判断一个 cv::Mat 对象是否在内存中是连续的。</p><p>如果是连续的返回 true，如果在每一行的结尾跳过一部分内存地址到达下一行，那么就会返回 false。</p><p>所以很显然，1x1 和 1xN 的对象一定是连续的，因为只有一行数据。</p><p>使用 <code>cv::Mat::create</code> 创建的对象也是连续的，表示直接开辟了一个连续的内存空间进行对象的创建。</p><p>但是，如果从一个 cv::Mat 对象中截取了一部分数据，或者构造数据来自外部存储的数据，那么就不一定是连续的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::Mat newM = cv::Mat::<span class="hljs-built_in">zeros</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, CV_32FC1);<br><br>cout &lt;&lt; newM.<span class="hljs-built_in">isContinuous</span>() &lt;&lt; endl;<br><br>cv::Mat segM = newM.<span class="hljs-built_in">colRange</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>);<br><br>cout &lt;&lt; segM.<span class="hljs-built_in">isContinuous</span>() &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><h4 id="非连续Mat-如何拷贝">非连续Mat 如何拷贝</h4><p>非连续是指行之间的地址是间断的，但是同一行的内存是连续，所以可以按行复制</p><p>下面是把非连续的 Mat 复制给vector.data(), 把非连续变成了连续，如果不关注连续还是非连续，可以直接 a_mat.copyTo(b_mat)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// apollo</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BEVObstacleDetector::Mat2Vec</span><span class="hljs-params">(<span class="hljs-type">const</span> cv::Mat &amp;im, <span class="hljs-type">float</span> *data)</span> </span>&#123;<br>  <span class="hljs-built_in">ACHECK</span>(<span class="hljs-literal">nullptr</span> != data);<br>  <span class="hljs-type">int</span> rh = im.rows;<br>  <span class="hljs-type">int</span> rw = im.cols;<br>  <span class="hljs-type">int</span> rc = im.<span class="hljs-built_in">channels</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rc; ++i) &#123;<br>    cv::<span class="hljs-built_in">extractChannel</span>(im, cv::<span class="hljs-built_in">Mat</span>(rh, rw, CV_32FC1, data + i * rh * rw), i);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 申请一块大内存</span><br><span class="hljs-function">Mat <span class="hljs-title">buffer</span><span class="hljs-params">(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">256</span>, <span class="hljs-number">5</span>, CV_32F)</span></span>;<br><br><span class="hljs-comment">// useful 是将要实际使用的行数</span><br><span class="hljs-comment">// rowRange 只是创建了个 mat 的 head，不会申请新的</span><br>handle = buffer.<span class="hljs-built_in">rowRange</span>(<span class="hljs-number">0</span>, useful)<br><span class="hljs-comment">// handle 相当于是 0 - useful 行的浅拷贝</span><br></code></pre></td></tr></table></figure><h3 id="cv-cuda-GpuMat">cv::cuda::GpuMat</h3><h4 id="cuda-kernel-访问-GpuMat">cuda kernel 访问 GpuMat</h4><p>GpuMat的数据在gpu 上，那么如何在 cuda kernel 中访问 GpuMat 呢？可以直接访问吗，答案是不可以，因为 cuda kernel 不可以传入不带__device__修饰的构造和析构的对象，就是说GpuMat 的构造和析构没有用__device__修饰，所以无法直接传递给kernel</p><p>opencv 提供了一个 PtrStepSz 类，其构造和析构函数是用__device__修饰的，所以可以传递给kernel。</p><p>另外一个问题是 GpuMat 是如何转化为 PtrStepSz 的，在GpuMat 的成员函数实现了GpuMat 到 PtrStepSz 的类型转换，因此在调用kernel 的时候直接传递GpuMat，而在kernel 的形参中用 PtrStepSz 进行接收</p><p>详细说明: <a href="https://stackoverflow.com/questions/73171101/how-does-cvcudagpumat-turn-into-cvcudaptrstepsz-when-passed-to-a-kernel">https://stackoverflow.com/questions/73171101/how-does-cvcudagpumat-turn-into-cvcudaptrstepsz-when-passed-to-a-kernel</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GLOG_usage</title>
    <link href="/2023/02/14/GLOG-usage/"/>
    <url>/2023/02/14/GLOG-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="cpp-code">cpp code</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">头文件包含：<br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;glog/logging.h&quot;</span>   <span class="hljs-comment">// 添加头文件</span><br><br>初始化：<br>FLAGS_log_dir = <span class="hljs-string">&quot;./&quot;</span>;  <span class="hljs-comment">// 指定地址log文件路径，默认是在/tmp/</span><br>google::<span class="hljs-constructor">InitGoogleLogging(<span class="hljs-params">argv</span>[0])</span>;   <span class="hljs-comment">// 设置log文件名称，argv[0].INFO</span><br><br>记录信息：<br><span class="hljs-constructor">LOG(WARNING)</span> &lt;&lt; <span class="hljs-string">&quot;WARNING: this is a test for glog&quot;</span>; <br><span class="hljs-constructor">LOG(INFO)</span> &lt;&lt; <span class="hljs-string">&quot;INFO: this is a test for glog&quot;</span>;<br></code></pre></td></tr></table></figure><p>还有更高阶用法：<a href="https://rpg.ifi.uzh.ch/docs/glog.html">https://rpg.ifi.uzh.ch/docs/glog.html</a></p><p><a href="https://my.oschina.net/u/4320185/blog/3755592">https://my.oschina.net/u/4320185/blog/3755592</a></p><h2 id="日志等级设置">日志等级设置</h2><h3 id="环境变量方式">环境变量方式</h3><p>通过export 设置<br>GLOG_alsologtostderr=1  error 和 fatal 输出到 stderr<br>GLOG_logtostderr=1  所有log 都输出到stderr<br>GLOG_stderrthreshold=2<br>把严重等级&gt;=指定等级的log信息额外输出到stderr中(默认为2,即ERROR和FATAL)</p><h3 id="GFLAGS-方式">GFLAGS 方式</h3><p>glog支持的FLAGS：<a href="https://github.com/google/glog/blob/674283420118bb919f83ceb3d9dee31ef43ff3aa/src/logging.cc">https://github.com/google/glog/blob/674283420118bb919f83ceb3d9dee31ef43ff3aa/src/logging.cc</a></p><p>VLOG(x) &lt;&lt; “message xxx”;<br>可以通过命令行&quot;–v=n&quot;,来控制VLOG的输出,VLOG(x),x&lt;=n的情况,VLOG会输出,否则不输出.v默认为0,所以默认情况下VLOG(-1),VLOG(0)能够输出<br>The default verbosity level for glog’s VLOG is 0, which means that no verbose output will be generated unless the --v flag is used or google::SetVLOGLevel() is called.<br><code>./my_program --v=2</code>  or  <code>google::SetVLOGLevel(&quot;my_file.cc&quot;, 2);</code></p><p>VLOG(level) 和 LOG(level) 记录的信息等级是相反的<br>VLOG 记录更详细的日志，INFO=&gt;WARNING=&gt;ERROR (v: 0=&gt;1=&gt;2), 当level&lt;=v 时记录<br>LOG 记录更高级的日志，ERROR=&gt;WARNING=&gt;INFO (minloglevel 2=&gt;1=&gt;0), 当level&gt;=miniloglevel 时记录</p><p>日志文件写入没有标准错误写入及时</p>]]></content>
    
    
    
    <tags>
      
      <tag>glog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFLAG_usage</title>
    <link href="/2023/02/14/GFLAG-usage/"/>
    <url>/2023/02/14/GFLAG-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="GFLAG使用记录">GFLAG使用记录</h3><p>在main()中调用gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true) 解析传入GFLAGS_xxx，在运行bin文件的时候，可以选择用命令传入flags参数，或者将参数放在一个文本文件中</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gflags/gflags.h&quot;</span></span><br><span class="hljs-built_in">DEFINE_string</span>(local_ip, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;genenral local ip&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>    gflags::<span class="hljs-built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 解析GFLAS_XX </span><br>    std::cout &lt;&lt; FLAGS_local_ip &lt;&lt; std::endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>g++ main.cpp 生成a.out可执行文件后，<br>命令行传入FLAGS_local_ip:<br><code>./a.out --local_ip=127.0.0.2</code></p><p>文本文件传入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> flags.txt<br>--local_ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>./a.out --flagfile=./flags.txt</p><p>如果不设置local_ip参数，默认打印 127.0.0.1；设置locol_ip参数后打印 127.0.0.2</p><p><strong>Note</strong>:</p><p>define有且只能出现一次，所以当头文件会被多个文件包含时，一定不能定义在头文件中<br>因此，DEFINE在cpp中，DECLARE在头文件中，若只想被一个.cpp文件使用，则只定义在此.cpp文件中而不在.h文件中声明</p>]]></content>
    
    
    
    <tags>
      
      <tag>gflag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bazel_usage</title>
    <link href="/2023/02/13/bazel-usage/"/>
    <url>/2023/02/13/bazel-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="bazel安装">bazel安装</h3><p>官方教程：<a href="https://bazel.build/install/ubuntu?hl=zh-cn">https://bazel.build/install/ubuntu?hl=zh-cn</a></p><h3 id="基础教程">基础教程</h3><p><a href="https://bazel.build/start/cpp?hl=zh-cn">https://bazel.build/start/cpp?hl=zh-cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>bazel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orin_env</title>
    <link href="/2023/02/13/orin-env/"/>
    <url>/2023/02/13/orin-env/</url>
    
    <content type="html"><![CDATA[<h3 id="jetpack-sdk-安装">jetpack sdk 安装</h3><h4 id="确认nvidia-apt资源列表">确认nvidia apt资源列表</h4><p>cat /etc/apt/sources.list.d/nvidia-l4t-apt-source.list</p><p>确认是否为</p><p>deb <a href="https://repo.download.nvidia.com/jetson/common">https://repo.download.nvidia.com/jetson/common</a> r35.1 main</p><p>deb <a href="https://repo.download.nvidia.com/jetson/t234">https://repo.download.nvidia.com/jetson/t234</a> r35.1 main</p><h4 id="校正时间和时区">校正时间和时区</h4><p>修改系统时间和时区</p><p>系统时间不准确，可能无法连网、获取nvidia 安装包索引</p><h4 id="安装jetpack5-0-2">安装jetpack5.0.2</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">dist-upgrade</span><br><span class="hljs-keyword"></span>sudo reboot<br>sudo apt-<span class="hljs-keyword">cache </span><span class="hljs-keyword">show </span>nvidia-<span class="hljs-keyword">jetpack </span>查看<span class="hljs-keyword">jetpack </span>sdk 版本，确认为<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br>sudo apt <span class="hljs-keyword">install </span>nvidia-<span class="hljs-keyword">jetpack</span><br><span class="hljs-keyword"></span>````<br><br><span class="hljs-comment">#### 查看cuda、cudnn、tensorrt 版本</span><br></code></pre></td></tr></table></figure><p>cat /usr/loca/cuda/version.json<br>cuda 11.4.14<br>cat /usr/include/aarch64-linux-gnu/cudnn_version_v8.h<br>cudnn 8.4.1<br>cat /usr/include/aarch64-linux-gnu/NvInferVersion.h<br>tensorrt 8.4.1.5</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 安装jtop<br></code></pre></td></tr></table></figure><p>sudo apt install python3-pip<br>sudo -H pip3 install -U jetson-stats<br>sudo jtop 验证是否可用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 开启最大性能<br></code></pre></td></tr></table></figure><p>sudo nvpmodel -m 0 &amp;&amp; sudo jetson_clocks<br>sudo jetson_clocks --fan<br>jtop 查看 NV Power[0] 是否为MAXN<br>重启后失效</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### wget 报错<br></code></pre></td></tr></table></figure><p>–2018-10-01 12:11:19--  <a href="https://url">https://url</a><br>Connecting to #:443… connected.<br>OpenSSL: error:14082174:SSL routines:ssl3_check_cert_and_algorithm:dh key too small<br>Unable to establish SSL connection.</p><div class="code-wrapper"><pre><code class="hljs">Here's a simple workaround for wget: use wget --cipher 'DEFAULT:!DH' in place of wget.https://stackoverflow.com/questions/52588948/problem-with-wget-command-ssl3-check-cert#### 终端重复打印 Message xxx终端报Message from syslogd kernel:unregister_netdevice: waiting for eth0 to become freehttps://blog.51cto.com/xiao987334176/1910715没有找到链接里说的     #*.emerg       16 # provides UDP syslog reception                                           17 #module(load=&quot;imudp&quot;)       18 #input(type=&quot;imudp&quot; port=&quot;514&quot;)             19                          20 # provides TCP syslog reception                                                                 21 #module(load=&quot;imtcp&quot;)                                                                                        22 #input(type=&quot;imtcp&quot; port=&quot;514&quot;)                                                              23                                                  24 # provides kernel logging support and enable non-kernel klog messages                                           25 #module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)   把25行注释掉  重启rsyslog服务/etc/init.d/rsyslog restart</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>orin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug_record</title>
    <link href="/2023/02/13/bug-record/"/>
    <url>/2023/02/13/bug-record/</url>
    
    <content type="html"><![CDATA[<h2 id="编译问题">编译问题</h2><h3 id="Wl-–no-as-needed">-Wl,–no-as-needed</h3><p><a href="https://sourceware.org/binutils/docs-2.16/ld/Options.html">https://sourceware.org/binutils/docs-2.16/ld/Options.html</a><br>只有简单的介绍，不能用来分析下面的问题。</p><ul><li><p>问题描述<br>在一个可执行程序A 和一个动态库B 中，会使用到另外一个动态库C 中的单例，依赖关系是 A依赖B 和 C，B 依赖C，在链接过程中使用–as-no-needed 修饰B 时，会导致A 和 B 中的单例对象冲突，表现为 A 中对单例的初始化，在B 中没有感应到</p></li><li><p>原因<br>可能是内存中存在了两个单例对象，</p></li></ul><h2 id="linux-环境问题">linux 环境问题</h2><ul><li>问题描述：</li></ul><p>程序有许多printf 时，使用管道符或重定向到文件均比直接打印到标准输出的性能要好</p><ul><li>原因: <a href="https://www.cnblogs.com/lhfcws/p/3197735.html">https://www.cnblogs.com/lhfcws/p/3197735.html</a></li></ul><p>Console 会给多个进程共享，因此对console操作时会存在进程同步和缓存问题。</p><p>ssh远程连接没有该问题，只有在本地运行才有</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++和shell脚本的输入参数设置</title>
    <link href="/2022/11/21/cpp-shell-input-args/"/>
    <url>/2022/11/21/cpp-shell-input-args/</url>
    
    <content type="html"><![CDATA[<h2 id="C-可执行文件输入参数">C++ 可执行文件输入参数</h2><h3 id="1-getopt-long-函数">1. getopt_long()函数</h3><p>使用手册： <a href="https://linux.die.net/man/3/getopt_long">https://linux.die.net/man/3/getopt_long</a></p><h3 id="2-设置参数选项">2. 设置参数选项</h3><p>参数选项的形式可以分为两种，一是 -n, 二是 --name</p><p>-n 这种需要设置短选项字符串；–name 这种需要设置长选项结构体。</p><h4 id="2-1-段选项字符串">2.1 段选项字符串</h4><p>书写规则：</p><ul><li>多个短选项可以连在一起</li><li>如果某个要解析的选项需要一个参数，则在选项名后面跟一个冒号</li><li>如果某个要解析的选项的参数可选，则在选项名后面跟两个冒号</li></ul><p>一般如这种形式:<br><code>const char* short_options = &quot;hx:t:c:&quot;</code><br>该字符串解释为：</p><div class="code-wrapper"><pre><code class="hljs">-h -t t_arg-c c_arg</code></pre></div><p>细心的话为发现多了h后面还有一个x:没有被说明，因为h(help)后面不需要接参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* short_options = <span class="hljs-string">&quot;hx:n:h:&quot;</span>;    <span class="hljs-comment">// 带参数的，要使用的命令，需要在这里声明</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">option</span> long_options[] = &#123;<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;,<br>        &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg usage</title>
    <link href="/2022/09/02/ffmpeg-usage/"/>
    <url>/2022/09/02/ffmpeg-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="ffmpeg-命令行">ffmpeg 命令行</h3><blockquote><p><a href="https://blog.csdn.net/avsuper/article/details/54918465?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;utm_relevant_index=6">FFMPEG命令行详细参数</a></p></blockquote><p>播放rgb格式的视频</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ffplay</span> -f rawvideo -pixel_format bgr24 -video_size <span class="hljs-number">1280</span>x1280 -framerate <span class="hljs-number">10</span> video_cuda_1.rgb <br></code></pre></td></tr></table></figure><p>播放 h264格式的视频</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ffplay</span> -f h264 -width <span class="hljs-number">1920</span> -height <span class="hljs-number">1080</span> record_424_sensor_ipcamera_h264_10_128_156_101.h264<br></code></pre></td></tr></table></figure><p>转码 h264 =&gt; mp4</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ffmpeg <span class="hljs-literal">-i</span> Free_Test_Data_15MB_MP4.h264 <span class="hljs-literal">-framerate</span> <span class="hljs-number">30</span> <span class="hljs-literal">-vcodec</span> <span class="hljs-built_in">copy</span> <span class="hljs-operator">-f</span> mp4 output.mp4<br></code></pre></td></tr></table></figure><p>转码 mp4 =&gt; h264</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ffmpeg -i Free_Test_Dat<span class="hljs-built_in">a_15MB</span>_MP4.mp4 -vcodec libx264 -acodec aac Free_Test_Dat<span class="hljs-built_in">a_15MB</span>_MP4.<span class="hljs-number">264</span><br></code></pre></td></tr></table></figure><p>yuv视频 =&gt; jpeg</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ffmpeg</span> -pix_fmt yuyv422 -s <span class="hljs-variable">$&#123;w&#125;</span>x<span class="hljs-variable">$&#123;h&#125;</span> -i <span class="hljs-variable">$&#123;name&#125;</span>.yuv <span class="hljs-variable">$&#123;name&#125;</span>.jpg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>performace-test</title>
    <link href="/2022/08/30/performace-test/"/>
    <url>/2022/08/30/performace-test/</url>
    
    <content type="html"><![CDATA[<h3 id="perf">perf</h3><h4 id="perf-安装">perf 安装</h4><p><a href="https://xiaoyanzhuo.github.io/2019/01/18/Perf-Tool.html">https://xiaoyanzhuo.github.io/2019/01/18/Perf-Tool.html</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> update<br><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> install linux-tools-common linux-tools-generic linux-tools-`uname -r`<br></code></pre></td></tr></table></figure><h4 id="orin上安装">orin上安装</h4><p>下载 JP-x.x.x Driver Package Sources:<br><a href="https://developer.nvidia.com/embedded/l4t/r35_release_v1.0/sources/public_sources.tbz2">https://developer.nvidia.com/embedded/l4t/r35_release_v1.0/sources/public_sources.tbz2</a></p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">复制压缩包到orin<br><span class="hljs-built_in">cd</span>到 kernel/kernel-4.9/tools/perf<br>make<br>./perf --version<br></code></pre></td></tr></table></figure><h4 id="常规用法">常规用法</h4><p>基础教程：<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/common-perf-commands_getting-started-with-perf">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/common-perf-commands_getting-started-with-perf</a></p><p>用 perf 监控相关指标，生成报告，然后可以将报告用 <a href="https://profiler.firefox.com/">https://profiler.firefox.com/</a> 进行查看</p><p>步骤：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>、sudo perf record -e cpu-<span class="hljs-keyword">clock </span>-g -p PID sleep <span class="hljs-number">10</span><br><span class="hljs-number">2</span>、perf <span class="hljs-keyword">script </span>-i perf<span class="hljs-meta">.data</span> &amp;&gt; perf.unfold<br></code></pre></td></tr></table></figure><p>然后将 .unfold 文件在 <a href="http://profiler.firefox.com">profiler.firefox.com</a> or speedscope.app 网站上打开</p><h5 id="perf-报错">perf 报错</h5><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tcl">Permission <span class="hljs-keyword">error</span> mapping pages.<br>Consider increasing /<span class="hljs-keyword">proc</span>/sys/kernel/perf_event_mlock_kb,<span class="hljs-title"></span><br><span class="hljs-title">or</span> try<span class="hljs-title"> again</span> with<span class="hljs-title"> a</span> smaller<span class="hljs-title"> value</span> of -m/--mmap_pages.<br>(current<span class="hljs-title"> value:</span> 4294967295,0)<br></code></pre></td></tr></table></figure><p>加上 -m 2参数，要加在 sleep 10 前面变成</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> perf record -e cpu-clock -g -p PID -m <span class="hljs-number">2</span> sleep <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="查看TLB命中率">查看TLB命中率</h4><p><a href="https://blog.csdn.net/hbuxiaofei/article/details/128402495">https://blog.csdn.net/hbuxiaofei/article/details/128402495</a><br>查看系统的TLB命中率 <code> perf stat -e iTLB-load,iTLB-load-misses -a -I 1000</code><br>查看某个进程TLB 命中率, ctrl + c 后输出结果 <code>perf stat -e iTLB-load,iTLB-load-misses -a -p pid</code></p><h5 id="Flame-Graph生成火焰图">Flame Graph生成火焰图</h5><p>Flame Graph项目位于GitHub上：<br><a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p><p>git clone <a href="https://github.com/brendangregg/FlameGraph.git">https://github.com/brendangregg/FlameGraph.git</a><br>./FlameGraph/stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded<br>./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</p><h3 id="nvidia-system">nvidia-system</h3><p>orin上</p><p>/opt/nvidia/nsight-systems/2022.3.3/target-linux-tegra-armv8/nsys profile -y 60 -d 20 --gpuctxsw=true -o out_file mainboard -d ./dag/test.dag</p><p>程序开始运行60s后,记录20s.然后core dump 生成记录报告out_file</p>]]></content>
    
    
    
    <tags>
      
      <tag>nsight</tag>
      
      <tag>nsys</tag>
      
      <tag>sysbench</tag>
      
      <tag>perf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hhd-ssd-emmc</title>
    <link href="/2022/08/30/hhd-ssd-emmc/"/>
    <url>/2022/08/30/hhd-ssd-emmc/</url>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>HDD，即硬盘驱动器（HardDiskDrive），一般指机械硬盘；多层盘，每层一个磁头<br>SSD，即固态硬盘（Solid State Drives）；<br>EMMC，(Embedded Multi Media Card) 一种内嵌式存储器标准规格；<br>NAND，即Nand-flash，闪存的一种。<br>SSD 和 EMMC 都是基于NAND 的</p><h3 id="ssd-为什么越写越慢-（磁盘空间快慢时变慢）">ssd 为什么越写越慢?（磁盘空间快慢时变慢）</h3><p><a href="http://www.ssdfans.com/?p=90902">http://www.ssdfans.com/?p=90902</a><br>因为垃圾回收机制</p><h3 id="hhd为什么随机读写很慢">hhd为什么随机读写很慢</h3><p><a href="https://zhuanlan.zhihu.com/p/20085866">https://zhuanlan.zhihu.com/p/20085866</a><br>因为磁头要来来回回移动</p><h3 id="ssd的分类">ssd的分类</h3><p><a href="https://www.kingston.com.cn/cn/community/articledetail/articleid/48543">https://www.kingston.com.cn/cn/community/articledetail/articleid/48543</a><br>SSD 技术：NVMe、SATA、M.2<br>NVMe (Non-Volatile Memory Express) 是一种通信接口和驱动程序，为基于 PCIe 的 SSD 定义了命令集和功能集<br>PICe（NVMe） 比 SATA 更快</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssd</tag>
      
      <tag>emmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-pip</title>
    <link href="/2022/08/28/python-pip/"/>
    <url>/2022/08/28/python-pip/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>有条件直接使用 conda的虚拟环境</p><h3 id="miniconda">miniconda</h3><p>brew install miniconda<br>安装miniconda：<a href="https://www.jianshu.com/p/992cadf45994">https://www.jianshu.com/p/992cadf45994</a></p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> env list  查看已有的python 环境<br><span class="hljs-attribute">conda</span> create --name py36 python=<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> 指定 Python 版本创建虚拟环境<br><span class="hljs-attribute">conda</span> activate py36   激活 py36 的虚拟环境<br></code></pre></td></tr></table></figure><h3 id="python2安装pip">python2安装pip</h3><p>wget <a href="https://bootstrap.pypa.io/pip/2.7/get-pip.py">https://bootstrap.pypa.io/pip/2.7/get-pip.py</a><br>下载成功后执行 python2 <a href="http://get-pip.py">get-pip.py</a></p><p>指定python 安装numpy库：<br>python2 -m pip install numpy</p><h3 id="python3安装-pip">python3安装 pip</h3><p>apt install python3-pip</p><h3 id="windows-启动-conda">windows 启动 conda</h3><p>$ source C:/Users/fgq/miniconda3/Scripts/activate base</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc 的标准库和头文件</title>
    <link href="/2022/07/19/gcc-so-include/"/>
    <url>/2022/07/19/gcc-so-include/</url>
    
    <content type="html"><![CDATA[<h3 id="libgcc-s-so-1是什么">libgcc_s.so.1是什么</h3><p><a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">The GCC low-level runtime library</a></p><p>会在有需要的时候自动启动的C 运行时库，可以替代某些机器完成整数、浮点运算，还有一些其他的功能。</p><h3 id="运行时库">运行时库</h3><p>应用程序和操作系统之间的桥梁，对操作系统硬件的抽象，包括对IO 操作、程序启动和程序退出、栈等的实现。不同的操作系统对应不同的运行时库，但提供的接口基本一致，比如windows 和linux 的运行时库，都提供fread 功能，但是其实现应该是不一样的，fread 就包括在运行时库中。</p><h3 id="编译参数顺序">编译参数顺序</h3><p>LINKFLAGS_AFTER_LIBS(False)决定cxxflags、ldflags（编译参数和链接参数）是放在库前还是库后，对cmake 和bcloud 而言有用，对gcc 而言没有所谓这些参数之分，都是编译参数，链接的库名也都是编译参数，但是编译参数之间的顺序可能会影响能否编译成功</p><h3 id="libc-so"><a href="http://libc.so">libc.so</a></h3><p>/usr/lib/aarch64-linux-gnu/libc.so 是个链接脚本，表示在链接时去链哪个库，可以根据需要选择动态库还是静态库</p><h3 id="符号集版本">符号集版本</h3><p>func@GLIBC_2.31</p><p>GLIBC_2.31表示符号集版本，向下兼容，即如果需要func@GLIBC_2.29时也没问题</p><h3 id="强符号和若符号">强符号和若符号</h3><p>符号表中的 STRONG 和 WEAK</p><p>强符号：全局且初始化的参数和默认的函数，都属于强符号，强符号全局只能唯一，找不到直接报 undefined  reference</p><p>弱符号：全局且未初始化的参数，也可以在代码中来指定。弱符号在链接时候找不到可以暂时用0地址代替，链接时不会报 undefined，作为插件接口或用户自定义接口使用更加方便。</p><h3 id="gcc-安装">gcc 安装</h3><p><a href="https://wenku.baidu.com/view/b73c43055a0102020740be1e650e52ea5418ce77.html?_wkts_=1676342805235">https://wenku.baidu.com/view/b73c43055a0102020740be1e650e52ea5418ce77.html?_wkts_=1676342805235</a></p><p>wget <a href="https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.5.0">https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.5.0</a></p><p>Note: gcc 安装后 c 和 c++ 的标准库还是原来的版本</p><h3 id="添加系统头文件搜索路径">添加系统头文件搜索路径</h3><p><a href="https://blog.csdn.net/yjk13703623757/article/details/83154578">https://blog.csdn.net/yjk13703623757/article/details/83154578</a></p><p>gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）</p><h3 id="gcc-低版本问题">gcc 低版本问题</h3><p>gcc4 gcc5 不支持直接使用enum 作为map 的键指，需要自己指定hash 方法。</p><h3 id="lib-ld-linux-aarch64-so-1-作用">/lib/ld-linux-aarch64.so.1 作用</h3><p>其是 aarch64平台上的动态链接器，ld-linux-aarch64.so.1 <a href="http://xn--ld-2-zi0i.31.so">是ld-2.31.so</a> 的软链接</p><p>linux man 手册介绍：<a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">https://man7.org/linux/man-pages/man8/ld.so.8.html</a></p><p>可执行的 ELF 程序中，将使用的动态链接器路径存储在 .interp section 中，或者也可以手动执行命令</p><p><code>/lib/ld-linux.so.*  [OPTIONS] [PROGRAM [ARGUMENTS]]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -l /bin/ls</span><br><br>Elf file type is DYN (Shared object file)<br>Entry point 0x67d0<br>There are 13 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040<br>                 0x00000000000002d8 0x00000000000002d8  R      0x8<br>  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318<br>                 0x000000000000001c 0x000000000000001c  R      0x1<br>      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<br>  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x00000000000036a8 0x00000000000036a8  R      0x1000<br>  LOAD           0x0000000000004000 0x0000000000004000 0x0000000000004000<br>                 0x0000000000013581 0x0000000000013581  R E    0x1000<br>  LOAD           0x0000000000018000 0x0000000000018000 0x0000000000018000<br>                 0x0000000000008b50 0x0000000000008b50  R      0x1000<br>  LOAD           0x0000000000021010 0x0000000000022010 0x0000000000022010<br>                 0x0000000000001258 0x0000000000002548  RW     0x1000<br>  DYNAMIC        0x0000000000021a58 0x0000000000022a58 0x0000000000022a58<br>                 0x0000000000000200 0x0000000000000200  RW     0x8<br>  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338<br>                 0x0000000000000020 0x0000000000000020  R      0x8<br>  NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358<br>                 0x0000000000000044 0x0000000000000044  R      0x4<br>  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338<br>                 0x0000000000000020 0x0000000000000020  R      0x8<br>  GNU_EH_FRAME   0x000000000001d24c 0x000000000001d24c 0x000000000001d24c<br>                 0x000000000000092c 0x000000000000092c  R      0x4<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br>  GNU_RELRO      0x0000000000021010 0x0000000000022010 0x0000000000022010<br>                 0x0000000000000ff0 0x0000000000000ff0  R      0x1<br></code></pre></td></tr></table></figure><p>当误删掉 ld-linux-aarch64.so.1, 可执行程序凭借 .interp section 找不到正确的动态链接器，因此什么命令也无法执行，但是还可以通过 /lib/ld-2.31.so /bin/ln 命令对原本的软链接做还原。</p><p>参考: <a href="https://www.zhihu.com/question/385135873/answer/1139858267">https://www.zhihu.com/question/385135873/answer/1139858267</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>so</tag>
      
      <tag>include</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-usage</title>
    <link href="/2022/07/14/docker-usage/"/>
    <url>/2022/07/14/docker-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="docker-用法">docker 用法</h3><p>docker教程： <a href="https://yeasy.gitbook.io/docker_practice/image/build">https://yeasy.gitbook.io/docker_practice/image/build</a></p><h3 id="运行容器">运行容器</h3><p>初次运行<br><code>docker run -itd image-id bash </code><br>//i 交互 t 终端 d 运行但不关闭，不进入docker</p><p><code>docker exec -it conatainer-id bash</code><br>// 进入docker,退出不关闭</p><p><code>docker run -id image-id bash</code><br>// 进入docker，退出关闭</p><h3 id="删除镜像和容器">删除镜像和容器</h3><p><a href="https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/">https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/</a></p><p><code>docker stop container-id</code><br>// 关闭容器<br><code>docker rm container-id</code><br>// 删除容器<br><code>docker rmi image-id</code><br>// 删除镜像<br><code>docker stop $(docker ps -a -q)</code><br>// 停止所有容器运行<br><code>docker rm $(docker ps -a -q)</code><br>// 删除所有容器</p><h3 id="根据Dockerfile制作镜像">根据Dockerfile制作镜像</h3><p><code>docker buildx build -t hansanf/cuda-11.1:11.1.1-devel-cudnn-ubuntu18.04 --platform=x86_64  . --push</code><br>// buildx是制作多架构工具，可以不用<br>// -t tag, [仓库名]:[镜像tag]<br>// --platform buildx要制作的哪个平台的镜像<br>// . Dockerfile的路径<br>// --push 制作的镜像push到远程仓库，不会保留在本地，可以用 -o type=docker 替换</p><h3 id="pull和push">pull和push</h3><p><code>docker pull [仓库名]:[tag]</code></p><p><code>docker push [仓库名]:[tag]</code></p><h3 id="关闭、打开和重启docker">关闭、打开和重启docker</h3><p>启动<br><code>sudo systemctl start docker</code><br>关闭<br><code>sudo  service docker stop</code></p><p>重启</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">sudo systemctl daemon-reload<span class="hljs-comment">;</span><br>sudo systemctl restart  docker<span class="hljs-comment">;</span><br>sudo sudo service docker restart<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="容器内进行可视化">容器内进行可视化</h3><p>设置 DISPLAY 环境变量，令 docker 内外一致, 比如均设置为 :1</p><p>冒号不能少</p><p>启动容器的时候加上：<br>-e DISPLAY=$DISPLAY -v /tmp/.X11-unix/:/tmp/.X11-unix</p><h3 id="跨平台构建-Docker-镜像">跨平台构建 Docker 镜像</h3><p>结论：在不使用nvidia的情况下，在开发机x86架构上构建arm64的docker镜像，在该镜像中进行开发，可以直接把程序移植到的arm盒子中运行</p><h4 id="跨-CPU-架构编译程序的方法：">跨 CPU 架构编译程序的方法：</h4><h5 id="方法一：直接在目标硬件上编译">方法一：直接在目标硬件上编译</h5><p>缺点：需每个人都直接操作目标硬件，在硬件资源不充足的情况下开发效率低。</p><h5 id="方法二：模拟目标硬件">方法二：模拟目标硬件</h5><p>通过QEMU（quick emulator）模拟一个完整的操作系统，创建出通用的 ARM 虚拟机，该虚拟机可以引导 Linux，设置开发环境，也可以在虚拟机内编译程序。</p><p>缺点：模拟整个系统，包括计时器、内存控制器、总线控制器等硬件，但编译程序不需要这些硬件。</p><h5 id="方法三：使用交叉编译器">方法三：使用交叉编译器</h5><p>类似于方法一，只不过将编译过程放在开发机</p><h5 id="方法四：模拟目标硬件的用户空间">方法四：模拟目标硬件的用户空间</h5><p>QEMU 将通过binfmt_misc（Miscellaneous Binary Format）在 Linux 内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标 CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标 CPU 架构的二进制文件。</p><h5 id="跨平台构建docker就是方法四的演化">跨平台构建docker就是方法四的演化</h5><p>背景：<br>目前手上ARM盒子只有一个，资源有限；<br>ARM盒子中，程序最终跑在docker里。</p><p>目标：<br>以软件模拟的方式，实现开发机中使用ARM架构下的docker，使开发机中的docker环境和ARM盒子中的一样，从而在开发机中就可以进行移植。</p><p><img src="https://img-blog.csdnimg.cn/c39c902beb63427bb54f878b856fb08a.png" alt="在这里插入图片描述"></p><h5 id="实现路线：">实现路线：</h5><p>使用 buildx 命令(使用 BuildKit实现的)构建多种系统架构支持的 Docker 镜像<br>BuildKit：镜像构建组件</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs tcl">（<span class="hljs-number">1</span>）启动buildx插件<br>$ export DOCKER_CLI_EXPERIMENTAL=enabled<br>验证是否开启<br>$ docker buildx version<br>github.com/docker/buildx v0<span class="hljs-number">.3</span><span class="hljs-number">.1</span>-tp-docker <span class="hljs-number">6</span>db68d029599c6710a32aa7adcba8e5a344795a7<br><br>（<span class="hljs-number">2</span>）启动binfmt_misc<br>$ docker run --rm --privileged tonistiigi/binfmt:latest --install all<br>验证是 binfmt_misc 否开启：<br>$ ls -al /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/<br>总用量 0<br>总用量 0<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-aarch64</span>   // 支持arrch64架构<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-arm</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-ppc64le</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-s390x</span><br>--w------- 1<span class="hljs-title"> root</span> root 0 11月 18 00:09<span class="hljs-title"> register</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> status</span><br>验证是否启用了arrch64处理器：<br>$<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">enabled</span><br>interpreter /usr/bin/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">flags:</span> OCF<span class="hljs-title"></span><br><span class="hljs-title">offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">magic</span> 7f454c460201010000000000000000000200b7<span class="hljs-title"></span><br><span class="hljs-title">mask</span> ffffffffffffff00fffffffffffffffffeffff<br><br>(3)新建<span class="hljs-title"> builder</span> 实例<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> create</span> --use --name=mybuilder-cn --driver<span class="hljs-title"> docker-container</span> --driver-opt<span class="hljs-title"> image=dockerpracticesig/buildkit:master</span><br>启动构建器<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> inspect</span> mybuilder --bootstrap<br>[+]<span class="hljs-title"> Building</span> 5.0s (1/1)<span class="hljs-title"> FINISHED</span><br> =&gt; [internal]<span class="hljs-title"> booting</span> buildkit                                                                                                                          5.0s<br> =&gt; =&gt;<span class="hljs-title"> pulling</span> image<span class="hljs-title"> moby/buildkit:buildx-stable-1</span>                                                                                                       4.4s<br> =&gt; =&gt;<span class="hljs-title"> creating</span> container<span class="hljs-title"> buildx_buildkit_mybuilder0</span>                                                                                                     0.6s<span class="hljs-title"></span><br><span class="hljs-title">Name:</span> <span class="hljs-title">  mybuilder</span><br>Driver:<span class="hljs-title"> docker-container</span><br><span class="hljs-title"></span><br><span class="hljs-title">Nodes:</span><br>Name:<span class="hljs-title">      mybuilder0</span><br>Endpoint:<span class="hljs-title">  unix:///var/run/docker.sock</span><br>Status:<span class="hljs-title">    running</span><br>Platforms:<span class="hljs-title"> linux/amd64,</span> linux/arm64,<span class="hljs-title"> linux/ppc64le,</span> linux/s390x,<span class="hljs-title"> linux/386,</span> linux/arm/v7,<span class="hljs-title"> linux/arm/v6</span><br><br>(4）新建<span class="hljs-title"> Dockerfile</span> 文件<span class="hljs-title"></span><br><span class="hljs-title">FROM</span> --platform=$TARGETPLATFORM<span class="hljs-title"> alpine</span><br><span class="hljs-title"></span><br><span class="hljs-title">RUN</span> uname -a &gt; /os.txt<span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">CMD</span> cat /os.txt<br><br>(5)本地创建镜像<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> build</span> -t<span class="hljs-title"> hello-arch-arm64</span> --platform=linux/arm64 -o<span class="hljs-title"> type=docker</span> .<br></code></pre></td></tr></table></figure><p>其他知识补充：</p><p>Qemu（quick emulator）是一个开源的托管虚拟机，通过纯软件来实现虚拟化模拟器，几乎可以模拟任何硬件设备。比如：Qemu可以模拟出一个ARM系统中的：CPU、内存、IO设备等，然后在这个模拟层之上，可以跑一台 ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。Qemu是使用纯软件模拟的，它的强项是模拟那些不涉及到外部的具体硬件设备的场景。因为QEMU是纯软件实现的，所有的指令都要经过QEMU，使得性能很差，而配合KVM则可以解决这一问题。</p><p>参考资料<br><a href="https://cloud.tencent.com/developer/article/1543689">https://cloud.tencent.com/developer/article/1543689</a><br><a href="https://yeasy.gitbook.io/docker_practice/buildx/multi-arch-images">https://yeasy.gitbook.io/docker_practice/buildx/multi-arch-images</a><br><a href="https://www.cnblogs.com/sewain/p/14206365.html">https://www.cnblogs.com/sewain/p/14206365.html</a></p><h3 id="ERRORS">ERRORS</h3><p>error-1<br>W: GPG error: <a href="https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.</p><p>硬盘空间不足了</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc-options</title>
    <link href="/2022/07/14/gcc-options/"/>
    <url>/2022/07/14/gcc-options/</url>
    
    <content type="html"><![CDATA[<h3 id="gcc-的编译选项">gcc 的编译选项</h3><p>gcc官方手册：<a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a></p><p>7.5手册：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options</a></p><p>链接选项：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options</a></p><h4 id="fPIC-和-fPIE">-fPIC 和-fPIE</h4><p>-fPIC 用在动态库的编译，产生位置无关的代码</p><p>-fPIE 用在可执行程序的编译</p><p>两者在效果上一样，都是把代码中的逻辑地址转为相对地址，但是作用上不一样。<br>-fPIC一般是动态库编译必须设置的，因为可能在链接时，多个模块之间的重定向可能会出现冲突。而-fPIE在可执行程序的编译中可加可不加，其将绝对地址转为相对地址，在一定程度上提高了安全性，另外相对寻址的方式可能会让程序在启动速度慢一点。</p><p>PIE 详解：<a href="https://www.redhat.com/en/blog/position-independent-executables-pie">https://www.redhat.com/en/blog/position-independent-executables-pie</a></p><p>-fPIC 在64 位系统中，动态库在链接编译静态库时也是需要加的，原因在于: 使用 32 位寄存器的汇编编译器无法访问64位平台地址偏移的范围，为了在使用64 位寄存器的情况下使用相同的代码，编译器需要借助一种方式进行标记，也就是使用-fPIC 或-mcmmodel=large<br>其实和直接编译动态库一样，只要涉及到动态库的编译加上 -fPIC 就行了，不管其底层是否依赖了静态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.cc</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// g++ -c a.cc -o a.o -fPIC</span><br><span class="hljs-comment">// ar rcs liba.a a.o</span><br><br><span class="hljs-comment">// b.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">func</span>();<br>&#125;<br><span class="hljs-comment">// g++ -shared -o libb.so b.cc -L -l a</span><br></code></pre></td></tr></table></figure><p>报错:<br>/usr/bin/ld: /tmp/ccGoVApA.o: relocation R_X86_64_PC32 against symbol `_ZSt4cout@@GLIBCXX_3.4’ can not be used when making a shared object; recompile with -fPIC<br>/usr/bin/ld: final link failed: bad value<br>collect2: error: ld returned 1 exit status</p><p>其实不引用 func(), 不依赖liba.a，在编译libb.so时也是需要加上 -fPIC 的</p><h4 id="L、-rpath和-rpath-link的区别">-L、-rpath和-rpath-link的区别</h4><p>-L 选项：<br>-L 选项用于指定链接器在链接程序时查找库文件的路径。<br>它告诉链接器在指定的路径中搜索库文件，以解析程序中的库依赖关系。<br>通常，您可以使用 -L 来指定非标准库目录，以便链接器能够找到您自己编译或第三方库的位置。<br>示例：-L/path/to/custom/libraries</p><p>-rpath 选项：<br>-rpath 选项用于在可执行文件中嵌入运行时库的搜索路径。<br>它允许您指定在程序运行时查找共享库的路径，而不仅仅是在链接时。<br>运行时，程序将在指定的路径中搜索共享库，以满足依赖关系。<br>示例：-Wl,-rpath,/path/to/runtime/libs</p><p>-rpath-link 选项：<br>-rpath-link 选项类似于 -rpath，但它用于在链接时将库搜索路径嵌入到可执行文件中，而不是运行时。<br>这可以用来解决在链接时将某个库链接到了其他共享库版本而不是预期版本的问题。<br>-rpath-link 可以影响到链接过程中的库搜索路径，但不会影响运行时。<br>示例：-Wl,-rpath-link,/path/to/runtime/libs</p><p>总结：<br>-L 用于链接时，指定库文件的搜索路径。<br>-rpath 用于运行时，嵌入可执行文件中，指定共享库的搜索路径。<br>-rpath-link 用于链接时，指定库文件的搜索路径，但不会影响运行时。<br>这些选项通常用于处理库依赖关系，特别是当您有自定义库的位置或多个版本的库时，可以使用这些选项来确保链接器和运行时都能正确找到所需的库。</p><h4 id="L-和-l-的顺序问题">-L 和 -l 的顺序问题</h4><p>-L 搜索路径时有顺序，按照从前往后；-l 搜索库时没有顺序</p><h4 id="强制链接没有使用的库">强制链接没有使用的库</h4><p>-Wl,–no-as-needed<br><a href="https://sourceware.org/binutils/docs-2.16/ld/Options.html">https://sourceware.org/binutils/docs-2.16/ld/Options.html</a></p><h4 id="只链接使用到的库（默认）">只链接使用到的库（默认）</h4><p>-Wl,–as-needed</p><h4 id="fstack-protector-栈溢出保护">-fstack-protector 栈溢出保护</h4><p>编写一个简单的例子，发展栈增长的方向是从地址向高地址增长的，与理论上的增长方向相反：<a href="https://blog.csdn.net/qq_48974566/article/details/127076024">https://blog.csdn.net/qq_48974566/article/details/127076024</a></p><p>原因就在于开启了栈溢出保护选项。栈溢出保护的选项有好几个: <a href="https://www.cnblogs.com/arnoldlu/p/11630979.html">https://www.cnblogs.com/arnoldlu/p/11630979.html</a><br>不同的选项的保护程度不一样，性能影响也不一样。</p><ul><li>栈溢出保护机制的基本实现原理：<br>通过 -fstack-protector 和 -fno-stack-protector 分别编译一个简单的程序，查看其区别就可以发现：</li></ul><ol><li>改变栈的使用方向，相当于预分配栈上的一大块空间，如果超过了预分配空间的写，就会改写其他内存数据</li><li>在栈分配空间前先标记一个位置，正常情况下该位置是不会被用户所改变和访问的，然后将该位置保存起来，等到分配和使用完栈空间后，再比较该位置的值是否发生了变化，从而判断栈是否发生了溢出。</li></ol><p>分析示例：<a href="https://www.modb.pro/db/217464">https://www.modb.pro/db/217464</a></p><p>也可以用 compiler explorer 进行比较</p><p><img src="image-6.png" alt="alt text"><br><img src="image-7.png" alt="alt text"></p><p>可以看到变量存储的方向是相反的。</p><p>发现只有分析示例里的 char a[64] 会用到标记位置的保护方式，int x[64]不行，可能是因为char* 的处理方式不太一样，也可能是上述理解的原理太简单，背后的实现更为复杂。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const_cast用法</title>
    <link href="/2022/07/11/cpp-const-cast/"/>
    <url>/2022/07/11/cpp-const-cast/</url>
    
    <content type="html"><![CDATA[<h2 id="const-cast">const_cast</h2><p>const_cast&lt;&gt;  &lt;&gt;必须是指针或引用</p><h2 id="const-std-shared-ptr-const-class-nam-去-const">const std::shared_ptr<const class_nam>去 const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; <span class="hljs-title">const_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(const_ptr).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//ptr-&gt;x = 100; //error</span><br>        <span class="hljs-comment">//std::shared_ptr&lt;A&gt; ptr = const_cast&lt;std::shared_ptr&lt;A&gt;&gt;(const_ptr);  //error</span><br>        std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; ptr = <span class="hljs-keyword">const_cast</span>&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; &amp;&gt;(const_ptr); <span class="hljs-comment">//必须是const_cast&lt;&amp;&gt; 必须加引用</span><br><br>        A &amp;a = <span class="hljs-built_in">const_cast</span>&lt;A &amp;&gt;(*const_ptr); <span class="hljs-comment">// const_cast&lt;&amp;&gt; 必须加引用</span><br>        a.x = <span class="hljs-number">100</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a.x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;const_ptr-&gt;x = &quot;</span> &lt;&lt; const_ptr-&gt;x &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp_mutable</title>
    <link href="/2022/07/06/cpp-mutable/"/>
    <url>/2022/07/06/cpp-mutable/</url>
    
    <content type="html"><![CDATA[<h3 id="mutable-关键字">mutable 关键字</h3><p><a href="https://www.jianshu.com/p/b2883dbf3854">mutabel 介绍</a></p><h4 id="为什么std-mutex-前通常用mutable-修饰">为什么std::mutex 前通常用mutable 修饰</h4><p>在const成员函数中，对mutex的加锁和释放锁操作会违背const的不可变语义，所以，只能将mutex定义为mutable，从而可以在const修饰的函数中加锁，实现线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cal</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Cal</span>(<span class="hljs-type">int</span> n) &#123;num = n;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc_num</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        ++num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">//const m 状态的改变会修改const 语义，但不报错？</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">mutable</span> std::mutex m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Cal c&#123;<span class="hljs-number">0</span>&#125;;<br>    std::cout &lt;&lt; c.<span class="hljs-built_in">get_num</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_debug_tools</title>
    <link href="/2022/07/05/debug-tools/"/>
    <url>/2022/07/05/debug-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="C-Debug命令和工具">C++ Debug命令和工具</h2><h3 id="readelf">readelf</h3><p>查看可执行文件或库的符号表</p><figure class="highlight ada"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ada">readelf -s ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>查看可执行文件或库的动态库表</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">readelf -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="objdump">objdump</h3><p>查看汇编情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>查看是否带有调试符号<br>objdump --debugging libvoidincr.a</p><h3 id="nm">nm</h3><p>查看符号类型<br>nm -a xxx 查看所有符号<br>nm -D xxx 查看动态库符号<br><a href="https://linux.die.net/man/1/nm">https://linux.die.net/man/1/nm</a></p><h3 id="ldd">ldd</h3><p>查看动态库的链接情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ldd ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="LD-PRELOAD">LD_PRELOAD</h3><p>在执行该文件前预加载库，要加具体的库名，LD_PRELOAD的值只在当前语句生效</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">env LD_PRELOAD=<span class="hljs-regexp">/home/</span>fenggq<span class="hljs-regexp">/libutil.so ./</span>a.out<br></code></pre></td></tr></table></figure><h3 id="查看系统默认链接的库路径">查看系统默认链接的库路径</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br>    # output: include /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br>    # output: 所有的默认库路径<br></code></pre></td></tr></table></figure><h3 id="gdb">gdb</h3><p>使用gdb调试带输入参数的程序</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gdb --<span class="hljs-keyword">args</span> ./a.<span class="hljs-keyword">out</span> <span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure><h3 id="file查看文件属性">file查看文件属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file msf<br>msf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped<br></code></pre></td></tr></table></figure><p>该文件被stripped ，去除掉了符号表信息</p><h3 id="strip-命令">strip 命令</h3><p>去掉符号表和调试等信息<br><a href="https://blog.51cto.com/u_15614325/5272498">https://blog.51cto.com/u_15614325/5272498</a></p><p>符号表和strip <a href="https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/">https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/</a></p><p>tmp_LD_PRELOAD=${LD_PRELOAD}<br>unset LD_PRELOAD<br>nohup cyber_launch start fusion_tracker.launch &amp;<br>export LD_PRELOAD=${tmp_LD_PRELOAD}</p><h3 id="core文件去哪了">core文件去哪了</h3><p><a href="http://www.hansanf.space/2023/07/29/core-file/">core 文件设置</a><br><a href="https://www.jianshu.com/p/7317910210a4">core文件去哪了</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode tips</title>
    <link href="/2022/06/29/vscode-tips/"/>
    <url>/2022/06/29/vscode-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="code命令终端直接打开文件">code命令终端直接打开文件</h3><p>code 命令启动vscode</p><p>开启方式的 ctrl+shift+p  输入code，选择 install<br>不好用的时候，uninstall 再 install 一遍</p><p><code>code [path]</code></p><p><a href="https://blog.csdn.net/weixin_42881768/article/details/119635248">https://blog.csdn.net/weixin_42881768/article/details/119635248</a></p><h3 id="vscode-正则表达式">vscode 正则表达式</h3><p>查找 // FGQ ******** QGF 的注释：</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> [\w\s,;.]*?FGQ [\w\s,;.]*? QGF<br></code></pre></td></tr></table></figure><h3 id="c-cpp-properties-json-配置">c_cpp_properties.json 配置</h3><h4 id="控制宏的高亮">控制宏的高亮</h4><p>step1. 安装C++ intelligence 插件<br>step2. 设置里搜 Dim Inactive Regions，勾选该设置<br>step3.  c_cpp_proerties.json 里 设置 defines</p><h4 id="设置头文件搜索路径">设置头文件搜索路径</h4><p>在 c_cpp_proerties.json 里设置 includePath</p><h4 id="完整c-cpp-proerties-json展示">完整c_cpp_proerties.json展示</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;/l4t/targetfs/usr/src/jetson_multimedia_api/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-string">&quot;USE_NVIDIA_TEGRA&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br><br>    <span class="hljs-attr">&quot;C_Cpp.default.includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">// 上面的没法用时 用这个，应该和vscode 版本有关</span><br>      <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br>    <span class="hljs-attr">&quot;editor.bracketPairColorization.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 控制是否对括号着色</span><br>    <span class="hljs-attr">&quot;editor.bracketPairColorization.independentColorPoolPerBracketType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 各类括号着色等级不独立</span><br>    <span class="hljs-attr">&quot;editor.guides.bracketPairs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启用括号指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.bracketPairsHorizontal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;active&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启用水平括号指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.highlightActiveIndentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用高亮选中的缩进指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.indentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用缩进指导线</span><br>    <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 颜色主题</span><br>    <span class="hljs-attr">&quot;editor.detectIndentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用自动检测文件缩进模式和缩进大小，即打开文件后自动将文件更改为 VSCode 配置的缩进格式</span><br>    <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 保存自动格式化代码</span><br>    <span class="hljs-attr">&quot;editor.formatOnPaste&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 粘贴自动格式化</span><br>      <span class="hljs-comment">// explorer</span><br>    <span class="hljs-attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 移动文件时无需确认</span><br>    <span class="hljs-attr">&quot;explorer.confirmDelete&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 删除文件确认</span><br>    <span class="hljs-attr">&quot;explorer.incrementalNaming&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;smart&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 粘贴同名文件时的重命名方式;smart: 在重复名称末尾智能地添加/递增数字</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="vscode-快捷键">vscode 快捷键</h3><p>ctrl+shift+{ 折叠内容</p><p>ctrl+shift+} 展开内容</p><p>设置中搜索forward backward 关键字可以设置前进、后退快捷键</p><p>control + q 左侧功能栏选择<br>control + w vscode 打开窗口切换，关键字搜索 切换窗口</p><h3 id="vscode-插件合集">vscode 插件合集</h3><ol><li>git：gitlen; gitblame; git graph;</li><li>Bracket Select 通过快捷键 alt+a 和 alt+z 选中和取消括号包含内容</li><li>Bracket Lens 在 } 的后面标示 { 的位置</li><li>indent rainbow 相同缩进的为统一颜色</li><li>blockman 将代码块高亮显示</li><li>Peacock 改变边框颜色</li></ol><h3 id="vscode-浏览-gitlab仓库">vscode 浏览 gitlab仓库</h3><ol><li>安装 gitlab workflow 插件</li><li>配置个人token，在gitlab个人设置界面 access token =&gt; 勾选 read_api 和 read_repository</li><li>ctrl+shift+p Gitlab: Add Account to VS Code</li><li>ctrl+shift+p Gitlab: Open Remote read_repository  可能需要一点时间认证？ 过了一会才能浏览 repository 的, 先输入个a试下</li></ol><h3 id="vscode-调试C">vscode 调试C++</h3><p>step1. 安装 gdb debug<br>step2. 点击左侧调试按钮，创建 launch.json<br>note: 断点调试需要编译时加 -g</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>  <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>  <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//配置名称，显示在配置下拉菜单中</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//配置类型</span><br>          <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//请求配置类型，可以是启动或者是附加</span><br>          <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//程序可执行文件的完整路径，$&#123;workspaceFolder&#125;表示远程连接的初始路径</span><br>          <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//传递给程序的命令行参数</span><br>          <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//可选参数，如果为true,调试程序应该在入口（main）处停止</span><br>          <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//目标的工作目录</span><br>          <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//表示要预设的环境变量</span><br>          <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//如果为true，则为调试对象启动控制台</span><br>          <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//要连接到的控制台启动程序</span><br>          <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">//为了安装基础调试程序而执行的一个或多个GDB/LLDB命令</span><br>              <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>              <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>远程调试配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>  <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>  <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;configurations&quot;</span>: [<br>      &#123;<br>          <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;(gdb) 启动&quot;</span>, <span class="hljs-regexp">//</span>配置名称，显示在配置下拉菜单中<br>          <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>, <span class="hljs-regexp">//</span>配置类型<br>          <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>, <span class="hljs-regexp">//</span>请求配置类型，可以是启动或者是附加<br>          <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;/home/guoqing.feng/code/perception-bev/build_aarch64_orin/output/test/bin/test_main&quot;</span>, <span class="hljs-regexp">//</span>程序可执行文件的完整路径，<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>表示远程连接的初始路径<br>          <span class="hljs-string">&quot;args&quot;</span>: [<br>            <span class="hljs-string">&quot;--flagfile=config/flags.conf&quot;</span><br>          ], <span class="hljs-regexp">//</span>传递给程序的命令行参数<br>          <span class="hljs-string">&quot;stopAtEntry&quot;</span>: true,<span class="hljs-regexp">//</span>可选参数，如果为true,调试程序应该在入口（main）处停止<br>          <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>, <span class="hljs-regexp">//</span>目标的工作目录<br>          <span class="hljs-string">&quot;environment&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;LD_LIBRARY_PATH&quot;</span>,<br>                <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;/mnt/data0/guoqing.feng/perception/output/test/../third_party/lib:/mnt/data0/guoqing.feng/perception/output/test/../third_party:/mnt/data0/guoqing.feng/perception/output/test/../lib:/usr/local/cuda-11.4/lib64&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;GLOG_v&quot;</span>,<br>                <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;5&quot;</span><br>            &#125;<br>        ],<br>          <span class="hljs-string">&quot;externalConsole&quot;</span>: false,<span class="hljs-regexp">//</span>如果为true，则为调试对象启动控制台<br>          <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<span class="hljs-regexp">//</span>要连接到的控制台启动程序<br>          <span class="hljs-string">&quot;setupCommands&quot;</span>: [ <span class="hljs-regexp">//</span>为了安装基础调试程序而执行的一个或多个GDB/LLDB命令<br>              &#123;<br>                  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                  <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                  <span class="hljs-string">&quot;ignoreFailures&quot;</span>: true<br>              &#125;<br>          ],<br>          <span class="hljs-string">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/l4t/toolchain/bin/aarch64-linux-gdb&quot;</span>,<br>          <span class="hljs-string">&quot;miDebuggerServerAddress&quot;</span>:<span class="hljs-string">&quot;10.31.1.173:12399&quot;</span><br>      &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>板子上执行:<br>gdbserver 10.31.1.172:10099 exec_file args</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yuv2rgb</title>
    <link href="/2022/06/29/yuv2rgb/"/>
    <url>/2022/06/29/yuv2rgb/</url>
    
    <content type="html"><![CDATA[<h1>YUV详解</h1><h3 id="YUV分类">YUV分类</h3><h5 id="1、按采样方式分类">1、按采样方式分类</h5><p>（1） YUV444: 全量UV，类似于RGB，每个像素点都有一套自己的YUV<br><img src="https://img-blog.csdnimg.cn/000b2132c524457583a034fcb2bd787c.png#pic_center" alt="在这里插入图片描述"><br>（2） YUV422: 50%的UV，与全量相比，UV数量减少一半，每行中由 2 个 Y 分量共用一套 UV 分量。<br><img src="https://img-blog.csdnimg.cn/eea18cfb6599473aab6374a6cc7b1fc2.png#pic_center" alt="在这里插入图片描述"></p><p>（3）YUV420: 25%的UV， UV的数量减少到1/4，每行两个Y、每列两个Y，共由 4 个 Y 分量共用一套 UV 分量。<img src="https://img-blog.csdnimg.cn/e01002399f09464e8916f4421fa5e8c0.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2、按内存中排列方式分类">2、按内存中排列方式分类</h5><p>（1）Planar YUV 三个分量分开存放<br>（2）Semi-Planar Y 分量单独存放，UV 分量交错存放<br>（3）Packed YUV 三个分量全部交错存放</p><p>以YUV420为例：</p><h5 id="3、ffmpeg中h264解码后的YUV格式">3、ffmpeg中h264解码后的YUV格式</h5><h3 id="YUV转RGB">YUV转RGB</h3><p>色彩空间：<br>公式：</p><h5 id="ffmpeg接口">ffmpeg接口</h5><h5 id="cuda实现">cuda实现</h5><p>参考：<br><a href="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a><br><a href="https://cloud.tencent.com/developer/article/1612357">https://cloud.tencent.com/developer/article/1612357</a><br><a href="https://juejin.cn/post/6920848468797816846">https://juejin.cn/post/6920848468797816846</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf</title>
    <link href="/2022/06/29/protobuf/"/>
    <url>/2022/06/29/protobuf/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是protobuf">什么是protobuf</h2><p>Protocol Buffers(简称Protobuf) ，是Google出品的序列化框架。<br>简单来讲，就是支持序列化与反序列化，用于数据的存储、传输。<br>protobuf将数据接口定义在.proto文件中，然后再利用protoc翻译为所需要的程序语言代码（类似于接口描述语言？）</p><p><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial">官方Guide</a></p><h2 id="怎么用protobuf">怎么用protobuf</h2><h3 id="安装">安装</h3><p>…省略</p><h3 id="C-使用">C++使用</h3><h4 id="数据类型定义">数据类型定义</h4><p><a href="https://blog.csdn.net/wangchong_fly/article/details/47614699">数据类型对应关系</a></p><h4 id="demo">demo</h4><p>step-1定义.proto</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// demo_msg.proto</span><br>syntax = <span class="hljs-string">&quot;proto2&quot;</span>; <span class="hljs-comment">//版本选择，proto2 or proto3</span><br>package fgq.demo; <span class="hljs-comment">// C++中的namespace,用.分隔</span><br><br>message PersonalInfo &#123;<br>required bytes name = <span class="hljs-number">1</span>;<br>optional bytes address = <span class="hljs-number">2</span>;<br>repeated bytes friends = <span class="hljs-number">3</span>;<br>&#125;;<br><span class="hljs-comment">//等号后面是field number,从1开始计数</span><br><span class="hljs-comment">//C++中字段名不区分大小写，即name和Name，在C++接口中都是name</span><br></code></pre></td></tr></table></figure><p>step-2 将.proto翻译为.cpp和.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc -I= demo_msg.proto的目录 --cpp_out=存放.cpp和.h的目录 demo_msg.proto的路径<br></code></pre></td></tr></table></figure><p>-I参数和gcc的-I参数类似？</p><p>step-3<br>.cpp中引入.pb.h头文件，就可以使用protobuf所提供的cpp接口了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;demo_msg.pb.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">g++ main.cpp -I [--cpp_out所指定的目录]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>atomic</title>
    <link href="/2022/06/29/atomic/"/>
    <url>/2022/06/29/atomic/</url>
    
    <content type="html"><![CDATA[<h3 id="内存模型">内存模型</h3><p>内存模型：指令执行顺序的模型</p><p>现代的处理器基本是并发式处理机器指令的,在一个cpu 时钟 issue 多条指令。</p><p>指令若总是严格按照书写顺序执行的，则称这样的内存模型为强顺序的(strong ordered),按照一定规则允许乱序的，称为弱顺序的(weak ordered)。</p><p>内存模型详细介绍：</p><ul><li><p><a href="https://www.zhihu.com/question/24301047">https://www.zhihu.com/question/24301047</a></p></li><li><p><a href="https://www.zhihu.com/question/24301047">https://zhuanlan.zhihu.com/p/264975254</a></p></li></ul><h3 id="C-atomix-内存顺序">C++ atomix 内存顺序</h3><p>根据允许指令的混乱程度，C++为原子操作指定了内存顺序（memory_order），其包含6种：</p><ul><li>momory_order_relaxed,</li><li>memory_order_consume,</li><li>memory_order_acquire,</li><li>memory_order_release,</li><li>memory_order_acq_rel,</li><li>memory_order_seq_cst.</li></ul><p><img src="https://img-blog.csdnimg.cn/56a139b6a7184bd5af35c4df4610a9aa.png" alt="在这里插入图片描述"></p><p>虽然共有 6 个选项,但它们表示的是三种内存模型:</p><p><strong>sequential consistent</strong>: memory_order_seq_cst</p><p>如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行。相当于所有的线程都用同一份内存，对同一个变量保持时刻可见</p><p><a href="https://www.zhihu.com/question/24301047">使用示例</a></p><p><strong>relaxed</strong>: memory_order_seq_cst</p><p>在同一线程内对同一变量的操作仍保持happens-before关系，但这与别的线程无关。 在 relaxed ordering 中唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排。</p><p><strong>acquire release</strong>: memory_order_consume, memory_order_acquire,<br>memory_order_release, memory_order_acq_rel</p><p>在这种序列模型下,原子 load 操作是 acquire 操作(memory_order_acquire), 原子 store 操作是release操作(memory_order_release).</p><p>原子read_modify_write操作(如fetch_add(), exchange())可以是 acquire, release 或两者皆是(memory_order_acq_rel).</p><p>同步是成对出现的,它出现在一个进行 release 操作和一个进行 acquire 操作的线程间。</p><h3 id="C-atomic-用法">C++ atomic 用法</h3><h3 id="atomic-和-mutex-区别">atomic 和 mutex 区别</h3><p>atomic 可以实现数据结构的无锁设计，为什么还要用 mutex 呢？</p><p>std::atomic原子操作，主要是保护一个变量，互斥量的保护范围更大，可以一段代码或一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>callback</title>
    <link href="/2022/06/15/callback/"/>
    <url>/2022/06/15/callback/</url>
    
    <content type="html"><![CDATA[<h2 id="C-回调函数">C++回调函数</h2><h3 id="函数指针">函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(* func)(<span class="hljs-type">int</span>)<br>返回值类型(* 函数指针变量名)(参数)<br></code></pre></td></tr></table></figure><h3 id="std-function">std::function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;<br>             &lt;返回值类型 (参数) &gt;<br></code></pre></td></tr></table></figure><h3 id="常见用法">常见用法</h3><p>1、普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>(* cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// std::function</span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">register_func1</span>(callback);<br>    <span class="hljs-built_in">register_func2</span>(callback);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(A a, <span class="hljs-type">void</span>(A::*cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    (a.*cb)(<span class="hljs-number">100</span>); <span class="hljs-comment">// Note: 要用括号; 要带*</span><br>&#125;<br><br><span class="hljs-comment">// std::function </span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    <span class="hljs-built_in">register_func1</span>(a, &amp;A::callback); <span class="hljs-comment">// 要传入两个参数</span><br><br>    <span class="hljs-keyword">auto</span> cb = std::<span class="hljs-built_in">bind</span>(&amp;A::callback, &amp;a, std::placeholders::_1); <span class="hljs-comment">// 使用std::bind将对象地址绑定到this位置。placehoders::_1 待传入参数的占位符。</span><br>    <span class="hljs-built_in">register_func2</span>(cb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary">Summary</h3><p>1、函数指针是C中定义的实际函数的地址. std :: function是一个包装器,可以容纳任何类型的可调用对象(可以像函数一样使用的对象)</p><p>2、函数指针也可以和std::bind配合使用，但是std::function功能更强大，和std::bind配合更方便</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_usage</title>
    <link href="/2022/05/06/hexo-usage/"/>
    <url>/2022/05/06/hexo-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="部署hexo环境">部署hexo环境</h3><ol><li>首先安装node.js和Git</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>node.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br><span class="hljs-comment">#查看安装的版本</span><br>node -v<br>git --version<br></code></pre></td></tr></table></figure><ol start="2"><li>安装hexo</li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建博客目录，初始化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>hexo init<br></code></pre></td></tr></table></figure><h3 id="移植到另一台电脑">移植到另一台电脑</h3><ol><li>备份好原来的 blog 目录 =&gt; old_blog</li><li>新电脑配置好 hexo 环境，并新建好blog 目录 =&gt; new_blog</li><li>将 old_blog 目录下的 _conifg.yml、source、和themes 复制到 new_blog 目录<br>Note：可以将blog 目录直接备份在github repo 中，可以很方便的进行移植。</li><li>验证本地版本是否可用：<code>hexo g; hexo s</code></li><li>此时还不能远程推送到git repo, 需要安装hexo-deployer-git插件</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol start="6"><li>如果是ssh 方式登录github 需要上传新电脑公钥到github</li><li>Work Done</li></ol><h3 id="hexo集成到docker镜像">hexo集成到docker镜像</h3><p><a href="https://gitee.com/LakeVilladom/docker-hexo">docker-hexo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug记录：常量值截断(truncation of constant value)</title>
    <link href="/2022/05/05/bug-truncation-of-constant-value/"/>
    <url>/2022/05/05/bug-truncation-of-constant-value/</url>
    
    <content type="html"><![CDATA[<h3 id="char和unsigned-char">char和unsigned char</h3><p><strong>char的取值范围</strong>：-128~127<br>  -128: 16进制0x80  二进制1000 0000<br>  -127: 16进制0xff    二进制1111 1111，注意第一位是符号位，0111 1111是127</p><p><strong>unsigned char的取值范围</strong>：0~255，16进制0x00 ~ 0xff</p><h3 id="内存中的0xf0-1111-0000">内存中的0xf0: 1111 0000</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x = <span class="hljs-number">0xf0</span>; <span class="hljs-comment">// 十进制数大小为240，超出了127，导致常量值截断</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">0xf0</span> == x)&#123; <span class="hljs-comment">// x86机器上判断为false，arm机器上可能判断为true</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;x == 0xf0&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout&lt;&lt; <span class="hljs-string">&quot;char x= &quot;</span> &lt;&lt; x <br>&lt;&lt; <span class="hljs-string">&quot;\tunsigned char x = &quot;</span> &lt;&lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)x <br>&lt;&lt; <span class="hljs-string">&quot;\tint x = &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)x &lt;&lt; std::endl; <span class="hljs-comment">// 在不同机器上可能出现不同值</span><br></code></pre></td></tr></table></figure><p>mac(m1 arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">-16</span>  <br></code></pre></td></tr></table></figure><p>linux(x86)打印结果和上面一致</p><p>arm盒子(arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p>     char和unsigned char乱码，直接看int，一个取值-16，一个取值240</p><p><strong>取值为-16的情况：</strong></p><p>     int类型时，-16的二进制为 1000 0000| 0000 0000| 0000 0000| 0001 0000，最后一个字节是0001 0000</p><p>     而1111 0000 取反为 0000 11111，加1正好是0001 0000，即0xf0的补码是0001 0000，因此在将(char)0xf0变为int类型时的十进制数-16，至于为什么是这样的规则我也不知道。<br><strong>取值为240的情况：</strong></p><p>     int类型时，240的二进制为 0000 0000| 0000 0000| 0000 0000| 1111 0000，最后一个字节就是1111 0000</p><p>    综上，有些机器在处理常量截断时是取补码，而有些机器是取正码，即不变。实际上，<code>char x = 0xf0</code>这种用法本身就是错误的，不应该使用，对二进制字节比较时最好选用<code>unsigned char</code>类型。</p><p>    不过，在对内存中的二进制字节进行判断时，也可以使用 if(x == (char)0xf0)这种形式。</p><p><strong>Note &amp; 猜测:</strong></p><p>     <code>char x = 0xf0</code> 虽然发生了常量截断，但是内存中的值确实是0xf0，只不过在从内存中读取出来时不同类型有不同的取值。</p><p>参考：</p><p><a href="http://www.cplusplus.com/forum/beginner/48577/">http://www.cplusplus.com/forum/beginner/48577/</a><br><a href="https://zhidao.baidu.com/question/533897399.html">https://zhidao.baidu.com/question/533897399.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_in_mac</title>
    <link href="/2022/05/04/test-in-mac/"/>
    <url>/2022/05/04/test-in-mac/</url>
    
    <content type="html"><![CDATA[<p>a test for mac hexo<br>second test</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git_ssh_usage</title>
    <link href="/2021/11/26/git-ssh-usage/"/>
    <url>/2021/11/26/git-ssh-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="git在线练习平台">git在线练习平台</h3><p><a href="https://learngitbranching.js.org">https://learngitbranching.js.org</a></p><p><a href="https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw">git常用命令和基本概念</a></p><h3 id="代码托管平台push-时需要的-ssh-密钥">代码托管平台push 时需要的 ssh 密钥</h3><h4 id="ssh-密钥生成">ssh 密钥生成</h4><ol><li>生成ssh密钥  ssh-keygen -t rsa   可以直接一路回车</li><li>打印密钥内容  cat ~/.ssh/id_rsa.pub</li><li>复制密钥到托管平台</li><li>查看.ssh/config文件，是否配置了你的ssh，没有配置不会被使用（在多人使用的情况下要注意）</li></ol><h4 id="ssh-配置">ssh 配置</h4><h5 id="多个用户时，指定用户在代码托管平台所用的密钥">多个用户时，指定用户在代码托管平台所用的密钥</h5><p>ssh-keygen 生成密钥时指定名称，比如加个后缀 .github来表示该密钥是用于github</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Host github.com<br>    User hansanf<br>    IdentityFile ~/.ssh/id_rsa.github<br></code></pre></td></tr></table></figure><h6 id="ssh-连接远程主机时别名登录和免密登录">ssh 连接远程主机时别名登录和免密登录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 Host fgq<br>2     HostName 主机端ip<br>3     User 主机端用户名<br>4     Port 22<br>5     IdentityFile ~/.ssh/id_rsa.remote  <span class="hljs-comment"># 连接主机所用的密钥，需要将公钥放在主机端</span><br></code></pre></td></tr></table></figure><p>将公钥放在主机端 ~/.ssh/ 目录下使用 <code>ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 username@192.168.11.11</code>，或scp 传输到 .ssh 目录下, 然后就可以通过 <code>ssh fgq</code> 登录远程主机了</p><h6 id="ssh-通过跳板机登录远程主机">ssh 通过跳板机登录远程主机</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host fgq<br>    HostName 192.168.2.100<br>    User caros<br>    Port 22<br>    ProxyCommand ssh middle@relay  %h:%p<br><br>Host relay<br>    HostName 192.168.1.10<br>    User middle<br>    Port 22<br></code></pre></td></tr></table></figure><p>上述配置实现<code>ssh fgq</code>时先登录relay 机器，然后再登录到 fgq 主机。</p><h3 id="github登录方式">github登录方式</h3><p><a href="https://blog.csdn.net/nbaDWde/article/details/80360836?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https和ssh两种</a><br><a href="https://baijiahao.baidu.com/s?id=1717846683433344604&amp;wfr=spider&amp;for=pc">https密码设置</a></p><h3 id="配置文件">配置文件</h3><h4 id="全局配置文件">全局配置文件</h4><p>全局配置文件有<code>~/.gitconfig</code>和<code>~/.git-credentials</code>两个</p><p><code>~/.gitconfig</code>对应着<code>git config --global</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name fgq<br> <br>//删<br>git config  --global --<span class="hljs-built_in">unset</span> user.name<br> <br>//改<br>git config --global user.name fgq<br></code></pre></td></tr></table></figure><p>比如修改GitHub账号名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config  --global  user.name hansanf<br></code></pre></td></tr></table></figure><p><code>~/.gitconfig</code>文件就会相应的做出修改<br><img src="https://img-blog.csdnimg.cn/6e26501083b945e1a65f2c225387b949.png" alt="在这里插入图片描述"></p><p><code>~/.git-credentials</code>中文是资格证书，里面保存github的token，使每次登陆都可以免密, 该部分应该是https token,也可以直接使用上面介绍的 ssh 配置。</p><p>需要注意的是, 在hexo 的 deploy (_config.yml) 中,</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:hansanf/hansanf.github.io.git</span>    <span class="hljs-comment"># ssh 方式, 需要设置 ssh</span><br>    <span class="hljs-comment">#repo: https://github.com/hansanf/hansanf.github.io   #https 方式, 需要设置 git-credentials </span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>repo 的地址可以在 github 的 repo 页面，点击 Code, 查看对应的 https 地址和ssh 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://GitHub用户名:具体的token@github.com<br></code></pre></td></tr></table></figure><h4 id="局部配置文件">局部配置文件</h4><p>在使用 <code>git init 文件目录</code>命令配置的git工作区中，即<code>文件目录/.git/config</code>，是局部配置文件，对应着<code>git config --local</code>命令。</p><p><code>.gitignore</code>也是只对当前工作区起作用，可以把要忽略的文件名填进去，然后Git就会自动忽略这些文件</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 不忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><h3 id="git-命令">git 命令</h3><h4 id="把修改-删除-新建文件添加到暂存区">把修改/删除/新建文件添加到暂存区</h4><ul><li>修改和删除的  <code>git add -u</code>  --update</li><li>修改和新建的  <code>git add .</code></li><li>修改、删除和新建的 <code>git add -A</code> -ALL</li></ul><h4 id="add后的东西撤销">add后的东西撤销</h4><ul><li><code>git status</code> 查看暂存区有哪些文件</li><li><code>git reset HEAD</code> 撤销暂存区所有文件到工作区 =&gt; 所有绿变红</li><li><code>git reset HEAD /XXX/XXX.cpp</code> 撤销暂存区特定的文件到工作区 =&gt; 特定绿变红</li><li><code>git checkout --  路径或文件</code> 只能用于已经被索引的文件，从工作区撤销，路径可以是 . =&gt; 红变无</li><li><code>git checkout -- .</code> =&gt; 所有文件红变无</li></ul><p>没有被索引的文件，意味着其是新文件，想红变无直接用 rm 即可</p><p>恢复到前一个commit, 并且将当前commit 的提交全部变为 绿色 <code>git reset --soft HEAD^</code></p><p>恢复到前一个commit，并且将当前commit 的提交全部变为 红色 <code>git reset --mixed HEAD^</code></p><p>–soft 和 --mixed 不会修改文件内容，只会修改文件在仓库的状态</p><p>将某个文件从当前提交中删除, 有一条删除该文件的修改，但文件内容不会变 <code>git rm --cache test.txt</code></p><h4 id="提交到本地仓库（repository）">提交到本地仓库（repository）</h4><p><code>git commit -m &quot;记录版本信息&quot;</code> 提交暂存区文件到本地仓库<br><code>git log</code> 查看commit-id和所有的版本信息</p><h4 id="提交仓库后，再次修改而不保留上次commit信息">提交仓库后，再次修改而不保留上次commit信息</h4><ul><li><code>git commit --amend</code><br>在本地仓库内容没有合并入远程分支时，可以给上次commit的内容打补丁。打完补丁后，上次的commit-id和其版本信息都被本次的amend所覆盖<br>加上 --no-edit 可直接跳过修改comment</li></ul><h4 id="推到远程仓库，合入master">推到远程仓库，合入master</h4><ul><li><code>git push origin HEAD:refs/for/master </code><br>origin是远程仓库的代名词<br>master远程仓库的分支</li></ul><h4 id="避免push到远程合入时有冲突，先拉远程最新分支">避免push到远程合入时有冲突，先拉远程最新分支</h4><ul><li><code>git stash</code> 把本地修改的内容保存到堆栈中</li><li><code>git pull</code> 拉取远程最新代码，并merge到本地HEAD  <code>git pull = git fetch ; git merge </code></li><li><code>git stash pop</code> 修改内容从堆栈弹出<br>然后再 add，commit。这样可以基于当前的最新内容进行更改</li></ul><h4 id="merge时有冲突，手动修改冲突内容">merge时有冲突，手动修改冲突内容</h4><p>打开冲突文件</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-section">=======</span><br>Creating a new branch is quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><p>======= 是两个版本的冲突内容，上面是当前版本，下面是别的分支修改后的版本，删掉不需要的内容，和所有==、&gt;&gt;·HEAD。</p><p>TODO: 怎么用还不太确定<br>自动修改冲突，使用 git checkout --ours 或者 git checkout --theirs</p><h4 id="单独克隆一个分支">单独克隆一个分支</h4><p>git clone --branch 分支名 --depth 分支深度<br>单独克隆一个分支后git pull只能拉取当前分支的内容，若需要其他分支，需要先fetch到本地：git fetch origin [remote-branch]:[local-branch]</p><h4 id="打补丁">打补丁</h4><p>制作补丁：git diff &gt; xxx.patch<br>检查patch文件：git apply --stat xxx.patch<br>查看补丁是否能够干净顺利地应用到当前分支中: git apply --check xxx.patch<br>将补丁合入当前分支 git apply xxx.patch</p><h3 id="git-error-解决">git error 解决</h3><h4 id="fatal-refusing-to-merge-unrelated-histories">fatal: refusing to merge unrelated histories</h4><p><a href="https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error">https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error</a></p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>参考：<br><a href="https://blog.csdn.net/themagickeyjianan/article/details/79683980?spm=1001.2014.3001.5506">修改git config配置文件</a></p><p><a href="https://blog.csdn.net/Lakers2015/article/details/111990909">Git 中的.gitignore文件的作用及配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量</title>
    <link href="/2021/11/25/linux-environment-path/"/>
    <url>/2021/11/25/linux-environment-path/</url>
    
    <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="三个文件">三个文件</h3><h4 id="1-etc-profile">1. <code>/etc/profile</code></h4><p>系统级别，可以所有用户起作用，网上有说是在用户登录时读取的。但在我电脑上使用<code>source /etc/profile</code>后只在当前终端起作用，新建终端仍不生效，为了以后在每个终端上都生效可以在<code>~/.bashrc</code>中添加<code>source /etc/profile</code>。<br>注意<code>~/.bashrc</code>和<code>/etc/profile</code>中还包括对终端其他方面的设置，比如显示格式、颜色</p><h4 id="2-etc-environment">2. <code>/etc/environment</code></h4><p>系统级别，应该是专门用于设置环境变量的，据说优先级高于<code>/etc/profile</code>，没验证过。</p><h4 id="3-bashrc">3. <code>~/.bashrc</code></h4><p>只对当前用户生效，在个人电脑上直接修改这个文件即可，简单省事。</p><h3 id="环境变量书写格式">环境变量书写格式</h3><p>最好在文件末尾添加</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin:/usr/bin<br></code></pre></td></tr></table></figure><p><code>PATH</code>表示环境变量，等号两边不要有空格（shell语法，赋值时等号两边不能有空格）<br><code>$PATH</code>表示取变量值，即如果上面定义了<code>PATH</code>，可以直接引用上面定义好的环境变量，所以这也是为什么要加在文件末尾<br><code>:</code>为分隔符，每一个环境变量的路径都要用<code>:</code>分开</p><p>上面这段代码等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin<br>PATH=<span class="hljs-variable">$PATH</span>:/usr/bin<br></code></pre></td></tr></table></figure><p>修改好后，使用source使其生效</p><h3 id="3-export命令">3.export命令</h3><p>export命令使环境变量在当前终端生效，关闭终端后失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:环境变量路径<br></code></pre></td></tr></table></figure><p>注意，一定要加上<code>$PATH</code>,否则会使已有的环境变量全都失效，只剩下新添加的</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ln命令</title>
    <link href="/2021/11/25/cmd-ln/"/>
    <url>/2021/11/25/cmd-ln/</url>
    
    <content type="html"><![CDATA[<h3 id="ln命令">ln命令</h3><h4 id="格式和参数">格式和参数</h4><p>语法格式： ln [参数] <strong>[源</strong>文件或目录] [<strong>目标</strong>文件或目录]<br>ln a b  a=&gt;b</p><table><thead><tr><th>参数</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td>空</td><td>hard</td><td>对源文件建立硬链接</td></tr><tr><td>-s</td><td>soft</td><td>对源文件建立软连接（符号链接）</td></tr><tr><td>-f</td><td>force</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-b</td><td>backup</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-i</td><td>Interactive</td><td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td></tr><tr><td>-v</td><td>verbose</td><td>详细信息模式，输出指令的详细执行过程</td></tr><tr><td>-d</td><td>direction</td><td>此选项允许“root”用户建立目录的硬链接</td></tr></tbody></table><h4 id="软连接、硬链接和拷贝的区别">软连接、硬链接和拷贝的区别</h4><p><strong>软连接：</strong></p><ul><li>链接文件内存储的是原文件的inode，也就是说是用来指向原文件文件，这<strong>两个文件的inode是不一样</strong>的</li><li>软链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li><li>删除软链接的链接文件，被链接文件不会受到任何影响，但是修改软链接文件内容，被链接文件内容也会被修改</li><li>软链接可以跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接不可以。</li><li>软链接可以对目录进行链接，硬链接不可以。</li><li>删除软链接的被链接文件，链接文件会变成红色，这时打开链接文件会报错，报找不到被链接的文件这种错误</li></ul><p><strong>硬连接：</strong><br>-硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件，这两个文件的<strong>inode号是同一个</strong>（ls -i）</p><ul><li>硬链接以文件副本的形式存在，但不占用实际空间。</li><li>硬链接不允许普通用户给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li></ul><blockquote><p>A硬链B 删除B后A依然存在，且可用。<br>A软链B 删除B后A存在，但不可用了（相当于Windows下快捷方式指向的目标不存在了）</p></blockquote><p><strong>拷贝：</strong></p><ul><li>拷贝产生的文件是一个独立的文件，有自己的元信息和inode节点</li></ul><blockquote><p>软连接和硬链接在使用时用哪一个，主要看是否需要链接目录，是否依赖相对路径，没有限制条件两者应该都可以使用。</p></blockquote><p>参考：<br><a href="https://www.linuxcool.com/ln">linux命令大全</a><br><a href="https://blog.csdn.net/geerniya/article/details/79093301">软链接、硬链接与复制的区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++可变参数</title>
    <link href="/2021/11/24/cpp-variable-arguments/"/>
    <url>/2021/11/24/cpp-variable-arguments/</url>
    
    <content type="html"><![CDATA[<h3 id="参数列表的…">参数列表的…</h3><p>… 表示函数的参数个数可变，典型的如<code>printf()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * szFormat, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br><span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ; <br></code></pre></td></tr></table></figure><h3 id="使用…实现变参数函数的两种场景">使用…实现变参数函数的两种场景</h3><h4 id="1-格式化字符串">1. 格式化字符串</h4><blockquote><p><strong>使用场景：</strong><br>类似于实现一个printf，输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, va_list ap)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">vasprintf</span>(&amp;buf, format, ap); <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>  <span class="hljs-comment">// 重载了func函数，不重载也行</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list ap;<br>    <span class="hljs-type">char</span> *res = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-built_in">va_start</span>(ap, format);<br>    res = <span class="hljs-built_in">func</span>(format, ap);  <br>    <span class="hljs-built_in">va_end</span>(ap);<br>    <span class="hljs-keyword">return</span> res ;  <br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br>    <span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %s \n&quot;</span>, str) ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果<br>result: info &#123;name:fgq, age:<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br>上面func()函数重载了，如果不是类成员函数，要注意函数定义的顺序，在func(const char* format, …)里要调用<code>func(const char* format, va_list ap)</code> ，因此<code>func(const char* format, ...)</code>要定义在后面。类内成员函数则可以是任意顺序。</p></blockquote><p>实际上完成占位符替换为数据的是<code>int vasprintf (char **buf, const char *format, va_list ap)</code>函数：<br><code>buf</code>：一个用于保存结果的字符串缓冲区<br><code>format</code>：一个格式化字符串<br><code>ap</code>:va_list类型的变量, va_list是一个宏，和va_start(va_list, arg)、va_arg(va_list, type)、va_end(va_list)这些宏在定义在头文件stdarg.h中，下面详细介绍通过这些宏来实现可变参数函数</p><h4 id="2-执行时指定可变参数类型">2.执行时指定可变参数类型</h4><blockquote><p><strong>使用场景：</strong><br>将n个数进行相加，此时n是不确定的，如果用重载方法，可能要重载很多次，如下面的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例子：<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2, <span class="hljs-type">double</span> d3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br></code></pre></td></tr></table></figure><p>使用可变参数的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;  <span class="hljs-comment">//格式:count代表参数个数, ...代表n个参数</span><br> <br>va_list ap;  <span class="hljs-comment">//声明一个va_list变量</span><br><span class="hljs-built_in">va_start</span>(ap, count);  <span class="hljs-comment">//第二个参数表示形参的个数</span><br> <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <span class="hljs-comment">// 按顺序返回参数列表中的参数</span><br>res += <span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>);   <span class="hljs-comment">//第二个参数表示形参类型</span><br>&#125;<br><br><span class="hljs-built_in">va_end</span>(ap);  <span class="hljs-comment">//用于清理</span><br> <br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">输出结果：<br>6<br></code></pre></td></tr></table></figure><h3 id="使用initializer-list实现变参函数">使用initializer_list实现变参函数</h3><p><code>initializer_list</code>是一个列表初始化容器，声明在initializer_list头文件中，可以采用迭代器的方式来遍历参数列表，克服了<code>...</code>需要指定参数个数的缺点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initializerSum</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; il)</span> </span>&#123;<br>   <br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = il.<span class="hljs-built_in">begin</span>(); ptr != il.<span class="hljs-built_in">end</span>(); ptr++)  <span class="hljs-comment">//类似于容器的操作</span><br>&#123;<br>sum += *ptr;<br>&#125;<br> <br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">initializerSum</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) ;  <span class="hljs-comment">// 初始化 initializer_list&lt;int&gt;</span><br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il &#123;<span class="hljs-number">1</span>&#125; ;<br>    res = <span class="hljs-built_in">initializerSum</span>(il);<br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    <span class="hljs-function">std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ill</span> <span class="hljs-params">(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)</span> </span>;<br>    res = <span class="hljs-built_in">initializerSum</span>(ill);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <br>    <span class="hljs-keyword">auto</span> illl = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    res = <span class="hljs-built_in">initializerSum</span>(illl);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="http://en.cppreference.com/w/cpp/utility/initializer_list">cppreference对inittializer_list的介绍</a></p><p><a href="https://blog.csdn.net/baidu_15952103/article/details/105886761">va_list函数学习（va_start，va_end, vasprintf）</a></p><p><a href="https://blog.csdn.net/alex1997222/article/details/78639991">C++可变参数的两种方法</a></p><p><a href="https://blog.csdn.net/anye3000/article/details/6593551">printf,sprintf,vsprintf 区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++宏的使用技巧</title>
    <link href="/2021/11/23/cpp-marco-tips/"/>
    <url>/2021/11/23/cpp-marco-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="宏的使用技巧">宏的使用技巧</h3><blockquote><p>1、在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义<br>2、\ 用来换行<br>3、 # 把变量变为字符串</p></blockquote><h3 id="1-在switch中使代码更简洁">1.在switch中使代码更简洁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br><span class="hljs-keyword">switch</span>(level)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XX(i,name) \</span><br><span class="hljs-meta">case i: \</span><br><span class="hljs-meta">return name; \</span><br><span class="hljs-meta"></span><br><span class="hljs-built_in">XX</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>) ; <br><span class="hljs-built_in">XX</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;INFO&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;WARN&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;ERROR&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;FATAL&quot;</span>) ;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> XX</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-把变量变为字符串">2.把变量变为字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1000</span> ; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(a)&lt;&lt;endl; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(b)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><h3 id="3-打印宏定义内容">3.打印宏定义内容</h3><p>通过预处理指令 #pragma message(宏)，将宏定义内容打印到标准输出, 由于宏定义只是一种文本表示，并不是字符串类型，因此如果宏定义的内容为 “v0.0.1” 这种形式，message 会有如下报错：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;command-line&gt;: <span class="hljs-keyword">error</span>: too many decimal points <span class="hljs-keyword">in</span> <span class="hljs-built_in">number</span><br></code></pre></td></tr></table></figure><p>因此需要将宏的内容转为字符串类型，所以 #pragma message 通常与<a href="#2%E6%8A%8A%E5%8F%98%E9%87%8F%E5%8F%98%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">把变量变为字符串</a>搭配使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(STRING(PROJETCT_VERSION));</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式</title>
    <link href="/2021/11/19/template_pattern/"/>
    <url>/2021/11/19/template_pattern/</url>
    
    <content type="html"><![CDATA[<h3 id="模板模式">模板模式</h3><p><strong>意图:</strong> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决:</strong> 一些方法通用，却在每一个子类都重新写了这一方法。</p><blockquote><p><strong>例子</strong><br>建造房子的流程都是一样的，比如：打地基-&gt;砌砖头-&gt;盖屋顶<br>但是不同种类的房子，比如茅草房和别墅，在这三个步骤中所要做的具体事情不一样<br>此时就可以应用模板模式，在接口类（基类）中抽象出统一的流程，在子类中再重写具体步骤的方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IGame</span>&#123;  <span class="hljs-comment">// 接口类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-comment">//模板：固定不变的部分，定义统一的游戏流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">initialize</span>();<br>        <span class="hljs-built_in">startPlay</span>();<br>        <span class="hljs-built_in">endPlay</span>(); <br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IGame</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basketball</span>:<span class="hljs-keyword">public</span> IGame&#123;  <br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Basketball</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Football</span>:<span class="hljs-keyword">public</span> IGame&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Football</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    IGame *pb ;  <br>    Basketball basketball ; <br>    Football Football ; <br>    pb = &amp;basketball ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    pb = &amp;Football ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打印输出：<br><br><span class="hljs-keyword">Basketball </span>initialize<br><span class="hljs-keyword">Basketball </span>startPlay<br><span class="hljs-keyword">Basketball </span>endPlay<br>Football initialize<br>Football startPlay<br>Football endPlay<br></code></pre></td></tr></table></figure><hr><p><strong>总结：</strong><br>模板模式在类库的设计中很常见，在模板模式中，库设计者会给使用者提供固定的流程和需要重写的接口，使用者通常只需要：<br>1、继承父类；<br>2、重写某一个或某几个接口；<br>3、调用包含了所有流程的方法，比如<code>play()</code></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的设计原则和分类</title>
    <link href="/2021/11/19/design-pattern-priciple-classification/"/>
    <url>/2021/11/19/design-pattern-priciple-classification/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式的设计原则和分类">设计模式的设计原则和分类</h2><h3 id="设计原则">设计原则</h3><h4 id="1、依赖倒置原则（DIP）">1、依赖倒置原则（DIP）</h4><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul><h4 id="2、开放封闭原则（OCP）">2、开放封闭原则（OCP）</h4><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><h4 id="3、单一职责原则（SRP）">3、单一职责原则（SRP）</h4><ul><li>一个类应该仅有一个引起他变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h4 id="4、Liskov替换原则（LSP）">4、Liskov替换原则（LSP）</h4><ul><li>子类必须能够替换他们的基类（IS-A）。</li><li>继承表达类型抽象。</li></ul><h4 id="5、接口隔离原则（ISP）">5、接口隔离原则（ISP）</h4><ul><li>不应该强迫客户程序依赖他们不用的方法。</li><li>接口应该小而完备。</li></ul><h4 id="6、迪米特洛原则（最少知识原则）">6、迪米特洛原则（最少知识原则）</h4><ul><li>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</li><li>优先使用对象组合，而不是类继承。类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><h4 id="7、封装变化点">7、封装变化点</h4><ul><li>使用封装来创建对象之间的分解层，让设计者可以在分层的一侧进行修改，而不会对另一侧产生不良的影响，减少层次间的耦合。</li></ul><h4 id="8、针对接口（抽象类）编程，而不是针对实现编程">8、针对接口（抽象类）编程，而不是针对实现编程</h4><ul><li>不将变量类型生命为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无须获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”。</li><li>和依赖倒置原则相辅相成。</li></ul><h3 id="分类">分类</h3><p>三分类：<a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a></p><p>李建忠老师的九分类：</p><table><thead><tr><th>模式分类</th><th>包括</th></tr></thead><tbody><tr><td><strong>组件协作</strong></td><td>模板模式<br>策略模式<br>观察者模式</td></tr><tr><td><strong>单一职责</strong></td><td>装饰者模式<br> 桥接模式</td></tr><tr><td><strong>对象创建</strong></td><td>工厂模式<br>抽象工厂模式<br>原型模式<br>建造者模式</td></tr><tr><td><strong>对象性能</strong></td><td>单例模式<br>享元模式</td></tr><tr><td><strong>接口隔离</strong></td><td>门面模式<br>代理模式<br>适配器模式<br>中介者模式</td></tr><tr><td><strong>状态变化</strong></td><td>状态模式<br>备忘录模式</td></tr><tr><td><strong>数据结构</strong></td><td>组合模式<br>迭代器模式<br>职责链模式</td></tr><tr><td><strong>行为变化</strong></td><td>命令模式<br>访问器模式</td></tr><tr><td><strong>领域问题</strong></td><td>解析器模式</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_opencv</title>
    <link href="/2021/11/12/vscode-opencv/"/>
    <url>/2021/11/12/vscode-opencv/</url>
    
    <content type="html"><![CDATA[<h3 id="win10-vscode-加载opencv库">win10 vscode 加载opencv库</h3><p>从头到尾的配置：<br>1、Visual Studio Code 配置<br>2、openCV 配置<br>3、MinGw 配置<br>4、cmake 配置<br>完整过程参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>如果使用vscode已经可以编译c++程序了，即可以省略掉大部分vscode和的MinGW的配置过程（只要vscode中配置好opencv的头文件路径和库路径即可）</p><p>opencv的配置过程，实际上就是库的加载过程，如果是已经编译好的opencv库，只要配置好头文件路径和库文件路径即可，如果是下载的源文件，则需要通过cmake进行编译。<br>cmake编译opencv参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>opencv已经编译好了之后，把头文件路径和库文件路径加到系统的环境变量中。</p><p>最后配置vscode的三个.json文件：<code>launch.json</code>、<code>tasks.json</code>、<code>c_cpp_properties.json</code></p><p>各自的配置如下：<br><code>launch.json</code>：主要注意<strong>miDebuggerPath</strong>和<strong>program</strong>两项</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">Use</span> <span class="hljs-string">IntelliSense</span> <span class="hljs-string">to</span> <span class="hljs-string">learn</span> <span class="hljs-string">about</span> <span class="hljs-string">possible</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">Hover</span> <span class="hljs-string">to</span> <span class="hljs-string">view</span> <span class="hljs-string">descriptions</span> <span class="hljs-string">of</span> <span class="hljs-string">existing</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-string">more</span> <span class="hljs-string">information</span>, <span class="hljs-attr">visit:</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        <br>        <br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;:</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;:</span> [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;:</span> [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;:</span> <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gdb.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;:</span> [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;:</span> <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json</code>：<br>主要修改<strong>args</strong>中大i、大L和小l<br>这里实际上就是g++ -I 头文件路径 -L 库文件路径 -l 库文件名<br>注意实际库文件的命名和这里写库文件名的区别   实际库文件名=lib库文件名.dll.a</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">See</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">documentation</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">tasks.json</span> <span class="hljs-string">format</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;command&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>    <span class="hljs-attr">&quot;args&quot;:</span> [<br>        <span class="hljs-string">&quot;-g&quot;</span>, <br>        <span class="hljs-string">&quot;-std=c++11&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <br>        <span class="hljs-string">&quot;-o&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,  <br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>,<br>        <span class="hljs-string">&quot;-L&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\x64\\MinGW\\lib&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_core3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_dnn3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_features2d3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_flann3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_highgui3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgcodecs3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgproc3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ml3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_objdetect3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_photo3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_shape3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_stitching3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_superres3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_video3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videoio3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videostab3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ts3416&quot;</span><br><br>  <br>    ],<span class="hljs-string">//</span> <span class="hljs-string">编译命令参数</span><br>    <span class="hljs-string">&quot;problemMatcher&quot;</span><span class="hljs-string">:</span>&#123;<br>        <span class="hljs-attr">&quot;owner&quot;:</span> <span class="hljs-string">&quot;cpp&quot;</span>,<br>        <span class="hljs-string">&quot;fileLocation&quot;</span><span class="hljs-string">:</span>[<br>            <span class="hljs-string">&quot;relative&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;pattern&quot;</span><span class="hljs-string">:</span>[<br>            &#123;<br>                <span class="hljs-attr">&quot;regexp&quot;:</span> <span class="hljs-string">&quot;^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$&quot;</span>,<br>                <span class="hljs-attr">&quot;file&quot;:</span> <span class="hljs-number">1</span>,<br>                <span class="hljs-attr">&quot;location&quot;:</span> <span class="hljs-number">2</span>,<br>                <span class="hljs-attr">&quot;message&quot;:</span> <span class="hljs-number">3</span><br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;group&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;kind&quot;:</span> <span class="hljs-string">&quot;build&quot;</span>,<br>        <span class="hljs-attr">&quot;isDefault&quot;:</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>：<br>主要修改<strong>includePath</strong>和<strong>compilerPath</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;win&quot;</span>,<br>            <span class="hljs-attr">&quot;includePath&quot;:</span> [<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>         <br>            ],<br>            <span class="hljs-attr">&quot;defines&quot;:</span> [],<br>            <span class="hljs-attr">&quot;compilerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gcc.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;cStandard&quot;:</span> <span class="hljs-string">&quot;c11&quot;</span>,<br>            <span class="hljs-attr">&quot;cppStandard&quot;:</span> <span class="hljs-string">&quot;c++17&quot;</span>,<br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;:</span> <span class="hljs-string">&quot;clang-x64&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不是完全照搬上述的配置，需要注意：</p><ul><li><code>launch.json</code>的<strong>preLaunchTask</strong>和<code>tasks.json</code>中的<strong>label</strong>内容需要一致，否则报错，比如修改<code>launch.json</code>的<strong>preLaunchTask</strong>为g++.exe，则会报错<br><img src="https://img-blog.csdnimg.cn/0539074e59fe455882f429a521c318b4.png" alt="在这里插入图片描述"><br>三个json文件的作用：<br><code>tasks.json</code> (build instructions)<br><code>launch.json</code> (debugger settings)<br><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings</li></ul><p>vscode配置官方教程：<a href="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之类图表示</title>
    <link href="/2021/11/07/UML/"/>
    <url>/2021/11/07/UML/</url>
    
    <content type="html"><![CDATA[<h3 id="类图属性">类图属性</h3><p>一个大矩形里面分三层：</p><ul><li>类名</li><li>成员名：可见性 名称 ：类型 [ = 默认值]</li><li>方法名：可见性  名称(参数列表) [ ： 返回类型]<br><img src="https://img-blog.csdnimg.cn/c59f02761f6b4d5c926297de49d48cfa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>可见性：</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected（friendly也归入这类）</li></ul><h3 id="类之间关系">类之间关系</h3><h4 id="1、依赖">1、依赖</h4><p>依赖关系使用<strong>带箭头的虚线</strong>来表示，箭头从使用类指向被依赖的类。</p><p><strong>人依赖手机：</strong><br><img src="https://img-blog.csdnimg.cn/f53bd1f094a946b9a8121fe7f7c3beb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>依赖（Dependency）关系是一种<strong>使用关系</strong>，它是对象之间耦合度最弱的一种关联方式，被使用对象的有无，不影响使用对象，是临时性的关联。</p><h4 id="2、关联">2、关联</h4><p>依赖关系使用<strong>带箭头的实线</strong>来表示，箭头从使用类指向被关联的类，可以单向关联，也可以双向关联。</p><p>双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示。</p><p><strong>老师和学生双向关联：<strong>每个老师可以教多个学生，每个学生也可向多个老师学<br><img src="https://img-blog.csdnimg.cn/59ed529d91fb40fcb133824a7fc0f59b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>关联（Association）关系是对象之间的一种</strong>引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。被引用者不存在时，引用者可以存在，但是没有意义。</p><h4 id="3、聚合">3、聚合</h4><p>聚合关系可以用<strong>带空心菱形的实线</strong>来表示，菱形指向整体。</p><p><strong>大学包含教师：</strong><br><img src="https://img-blog.csdnimg.cn/5979cb34f002423bb819274d3a3798d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是<strong>整体和部分之间的关系</strong>，是 has-a 的关系。当部分类不存在，整体类也不能存在，但是部分可以脱离整体而独立存在。比如大学不能脱离教师而存在，但是没有大学教师依然能够独立存在。</p><h4 id="4、组合">4、组合</h4><p>组合关系用<strong>带实心菱形的实线来表示</strong>，菱形指向整体<br><strong>头和嘴：</strong><br><img src="https://img-blog.csdnimg.cn/9accac46ce1d4eb382cdf8d1c00623b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象也不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><h4 id="5、泛化">5、泛化</h4><p>泛化关系用<strong>带空心三角箭头的实线</strong>来表示，箭头从子类指向父类。</p><p><strong>人和学生、老师：</strong><br><img src="https://img-blog.csdnimg.cn/b27b8f34dcfd4134b179533991d8d045.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是<strong>父类与子类之间的关系，是一种继承关系</strong>，是 is-a 的关系。</p><h4 id="6、实现">6、实现</h4><p>实现关系使用<strong>带空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><strong>鸟和飞：</strong><br><img src="https://img-blog.csdnimg.cn/2380c43ba2dc4c07b395882e3930059c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>实现（Realization）关系是<strong>接口与实现类之间的关系</strong>。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。可以将实现类看做方法。</p><p>参考：<br><a href="https://www.cnblogs.com/shindo/p/5579191.html">https://www.cnblogs.com/shindo/p/5579191.html</a><br><a href="https://blog.csdn.net/sinat_21107433/article/details/102576624">https://blog.csdn.net/sinat_21107433/article/details/102576624</a><br><a href="http://c.biancheng.net/view/1319.html">http://c.biancheng.net/view/1319.html</a><br><a href="https://www.jianshu.com/p/641682f9c918">https://www.jianshu.com/p/641682f9c918</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update_nodejs</title>
    <link href="/2021/11/01/update-nodejs/"/>
    <url>/2021/11/01/update-nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu升级nodejs">Ubuntu升级nodejs</h2><h3 id="下载nodejs压缩文件">下载nodejs压缩文件</h3><p>打开nodejs官网，打开<code>DOWNLOADS</code>页面，选择一个版本，右键复制链接地址，然后使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">wget https://nodejs.org/dist/v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><p>下载到本地</p><h3 id="解压">解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><h3 id="将node和npm设置为全局">将node和npm设置为全局</h3><p>将新的node可执行文件<strong>硬链接</strong>到/usr/local/bin/node,如果提示连接已存在，可将/usr/local/bin/node删掉，再重新连接(删除前建议先备份)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/node /usr/local/bin/node<br> <br>sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/npm /usr/local/bin/npm  <br></code></pre></td></tr></table></figure><p><strong>/bin/usr和/bin/local/usr的区别：</strong><br>   /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。<br>   /usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。<br>   /如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fgq@ubuntu:~/hexo_blog$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br></code></pre></td></tr></table></figure><p>   这里/usr/local/bin优先于/usr/bin, 一般都是如此</p><p><strong>另外一种设为全局的方法：使用别名alias</strong></p><p>当前终端生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> node=解压后路径/node-v16.13.0-linux-x64/bin/node<br><span class="hljs-built_in">alias</span> npm=解压后路径/node-v16.13.0-linux-x64/bin/npm<br></code></pre></td></tr></table></figure><p>永久生效：<br>  修改主目录下.bashrc文件(~/.bashrc)，添加上述两句<br>   然后 <code>source  ~/.bashrc</code><br><strong>note:</strong> 等号两边没有空格</p><blockquote><p>node和nodejs之间没有区别，node全称就是nodejs。nodejs是一个基于Chrome V8引擎的JavaScript运行环境</p></blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_37035946/article/details/99451703">1、https://blog.csdn.net/qq_37035946/article/details/99451703</a><br><a href="https://blog.csdn.net/nzjdsds/article/details/88345400">2、https://blog.csdn.net/nzjdsds/article/details/88345400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux_tips</title>
    <link href="/2021/11/01/linux-tips/"/>
    <url>/2021/11/01/linux-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="linux">linux</h3><p>for linux tips</p><h5 id="格式化环境变量">格式化环境变量</h5><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span>|awk -F<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;for(i=1;i&lt;=NF;i++)print <span class="hljs-variable">$i</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="清空共享内存">清空共享内存</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ipcs|awk &#x27;</span><span class="hljs-template-variable">&#123;print $1&#125;</span><span class="language-xml">&#x27;|xargs -I </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> sudo ipcrm -M </span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="查看系统启动时间">查看系统启动时间</h5><p><code>ps -p PID -o lstart</code></p><p>top 的 TIME 是占用 cpu 时间</p><p>(加sudo 权限)修改系统时间和时区: <a href="https://www.cnblogs.com/ljy2013/p/4615149.html">https://www.cnblogs.com/ljy2013/p/4615149.html</a></p><h5 id="磁盘-U盘-挂载">磁盘/U盘 挂载</h5><p>查看磁盘列表</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo fdisk -l</span><br></code></pre></td></tr></table></figure><p>挂载 mount</p><p>卸载 umount</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mount 磁盘名称 挂载路径<br>sudo umount 磁盘名称<br>比如: <br>sudo mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/home/</span>work/<br>sudo umount <span class="hljs-regexp">/dev/</span>sda1    <br></code></pre></td></tr></table></figure><p>不小心拔下在复制数据的移动硬盘出现无法加载的错误</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MFTMirrdoesnotmatchMFTMirrdoesnotmatchMFT (<span class="hljs-built_in">record</span> <span class="hljs-number">0</span>).<br>Failed <span class="hljs-keyword">to</span> mount &#x27;/dev/sda1&#x27;: Input/output <span class="hljs-keyword">error</span><br>NTFS <span class="hljs-keyword">is</span> either inconsistent, <span class="hljs-keyword">or</span> there <span class="hljs-keyword">is</span> a hardware fault, <span class="hljs-keyword">or</span> <span class="hljs-keyword">it</span>&#x27;s a<br>SoftRAID/FakeRAID hardware. In <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> case <span class="hljs-built_in">run</span> chkdsk /f <span class="hljs-keyword">on</span> Windows<br><span class="hljs-keyword">then</span> reboot <span class="hljs-keyword">into</span> Windows twice. The usage <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> /f parameter <span class="hljs-keyword">is</span> very<br>important! If <span class="hljs-keyword">the</span> device <span class="hljs-keyword">is</span> a SoftRAID/FakeRAID <span class="hljs-keyword">then</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">activate</span><br><span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> mount a different device under <span class="hljs-keyword">the</span> /dev/mapper/ directory, (e.g.<br>/dev/mapper/nvidia_eahaabcc1). Please see <span class="hljs-keyword">the</span> &#x27;dmraid&#x27; documentation<br><span class="hljs-keyword">for</span> more details.<br></code></pre></td></tr></table></figure><p>LINUX下<code>sudo ntfsfix /dev/sda1</code></p><h5 id="输出重定向">输出重定向</h5><p>标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2</p><p>2&gt;&amp;1  意思是把 标准错误输出 重定向到 标准输出.</p><p>&amp;&gt;file  意思是把标准输出 和 标准错误输出 都重定向到文件file中</p><h5 id="磁盘分区和安装文件系统">磁盘分区和安装文件系统</h5><p><a href="https://blog.csdn.net/qq_43527718/article/details/122850052">https://blog.csdn.net/qq_43527718/article/details/122850052</a></p><p>sudo fdisk /dev/nvme0n1</p><p>n  添加分区</p><p>p 打印分区表 查看分区成功否</p><p>w 保存</p><p>mkfs -t ext4 /dev/nvme0n1p1  给第一个分区安装文件系统</p><p>sudo blkid /dev/nvme0n1p1  查看nvme0n1p1属性</p><h5 id="命令行启动向日葵">命令行启动向日葵</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ps -ef | <span class="hljs-keyword">grep</span> sun<br>root       <span class="hljs-number">836</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">18</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/oray_rundaemon -m server<br>root       <span class="hljs-number">856</span>   <span class="hljs-number">836</span>  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">08</span>:<span class="hljs-number">43</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/sunloginclient -m service<br><br>杀掉两个进程后执行<br>(开机自启动服务):<br>sudo systemctl start runsunloginclient.service<br>sudo systemctl enable runsunloginclient.service<br></code></pre></td></tr></table></figure><h5 id="apt">apt</h5><p>apt 的目录</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/</span>apt/<span class="hljs-keyword">source</span>.list 源列表，apt update 所使用的源<br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists index 位置，即 apt update所更新的包的标签<br><span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archive  apt-get install 下载安装包的路径<br></code></pre></td></tr></table></figure><p>命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">apt-cache show 包名，展示的是<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists 目录下所对应的标签的信息<br>apt list 当前所使用的源所能获取到的软件包(deb)<br>apt install 包<br>apt remove 包<br></code></pre></td></tr></table></figure><p>小 tip：当编译提示缺少什么库的时候的，apt list|grep 库 试下, 一般是 libxxx-dev，可以试下 apt install libxxx-dev</p><h4 id="wget">wget</h4><p>wget 下载目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -r -np -nH -R index.html http:<span class="hljs-regexp">//u</span>rl<span class="hljs-regexp">/including/</span>files/you<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/380793959">https://zhuanlan.zhihu.com/p/380793959</a></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@j5dvb</span><span class="hljs-symbol">:/map/guoqing</span>.feng/multiperception<span class="hljs-comment"># wget  https://www.xxx.io/output.tar</span><br><span class="hljs-symbol">wget:</span> bad address <span class="hljs-string">&#x27;www.xxx.io&#x27;</span><br></code></pre></td></tr></table></figure><p>修改域名解析配置 /etc/resolv.conf，没有则新建，格式如下:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">127.0.0.53</span><br></code></pre></td></tr></table></figure><h3 id="tar传输文件">tar传输文件</h3><p>tar cf - src_dir  | ssh user@ip “tar xf - -C dst_path”<br>会节省4次磁盘操作，提升一下开发效率。</p><h3 id="export-当前所有目录下的动态库">export 当前所有目录下的动态库</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> `<span class="hljs-built_in">find</span> -name <span class="hljs-string">&quot;*.so&quot;</span>|xargs -I &#123;&#125; realpath &#123;&#125; | xargs -I &#123;&#125; dirname &#123;&#125;`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:$p; done<br></code></pre></td></tr></table></figure><h3 id="vim">vim</h3><h4 id="块模式">块模式</h4><p>windows 快捷键 ctrl+v<br>mac  快捷键 shift+control+v<br>进入visual block 后，上下选择行的范围 -&gt; 输入内容 -&gt; 按 I -&gt; 按 ESC -&gt; 完成多行的一起修改</p><h4 id=""></h4><p>行首输入 I<br>行尾输入</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类和对象的内存布局</title>
    <link href="/2021/11/01/cpp-memory-layout/"/>
    <url>/2021/11/01/cpp-memory-layout/</url>
    
    <content type="html"><![CDATA[<h3 id="用g-查看内存布局的方法：">用g++查看内存布局的方法：</h3><p>  g++ 版本&gt;8.0：<code>g++ -fdump-lang-class vptr.cpp</code><br>  g++ 版本&lt;8.0：<code>g++ -fdump-class-hierarchy vptr.cpp</code><br><a href="https://blog.csdn.net/Ineedapassward/article/details/118417116">参考：https://blog.csdn.net/Ineedapassward/article/details/118417116</a></p><h3 id="类的内存布局">类的内存布局</h3><p><a href="https://blog.csdn.net/shichao1470/article/details/91563282">参考：https://blog.csdn.net/shichao1470/article/details/91563282</a></p><h3 id="菱形继承下对象的内存布局">菱形继承下对象的内存布局</h3><p><a href="https://blog.csdn.net/j4ya_/article/details/80177897">参考：https://blog.csdn.net/j4ya_/article/details/80177897</a></p><h3 id="菱形继承下类的内存布局">菱形继承下类的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;X::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Y::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">funcY</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span>: <span class="hljs-keyword">public</span> X,  <span class="hljs-keyword">public</span> Y&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Z::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(Base)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(X)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Y)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Z)&lt;&lt;endl ; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>64位系统下运行，sizeof(int *) 等于8，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">8<br>8<br>8<br>16<br></code></pre></td></tr></table></figure><p><strong>问题：</strong><br>  类Base的size为8，是因为有一个虚表指针，<br>  类X和类Y的size也为8，也是因为各自只有一个虚表指针？<br>  类Z的size为16，是为甚？不采用虚继承的时候结果不变，为甚？<br>使用g++ 查看内存布局，结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Vtable <span class="hljs-keyword">for</span> Z<br>Z::_ZTV1Z: <span class="hljs-number">6</span> entries<br><span class="hljs-number">0</span>     (int <span class="hljs-comment">(*)(...))0</span><br><span class="hljs-comment">8     (int (*)</span>(...))(&amp; _ZTI1Z)<br><span class="hljs-number">16</span>    (int <span class="hljs-comment">(*)(...))Z::func</span><br><span class="hljs-comment">24    (int (*)</span>(...))-<span class="hljs-number">8</span><br><span class="hljs-number">32</span>    (int <span class="hljs-comment">(*)(...))(&amp; _ZTI1Z)</span><br><span class="hljs-comment">40    (int (*)</span>(...))Z::_ZThn8_N1Z4funcEv<br><br><span class="hljs-keyword">Class</span> Z<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br>Z (<span class="hljs-number">0</span>x0x3feb780) <span class="hljs-number">0</span><br>    vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">16</span>)<br>  X (<span class="hljs-number">0</span>x0x3feb7c0) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>      primary-<span class="hljs-keyword">for</span> Z (<span class="hljs-number">0</span>x0x3feb780)<br>    Base (<span class="hljs-number">0</span>x0x3fdca48) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> X (<span class="hljs-number">0</span>x0x3feb7c0)<br>  Y (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>      vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>    Base (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>为啥</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Y</span> (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-empty<br>    <span class="hljs-attribute">vptr</span>=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>  <span class="hljs-attribute">Base</span> (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-empty<br>      <span class="hljs-attribute">primary</span>-for Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>这里是什么东西啊？</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error_non_const_lvalue</title>
    <link href="/2021/10/31/error-non-const-lvalue/"/>
    <url>/2021/10/31/error-non-const-lvalue/</url>
    
    <content type="html"><![CDATA[<h4 id="error：cannot-bind-non-const-lvalue-reference-of-type-‘xxx-‘-to-an-rvalue-of-type-‘xxx‘">error：cannot bind non-const lvalue reference of type ‘xxx&amp;‘ to an rvalue of type ‘xxx‘</h4><p>非常量左值引用不能赋给右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base()&quot;</span>&lt;&lt;endl ; <br>    &#125;; <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base &amp;other)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base(Base &amp;other)&quot;</span>&lt;&lt;endl ; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b0 ; <br>    <span class="hljs-comment">// 三种调用拷贝构造创建对象的方式</span><br>    <span class="hljs-function">Base <span class="hljs-title">b1</span><span class="hljs-params">(b0)</span> </span>;  <br>    Base b2 = b0 ; <br>    Base b3 = <span class="hljs-built_in">Base</span>(b0) ;   <span class="hljs-comment">// 当拷贝构造函数为 Base(Base &amp;other) 而不是Base(const Base &amp;other)时，报错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原因：</strong><br>  如果一个参数是以非const引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。但如果你把一个临时变量当作非const引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，<strong>c++ 编译器加入了临时变量不能作为非const引用的这个语义限制。</strong></p><p><a href="https://blog.csdn.net/digitalkee/article/details/105092400">参考：https://blog.csdn.net/digitalkee/article/details/105092400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缺少模板参数列表</title>
    <link href="/2021/10/28/template_typename_T/"/>
    <url>/2021/10/28/template_typename_T/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/da1fd3f3cf3244ecac3814f3e1ed0f0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* data */</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">vector</span>(<span class="hljs-comment">/* args */</span>);<br>    ~ <span class="hljs-built_in">vector</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T <span class="hljs-type">const</span>&amp; )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 不加这一行 会报错：“缺少模板参数列表”</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>参考 <a href="https://blog.csdn.net/u013891092/article/details/51583666/">https://blog.csdn.net/u013891092/article/details/51583666/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
