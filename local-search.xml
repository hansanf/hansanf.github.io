<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>template_meta_program</title>
    <link href="/2023/02/14/template-meta-program/"/>
    <url>/2023/02/14/template-meta-program/</url>
    
    <content type="html"><![CDATA[<h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><p><a href="https://www.cnblogs.com/3d-gis/articles/14392648.html">https://www.cnblogs.com/3d-gis/articles/14392648.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>readthedoc_usage</title>
    <link href="/2023/02/14/readthedoc-usage/"/>
    <url>/2023/02/14/readthedoc-usage/</url>
    
    <content type="html"><![CDATA[<p> 电子书搭建教程：<br> <a href="https://zhuanlan.zhihu.com/p/388640347">https://zhuanlan.zhihu.com/p/388640347</a></p><p>read the docs 官网：<br> <a href="https://readthedocs.org/?utm_source=testingpai.com">https://readthedocs.org/?utm_source=testingpai.com</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>compile_runtime_error</title>
    <link href="/2023/02/14/compile-runtime-error/"/>
    <url>/2023/02/14/compile-runtime-error/</url>
    
    <content type="html"><![CDATA[<h3 id="编译时报错"><a href="#编译时报错" class="headerlink" title="编译时报错"></a>编译时报错</h3><h4 id="找不到依赖库的头文件"><a href="#找不到依赖库的头文件" class="headerlink" title="找不到依赖库的头文件"></a>找不到依赖库的头文件</h4><p>找不到依赖库的头文件，找不到依赖库中头文件所包含的头文件<br>bcloud 引用依赖库时，头文件需要 HEADER 标签发布到output 中。</p><p>发布到output 的头文件，如果包含了库中的其他头文件，也需要一起发布到output 中</p><p>为什么之前没有注意这个问题呢？因为一般头文件不会引用自己所不需要的头文件，只有其需要被引用时，才进行 include。而如果将库中的头文件引用操作放在 .cc 文件，其所include 的头文件的内容直接就编译到库中，在其他库所引用该库时，也就不会存头文件找不到另外一个头文件的问题了。</p><h4 id="undefined-reference-to-atan2-finite’"><a href="#undefined-reference-to-atan2-finite’" class="headerlink" title="undefined reference to &#96;__atan2_finite’"></a>undefined reference to &#96;__atan2_finite’</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-literal">[ERROR]</span> fail <span class="hljs-keyword">to</span> compile baidu/adu-lab/framework/output/bin/radar_fusion_app ip:<span class="hljs-number">10.61</span>.<span class="hljs-number">192.37</span><br> err:bc_out/baidu/adu-lab/framework/app/radar_fusion/baidu_adu-lab_framework_radar_fusion_app_app_radar_fusion.cpp.o: In <span class="hljs-keyword">function</span> `v2x::sensor::radar::radar_fusion::radar<span class="hljs-constructor">_msg_proc(<span class="hljs-params">int</span>, <span class="hljs-params">std</span>::<span class="hljs-params">shared_ptr</span>&lt;<span class="hljs-params">os</span>::<span class="hljs-params">v2x</span>::<span class="hljs-params">device</span>::RadarObstacles <span class="hljs-params">const</span>&gt; <span class="hljs-params">const</span>&amp;)</span>&#x27;:<br>/home/bcloud/bcloud_data/EE/BCLOUD_PROTOBUF/CompileServer/Task/bb84d71b78676b10f34e635275115abf/baidu/adu-lab/framework/app/radar_fusion/radar_fusion.cpp:<span class="hljs-number">118</span>: undefined reference <span class="hljs-keyword">to</span> `__atan2_finite&#x27;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/google/filament/issues/2875">https://github.com/google/filament/issues/2875</a><br><a href="https://stackoverflow.com/questions/62334452/fast-math-cause-undefined-reference-to-pow-finite">https://stackoverflow.com/questions/62334452/fast-math-cause-undefined-reference-to-pow-finite</a><br><a href="https://github.com/google/filament/issues/2146">https://github.com/google/filament/issues/2146</a></p><p>1、去掉 fast-math<br>2、或加上 -fno-builtin +#include&lt;tgmath.h&gt;</p><h3 id="运行时报错"><a href="#运行时报错" class="headerlink" title="运行时报错"></a>运行时报错</h3><h4 id="undefined-symbol"><a href="#undefined-symbol" class="headerlink" title="undefined symbol"></a>undefined symbol</h4><p>1、运行时报 undefined symbol，可能是编译该so 时没有实际链接依赖库，只是使用了头文件，比如编libmsf_Ucommon_Umath.so时没有链接libopencv_core.so，但还是能编译通过，因为其在系统目录下找到了头文件，有些情况仅使用头文件就编译通过了。。</p><p>TODO：具体什么情况只需要头文件</p><p>2、<br>E1219 23:24:25.009349  7549 class_loader_utility.cc:218] [mainboard]LibraryLoadException: &#x2F;home&#x2F;caros&#x2F;work&#x2F;airos_fusion&#x2F;baidu&#x2F;adu-lab&#x2F;airos&#x2F;output&#x2F;3rd&#x2F;libmodules_Sperception-fusion_Salgorithm_Sfusion_Utracker_Stracker_Sprocess_Slibmsf_Utracker_Uprocess.so: undefined symbol: _ZN9algorithm2ft5track14StateContainer9frequent_E</p><p>也是运行期间报 undefined symbol 问题，但 <em>ZN9algorithm2ft5track14StateContainer9frequent_E 这个符号在libmsf_Utracker_Uprocess.so 这个动态库里的，是作为其中一个类的    静态成员变量， 其使用形式为这种：<br>StateContainer() : vx_mean_filter</em>(frequent_), vy_mean_filter_(frequent_){};<br>其使用静态成员变量在初始化列表中对成员变量进行初始化，因此报错，这种形式应该在一些编译参数的设置下是允许的。</p><p>3、undefined symbol 也可能是因为编译链接的库和运行时链接的库版本不一致</p><h3 id="undefined-reference-google-isGoogleLoggingInited"><a href="#undefined-reference-google-isGoogleLoggingInited" class="headerlink" title="undefined reference google::isGoogleLoggingInited()"></a>undefined reference google::isGoogleLoggingInited()</h3><p>从baidu&#x2F;adu-3rd&#x2F;glog 引用了glog库<br>但是本地也有glog库，</p><p>笨方法：<br>删掉本地库后就ok了</p><p>卸载glog的方法：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//安装</span><br>sudo apt-<span class="hljs-built_in">get</span> install libgoogle-glog-<span class="hljs-built_in">dev</span><br><span class="hljs-comment">//卸载</span><br>sudo apt-<span class="hljs-built_in">get</span> remove libgoogle-glog-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>聪明方法：</p><p>使用 ldd命令 查看当前所链接的库是哪一个，是否是想要链接的库，使用export命令把想要链接的库放在前面 </p><h3 id="cpplint-报错"><a href="#cpplint-报错" class="headerlink" title="cpplint 报错"></a>cpplint 报错</h3><h4 id="static-extern-typedef等要放在声明前"><a href="#static-extern-typedef等要放在声明前" class="headerlink" title="static extern typedef等要放在声明前"></a>static extern typedef等要放在声明前</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">select_npy_type</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> NPY_TYPES type = NPY_NOTYPE;<br>&#125;;  <span class="hljs-comment">// Default</span><br></code></pre></td></tr></table></figure><p>3行 : Storage-class specifier (static, extern, typedef, etc) should be at the beginning of the declaration</p><p>static 放在 const 前面即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译报错</tag>
      
      <tag>运行报错</tag>
      
      <tag>cpplint报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv_usage</title>
    <link href="/2023/02/14/opencv-usage/"/>
    <url>/2023/02/14/opencv-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><figure class="highlight zephir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs zephir">cv::Mat m(<span class="hljs-number">1080</span>, <span class="hljs-number">1920</span>, CV_8UC3);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* m_ptr = m.ptr&lt;<span class="hljs-keyword">uchar</span>&gt;(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fgq_n = <span class="hljs-number">0</span>;<br>memcpy((void*)m_ptr, image_blob-&gt;cpu_data(), <span class="hljs-number">1080</span> * <span class="hljs-number">1920</span> * <span class="hljs-number">3</span>);<br>cv::imwrite(<span class="hljs-string">&quot;/home/caros/work/tmp/&quot;</span> + std::to_string(fgq_n++) + <span class="hljs-string">&quot;.png&quot;</span>, m);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GLOG_usage</title>
    <link href="/2023/02/14/GLOG-usage/"/>
    <url>/2023/02/14/GLOG-usage/</url>
    
    <content type="html"><![CDATA[<figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">头文件包含：<br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;glog/logging.h&quot;</span>   <span class="hljs-comment">// 添加头文件</span><br><br>初始化：<br>FLAGS_log_dir = <span class="hljs-string">&quot;./&quot;</span>;  <span class="hljs-comment">// 指定地址log文件路径，默认是在/tmp/</span><br>google::<span class="hljs-constructor">InitGoogleLogging(<span class="hljs-params">argv</span>[0])</span>;   <span class="hljs-comment">// 设置log文件名称，argv[0].INFO</span><br><br>记录信息：<br><span class="hljs-constructor">LOG(WARNING)</span> &lt;&lt; <span class="hljs-string">&quot;WARNING: this is a test for glog&quot;</span>; <br><span class="hljs-constructor">LOG(INFO)</span> &lt;&lt; <span class="hljs-string">&quot;INFO: this is a test for glog&quot;</span>;<br></code></pre></td></tr></table></figure><p>还有更高阶用法：<a href="https://rpg.ifi.uzh.ch/docs/glog.html">https://rpg.ifi.uzh.ch/docs/glog.html</a></p><p><a href="https://my.oschina.net/u/4320185/blog/3755592">https://my.oschina.net/u/4320185/blog/3755592</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>glog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFLAG_usage</title>
    <link href="/2023/02/14/GFLAG-usage/"/>
    <url>/2023/02/14/GFLAG-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="GFLAG使用记录"><a href="#GFLAG使用记录" class="headerlink" title="GFLAG使用记录"></a>GFLAG使用记录</h3><p>在main()中调用gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true) 解析传入GFLAGS_xxx，在运行bin文件的时候，可以选择用命令传入flags参数，或者将参数放在一个文本文件中</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gflags/gflags.h&quot;</span></span><br><span class="hljs-built_in">DEFINE_string</span>(local_ip, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;genenral local ip&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>    gflags::<span class="hljs-built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 解析GFLAS_XX </span><br>    std::cout &lt;&lt; FLAGS_local_ip &lt;&lt; std::endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>g++ main.cpp 生成a.out可执行文件后，<br>命令行传入FLAGS_local_ip:<br><code>./a.out --local_ip=127.0.0.2</code></p><p>文本文件传入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> flags.txt<br>--local_ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>.&#x2F;a.out –flagfile&#x3D;.&#x2F;flags.txt</p><p>如果不设置local_ip参数，默认打印 127.0.0.1；设置locol_ip参数后打印 127.0.0.2</p><p><strong>Note</strong>:</p><p>define有且只能出现一次，所以当头文件会被多个文件包含时，一定不能定义在头文件中<br>因此，DEFINE在cpp中，DECLARE在头文件中，若只想被一个.cpp文件使用，则只定义在此.cpp文件中而不在.h文件中声明</p>]]></content>
    
    
    
    <tags>
      
      <tag>gflag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bazel_usage</title>
    <link href="/2023/02/13/bazel-usage/"/>
    <url>/2023/02/13/bazel-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="bazel安装"><a href="#bazel安装" class="headerlink" title="bazel安装"></a>bazel安装</h3><p>官方教程：<a href="https://bazel.build/install/ubuntu?hl=zh-cn">https://bazel.build/install/ubuntu?hl=zh-cn</a></p><h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><p><a href="https://bazel.build/start/cpp?hl=zh-cn">https://bazel.build/start/cpp?hl=zh-cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>bazel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orin_env</title>
    <link href="/2023/02/13/orin-env/"/>
    <url>/2023/02/13/orin-env/</url>
    
    <content type="html"><![CDATA[<h3 id="jetpack-sdk-安装"><a href="#jetpack-sdk-安装" class="headerlink" title="jetpack sdk 安装"></a>jetpack sdk 安装</h3><h4 id="确认nvidia-apt资源列表"><a href="#确认nvidia-apt资源列表" class="headerlink" title="确认nvidia apt资源列表"></a>确认nvidia apt资源列表</h4><p>cat &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-l4t-apt-source.list  </p><p>确认是否为 </p><p>deb <a href="https://repo.download.nvidia.com/jetson/common">https://repo.download.nvidia.com/jetson/common</a> r35.1 main </p><p>deb <a href="https://repo.download.nvidia.com/jetson/t234">https://repo.download.nvidia.com/jetson/t234</a> r35.1 main</p><h4 id="校正时间和时区"><a href="#校正时间和时区" class="headerlink" title="校正时间和时区"></a>校正时间和时区</h4><p>修改系统时间和时区 </p><p>系统时间不准确，可能无法连网、获取nvidia 安装包索引</p><h4 id="安装jetpack5-0-2"><a href="#安装jetpack5-0-2" class="headerlink" title="安装jetpack5.0.2"></a>安装jetpack5.0.2</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">dist-upgrade</span><br><span class="hljs-keyword"></span>sudo reboot<br>sudo apt-<span class="hljs-keyword">cache </span><span class="hljs-keyword">show </span>nvidia-<span class="hljs-keyword">jetpack </span>查看<span class="hljs-keyword">jetpack </span>sdk 版本，确认为<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br>sudo apt <span class="hljs-keyword">install </span>nvidia-<span class="hljs-keyword">jetpack</span><br><span class="hljs-keyword"></span>````<br><br><span class="hljs-comment">#### 查看cuda、cudnn、tensorrt 版本</span><br></code></pre></td></tr></table></figure><p>cat &#x2F;usr&#x2F;loca&#x2F;cuda&#x2F;version.json<br>    cuda 11.4.14<br>cat &#x2F;usr&#x2F;include&#x2F;aarch64-linux-gnu&#x2F;cudnn_version_v8.h<br>    cudnn 8.4.1<br>cat &#x2F;usr&#x2F;include&#x2F;aarch64-linux-gnu&#x2F;NvInferVersion.h<br>    tensorrt 8.4.1.5</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 安装jtop<br></code></pre></td></tr></table></figure><p>sudo apt install python3-pip<br>sudo -H pip3 install -U jetson-stats<br>sudo jtop 验证是否可用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 开启最大性能<br></code></pre></td></tr></table></figure><p>sudo nvpmodel -m 0 &amp;&amp; sudo jetson_clocks<br>sudo jetson_clocks –fan<br>jtop 查看 NV Power[0] 是否为MAXN<br>重启后失效</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### wget 报错<br></code></pre></td></tr></table></figure><p>–2018-10-01 12:11:19–  <a href="https://url/">https://url</a><br>Connecting to #:443… connected.<br>OpenSSL: error:14082174:SSL routines:ssl3_check_cert_and_algorithm:dh key too small<br>Unable to establish SSL connection.</p><div class="code-wrapper"><pre><code class="hljs">Here&#39;s a simple workaround for wget: use wget --cipher &#39;DEFAULT:!DH&#39; in place of wget.https://stackoverflow.com/questions/52588948/problem-with-wget-command-ssl3-check-cert#### 终端重复打印 Message xxx终端报Message from syslogd kernel:unregister_netdevice: waiting for eth0 to become freehttps://blog.51cto.com/xiao987334176/1910715没有找到链接里说的     #*.emerg       16 # provides UDP syslog reception                                           17 #module(load=&quot;imudp&quot;)       18 #input(type=&quot;imudp&quot; port=&quot;514&quot;)             19                          20 # provides TCP syslog reception                                                                 21 #module(load=&quot;imtcp&quot;)                                                                                        22 #input(type=&quot;imtcp&quot; port=&quot;514&quot;)                                                              23                                                  24 # provides kernel logging support and enable non-kernel klog messages                                           25 #module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)   把25行注释掉  重启rsyslog服务/etc/init.d/rsyslog restart</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>orin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug_record</title>
    <link href="/2023/02/13/bug-record/"/>
    <url>/2023/02/13/bug-record/</url>
    
    <content type="html"><![CDATA[<h3 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h3><h3 id="linux-环境问题"><a href="#linux-环境问题" class="headerlink" title="linux 环境问题"></a>linux 环境问题</h3><p>问题描述：</p><p>程序有许多printf 时，使用管道符或重定向到文件均比直接打印到标准输出的性能要好</p><p>原因: <a href="https://www.cnblogs.com/lhfcws/p/3197735.html">https://www.cnblogs.com/lhfcws/p/3197735.html</a></p><p>Console 会给多个进程共享，因此对console操作时会存在进程同步和缓存问题。</p><p>ssh远程连接没有该问题，只有在本地运行才有</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++和shell脚本的输入参数设置</title>
    <link href="/2022/11/21/cpp-shell-input-args/"/>
    <url>/2022/11/21/cpp-shell-input-args/</url>
    
    <content type="html"><![CDATA[<h2 id="C-可执行文件输入参数"><a href="#C-可执行文件输入参数" class="headerlink" title="C++ 可执行文件输入参数"></a>C++ 可执行文件输入参数</h2><h3 id="1-getopt-long-函数"><a href="#1-getopt-long-函数" class="headerlink" title="1. getopt_long()函数"></a>1. getopt_long()函数</h3><p>使用手册： <a href="https://linux.die.net/man/3/getopt_long">https://linux.die.net/man/3/getopt_long</a></p><h3 id="2-设置参数选项"><a href="#2-设置参数选项" class="headerlink" title="2. 设置参数选项"></a>2. 设置参数选项</h3><p>参数选项的形式可以分为两种，一是 -n, 二是 –name</p><p>-n 这种需要设置短选项字符串；–name 这种需要设置长选项结构体。</p><h4 id="2-1-段选项字符串"><a href="#2-1-段选项字符串" class="headerlink" title="2.1 段选项字符串"></a>2.1 段选项字符串</h4><p>书写规则：</p><ul><li>多个短选项可以连在一起</li><li>如果某个要解析的选项需要一个参数，则在选项名后面跟一个冒号</li><li>如果某个要解析的选项的参数可选，则在选项名后面跟两个冒号</li></ul><p>一般如这种形式:<br>    <code>const char* short_options = &quot;hx:t:c:&quot;</code><br>该字符串解释为： </p><div class="code-wrapper"><pre><code class="hljs">-h -t t_arg-c c_arg</code></pre></div><p>细心的话为发现多了h后面还有一个x:没有被说明，因为h(help)后面不需要接参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* short_options = <span class="hljs-string">&quot;hx:n:h:&quot;</span>;    <span class="hljs-comment">// 带参数的，要使用的命令，需要在这里声明</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">option</span> long_options[] = &#123;<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;,<br>        &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg-usage</title>
    <link href="/2022/09/02/ffmpeg-usage/"/>
    <url>/2022/09/02/ffmpeg-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="ffmpeg-命令行"><a href="#ffmpeg-命令行" class="headerlink" title="ffmpeg 命令行"></a>ffmpeg 命令行</h3><p><code>ffplay -f rawvideo -pixel_format bgr24 -video_size 1280x1280 -framerate 10 video_cuda_1.rgb</code><br>播放rgb格式的视频</p><p><code>ffplay -f h264 -width 1920 -height 1080 record_424_sensor_ipcamera_h264_10_128_156_101.h264</code><br>播放 h264格式的视频</p><p><code>ffmpeg -i Free_Test_Data_15MB_MP4.h264 -framerate 30 -vcodec copy -f mp4 output.mp4</code><br>转码 h264 &#x3D;&gt; mp4<br><code>ffmpeg -i Free_Test_Data_15MB_MP4.mp4 -vcodec libx264 -acodec aac Free_Test_Data_15MB_MP4.264 </code><br>转码 mp4 &#x3D;&gt; h264</p>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>performace-test</title>
    <link href="/2022/08/30/performace-test/"/>
    <url>/2022/08/30/performace-test/</url>
    
    <content type="html"><![CDATA[<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><h4 id="perf-安装"><a href="#perf-安装" class="headerlink" title="perf 安装"></a>perf 安装</h4><p><a href="https://xiaoyanzhuo.github.io/2019/01/18/Perf-Tool.html">https://xiaoyanzhuo.github.io/2019/01/18/Perf-Tool.html</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> update<br><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> install linux-tools-common linux-tools-generic linux-tools-`uname -r`<br></code></pre></td></tr></table></figure><h4 id="orin上安装"><a href="#orin上安装" class="headerlink" title="orin上安装"></a>orin上安装</h4><p>下载 JP-x.x.x Driver Package Sources:<br><a href="https://developer.nvidia.com/embedded/l4t/r35_release_v1.0/sources/public_sources.tbz2">https://developer.nvidia.com/embedded/l4t/r35_release_v1.0/sources/public_sources.tbz2</a></p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">复制压缩包到orin<br><span class="hljs-built_in">cd</span>到 kernel/kernel-4.9/tools/perf<br>make<br>./perf --version<br></code></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>基础教程：<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/common-perf-commands_getting-started-with-perf">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/common-perf-commands_getting-started-with-perf</a></p><p>用 perf 监控相关指标，生成报告，然后可以将报告用 <a href="https://profiler.firefox.com/">https://profiler.firefox.com/</a> 进行查看</p><p>步骤：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>、sudo perf record -e cpu-<span class="hljs-keyword">clock </span>-g -p PID<br><span class="hljs-number">2</span>、perf <span class="hljs-keyword">script </span>-i perf<span class="hljs-meta">.data</span> &amp;&gt; perf.unfold<br></code></pre></td></tr></table></figure><p>然后将 .unfold 文件在 profiler.firefox.com 网站上打开</p><h3 id="nvidia-system"><a href="#nvidia-system" class="headerlink" title="nvidia-system"></a>nvidia-system</h3><p>orin上</p><p>&#x2F;opt&#x2F;nvidia&#x2F;nsight-systems&#x2F;2022.3.3&#x2F;target-linux-tegra-armv8&#x2F;nsys profile -y 60 -d 20 –gpuctxsw&#x3D;true -o out_file mainboard -d .&#x2F;dag&#x2F;test.dag</p><p>程序开始运行60s后,记录20s.然后core dump 生成记录报告out_file</p>]]></content>
    
    
    
    <tags>
      
      <tag>nsight</tag>
      
      <tag>nsys</tag>
      
      <tag>sysbench</tag>
      
      <tag>perf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hhd-ssd-emmc</title>
    <link href="/2022/08/30/hhd-ssd-emmc/"/>
    <url>/2022/08/30/hhd-ssd-emmc/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HDD，即硬盘驱动器（HardDiskDrive），一般指机械硬盘；多层盘，每层一个磁头<br>SSD，即固态硬盘（Solid State Drives）；<br>EMMC，(Embedded Multi Media Card) 一种内嵌式存储器标准规格；<br>NAND，即Nand-flash，闪存的一种。<br>SSD 和 EMMC 都是基于NAND 的</p><h3 id="ssd-为什么越写越慢-（磁盘空间快慢时变慢）"><a href="#ssd-为什么越写越慢-（磁盘空间快慢时变慢）" class="headerlink" title="ssd 为什么越写越慢?（磁盘空间快慢时变慢）"></a>ssd 为什么越写越慢?（磁盘空间快慢时变慢）</h3><p><a href="http://www.ssdfans.com/?p=90902">http://www.ssdfans.com/?p=90902</a><br>因为垃圾回收机制</p><h3 id="hhd为什么随机读写很慢"><a href="#hhd为什么随机读写很慢" class="headerlink" title="hhd为什么随机读写很慢"></a>hhd为什么随机读写很慢</h3><p><a href="https://zhuanlan.zhihu.com/p/20085866">https://zhuanlan.zhihu.com/p/20085866</a><br>因为磁头要来来回回移动</p><h3 id="ssd的分类"><a href="#ssd的分类" class="headerlink" title="ssd的分类"></a>ssd的分类</h3><p><a href="https://www.kingston.com.cn/cn/community/articledetail/articleid/48543">https://www.kingston.com.cn/cn/community/articledetail/articleid/48543</a><br>SSD 技术：NVMe、SATA、M.2<br>NVMe (Non-Volatile Memory Express) 是一种通信接口和驱动程序，为基于 PCIe 的 SSD 定义了命令集和功能集<br>PICe（NVMe） 比 SATA 更快</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssd</tag>
      
      <tag>emmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-pip</title>
    <link href="/2022/08/28/python-pip/"/>
    <url>/2022/08/28/python-pip/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有条件直接使用 conda的虚拟环境</p><h3 id="miniconda"><a href="#miniconda" class="headerlink" title="miniconda"></a>miniconda</h3><p>安装miniconda：<a href="https://www.jianshu.com/p/992cadf45994">https://www.jianshu.com/p/992cadf45994</a></p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> env list  查看已有的python 环境<br><span class="hljs-attribute">conda</span> create --name py36 python=<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> 指定 Python 版本创建虚拟环境<br><span class="hljs-attribute">conda</span> activate py36   激活 py36 的虚拟环境<br></code></pre></td></tr></table></figure><h3 id="python2安装pip"><a href="#python2安装pip" class="headerlink" title="python2安装pip"></a>python2安装pip</h3><p>wget <a href="https://bootstrap.pypa.io/pip/2.7/get-pip.py">https://bootstrap.pypa.io/pip/2.7/get-pip.py</a><br>下载成功后执行 python2 get-pip.py</p><p>指定python 安装numpy库：<br>python2 -m pip install numpy</p><h3 id="python3安装-pip"><a href="#python3安装-pip" class="headerlink" title="python3安装 pip"></a>python3安装 pip</h3><p>apt install python3-pip</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc 的标准库和头文件</title>
    <link href="/2022/07/19/gcc-so-include/"/>
    <url>/2022/07/19/gcc-so-include/</url>
    
    <content type="html"><![CDATA[<h3 id="libgcc-s-so-1是什么"><a href="#libgcc-s-so-1是什么" class="headerlink" title="libgcc_s.so.1是什么"></a>libgcc_s.so.1是什么</h3><p><a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">The GCC low-level runtime library</a></p><p>会在有需要的时候自动启动的C 运行时库，可以替代某些机器完成整数、浮点运算，还有一些其他的功能。</p><h3 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h3><p>应用程序和操作系统之间的桥梁，对操作系统硬件的抽象，包括对IO 操作、程序启动和程序退出、栈等的实现。不同的操作系统对应不同的运行时库，但提供的接口基本一致，比如windows 和linux 的运行时库，都提供fread 功能，但是其实现应该是不一样的，fread 就包括在运行时库中。</p><h3 id="编译参数顺序"><a href="#编译参数顺序" class="headerlink" title="编译参数顺序"></a>编译参数顺序</h3><p>LINKFLAGS_AFTER_LIBS(False)决定cxxflags、ldflags（编译参数和链接参数）是放在库前还是库后，对cmake 和bcloud 而言有用，对gcc 而言没有所谓这些参数之分，都是编译参数，链接的库名也都是编译参数，但是编译参数之间的顺序可能会影响能否编译成功</p><h3 id="libc-so"><a href="#libc-so" class="headerlink" title="libc.so"></a>libc.so</h3><p>&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;libc.so 是个链接脚本，表示在链接时去链哪个库，可以根据需要选择动态库还是静态库</p><h3 id="符号集版本"><a href="#符号集版本" class="headerlink" title="符号集版本"></a>符号集版本</h3><p><a href="mailto:&#x66;&#117;&#110;&#x63;&#64;&#71;&#76;&#73;&#66;&#x43;&#x5f;&#x32;&#x2e;&#x33;&#49;">&#x66;&#117;&#110;&#x63;&#64;&#71;&#76;&#73;&#66;&#x43;&#x5f;&#x32;&#x2e;&#x33;&#49;</a> </p><p>GLIBC_2.31表示符号集版本，向下兼容，即如果需要<a href="mailto:&#x66;&#117;&#x6e;&#x63;&#x40;&#71;&#x4c;&#73;&#66;&#67;&#95;&#50;&#46;&#x32;&#x39;">&#x66;&#117;&#x6e;&#x63;&#x40;&#71;&#x4c;&#73;&#66;&#67;&#95;&#50;&#46;&#x32;&#x39;</a>时也没问题</p><h3 id="强符号和若符号"><a href="#强符号和若符号" class="headerlink" title="强符号和若符号"></a>强符号和若符号</h3><p>符号表中的 STRONG 和 WEAK</p><p>强符号：全局且初始化的参数和默认的函数，都属于强符号，强符号全局只能唯一，找不到直接报 undefined  reference</p><p>弱符号：全局且未初始化的参数，也可以在代码中来指定。弱符号在链接时候找不到可以暂时用0地址代替，链接时不会报 undefined，作为插件接口或用户自定义接口使用更加方便。</p><h3 id="gcc-安装"><a href="#gcc-安装" class="headerlink" title="gcc 安装"></a>gcc 安装</h3><p><a href="https://wenku.baidu.com/view/b73c43055a0102020740be1e650e52ea5418ce77.html?_wkts_=1676342805235">https://wenku.baidu.com/view/b73c43055a0102020740be1e650e52ea5418ce77.html?_wkts_=1676342805235</a></p><p>wget <a href="https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.5.0">https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.5.0</a></p><p>Note: gcc 安装后 c 和 c++ 的标准库还是原来的版本</p><h3 id="添加系统头文件搜索路径"><a href="#添加系统头文件搜索路径" class="headerlink" title="添加系统头文件搜索路径"></a>添加系统头文件搜索路径</h3><p><a href="https://blog.csdn.net/yjk13703623757/article/details/83154578">https://blog.csdn.net/yjk13703623757/article/details/83154578</a></p><p>gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）</p><h3 id="gcc-低版本问题"><a href="#gcc-低版本问题" class="headerlink" title="gcc 低版本问题"></a>gcc 低版本问题</h3><p> gcc4 gcc5 不支持直接使用enum 作为map 的键指，需要自己指定hash 方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>so</tag>
      
      <tag>include</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-usage</title>
    <link href="/2022/07/14/docker-usage/"/>
    <url>/2022/07/14/docker-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="docker-用法"><a href="#docker-用法" class="headerlink" title="docker 用法"></a>docker 用法</h3><p>docker教程： <a href="https://yeasy.gitbook.io/docker_practice/image/build">https://yeasy.gitbook.io/docker_practice/image/build</a>   </p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>初次运行<br><code>docker run -itd image-id bash </code><br>&#x2F;&#x2F;i 交互 t 终端 d 运行但不关闭，不进入docker</p><p><code>docker exec -it conatainer-id bash</code><br>&#x2F;&#x2F; 进入docker,退出不关闭</p><p><code>docker run -id image-id bash</code><br>&#x2F;&#x2F; 进入docker，退出关闭</p><h3 id="删除镜像和容器"><a href="#删除镜像和容器" class="headerlink" title="删除镜像和容器"></a>删除镜像和容器</h3><p><a href="https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/">https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/</a></p><p><code>docker stop container-id</code><br>&#x2F;&#x2F; 关闭容器<br><code>docker rm container-id</code><br>&#x2F;&#x2F; 删除容器<br><code>docker rmi image-id</code><br>&#x2F;&#x2F; 删除镜像<br><code>docker stop $(docker ps -a -q)</code><br>&#x2F;&#x2F; 停止所有容器运行<br><code>docker rm $(docker ps -a -q)</code><br>&#x2F;&#x2F; 删除所有容器</p><h3 id="根据Dockerfile制作镜像"><a href="#根据Dockerfile制作镜像" class="headerlink" title="根据Dockerfile制作镜像"></a>根据Dockerfile制作镜像</h3><p><code>docker buildx build -t hansanf/cuda-11.1:11.1.1-devel-cudnn-ubuntu18.04 --platform=x86_64  . --push</code><br>&#x2F;&#x2F; buildx是制作多架构工具，可以不用<br>&#x2F;&#x2F; -t tag, [仓库名]:[镜像tag]<br>&#x2F;&#x2F; –platform buildx要制作的哪个平台的镜像<br>&#x2F;&#x2F; . Dockerfile的路径<br>&#x2F;&#x2F; –push 制作的镜像push到远程仓库，不会保留在本地，可以用 -o type&#x3D;docker 替换</p><h3 id="pull和push"><a href="#pull和push" class="headerlink" title="pull和push"></a>pull和push</h3><p><code>docker pull [仓库名]:[tag]</code>  </p><p><code>docker push [仓库名]:[tag]</code></p><h3 id="关闭、打开和重启docker"><a href="#关闭、打开和重启docker" class="headerlink" title="关闭、打开和重启docker"></a>关闭、打开和重启docker</h3><p>启动<br><code>sudo systemctl start docker</code><br>关闭<br><code>sudo  service docker stop</code> </p><p>重启</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">sudo systemctl daemon-reload<span class="hljs-comment">;</span><br>sudo systemctl restart  docker<span class="hljs-comment">;</span><br>sudo sudo service docker restart<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="容器内进行可视化"><a href="#容器内进行可视化" class="headerlink" title="容器内进行可视化"></a>容器内进行可视化</h3><p>设置 DISPLAY 环境变量，令 docker 内外一致, 比如均设置为 :1</p><p>冒号不能少</p><p>启动容器的时候加上：<br>-e DISPLAY&#x3D;$DISPLAY -v &#x2F;tmp&#x2F;.X11-unix&#x2F;:&#x2F;tmp&#x2F;.X11-unix</p><h3 id="跨平台构建-Docker-镜像"><a href="#跨平台构建-Docker-镜像" class="headerlink" title="跨平台构建 Docker 镜像"></a>跨平台构建 Docker 镜像</h3><p>结论：在不使用nvidia的情况下，在开发机x86架构上构建arm64的docker镜像，在该镜像中进行开发，可以直接把程序移植到的arm盒子中运行</p><h4 id="跨-CPU-架构编译程序的方法："><a href="#跨-CPU-架构编译程序的方法：" class="headerlink" title="跨 CPU 架构编译程序的方法："></a>跨 CPU 架构编译程序的方法：</h4><h5 id="方法一：直接在目标硬件上编译"><a href="#方法一：直接在目标硬件上编译" class="headerlink" title="方法一：直接在目标硬件上编译"></a>方法一：直接在目标硬件上编译</h5><p>缺点：需每个人都直接操作目标硬件，在硬件资源不充足的情况下开发效率低。</p><h5 id="方法二：模拟目标硬件"><a href="#方法二：模拟目标硬件" class="headerlink" title="方法二：模拟目标硬件"></a>方法二：模拟目标硬件</h5><p>通过QEMU（quick emulator）模拟一个完整的操作系统，创建出通用的 ARM 虚拟机，该虚拟机可以引导 Linux，设置开发环境，也可以在虚拟机内编译程序。</p><p>缺点：模拟整个系统，包括计时器、内存控制器、总线控制器等硬件，但编译程序不需要这些硬件。</p><h5 id="方法三：使用交叉编译器"><a href="#方法三：使用交叉编译器" class="headerlink" title="方法三：使用交叉编译器"></a>方法三：使用交叉编译器</h5><p>类似于方法一，只不过将编译过程放在开发机</p><h5 id="方法四：模拟目标硬件的用户空间"><a href="#方法四：模拟目标硬件的用户空间" class="headerlink" title="方法四：模拟目标硬件的用户空间"></a>方法四：模拟目标硬件的用户空间</h5><p>QEMU 将通过binfmt_misc（Miscellaneous Binary Format）在 Linux 内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标 CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标 CPU 架构的二进制文件。</p><h5 id="跨平台构建docker就是方法四的演化"><a href="#跨平台构建docker就是方法四的演化" class="headerlink" title="跨平台构建docker就是方法四的演化"></a>跨平台构建docker就是方法四的演化</h5><p>背景：<br>目前手上ARM盒子只有一个，资源有限；<br>ARM盒子中，程序最终跑在docker里。</p><p>目标：<br>以软件模拟的方式，实现开发机中使用ARM架构下的docker，使开发机中的docker环境和ARM盒子中的一样，从而在开发机中就可以进行移植。</p><p><img src="https://img-blog.csdnimg.cn/c39c902beb63427bb54f878b856fb08a.png" alt="在这里插入图片描述"></p><h5 id="实现路线："><a href="#实现路线：" class="headerlink" title="实现路线："></a>实现路线：</h5><p>使用 buildx 命令(使用 BuildKit实现的)构建多种系统架构支持的 Docker 镜像<br>BuildKit：镜像构建组件</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs tcl">（<span class="hljs-number">1</span>）启动buildx插件<br>$ export DOCKER_CLI_EXPERIMENTAL=enabled<br>验证是否开启<br>$ docker buildx version<br>github.com/docker/buildx v0<span class="hljs-number">.3</span><span class="hljs-number">.1</span>-tp-docker <span class="hljs-number">6</span>db68d029599c6710a32aa7adcba8e5a344795a7<br><br>（<span class="hljs-number">2</span>）启动binfmt_misc<br>$ docker run --rm --privileged tonistiigi/binfmt:latest --install all<br>验证是 binfmt_misc 否开启：<br>$ ls -al /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/<br>总用量 0<br>总用量 0<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-aarch64</span>   // 支持arrch64架构<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-arm</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-ppc64le</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-s390x</span><br>--w------- 1<span class="hljs-title"> root</span> root 0 11月 18 00:09<span class="hljs-title"> register</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> status</span><br>验证是否启用了arrch64处理器：<br>$<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">enabled</span><br>interpreter /usr/bin/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">flags:</span> OCF<span class="hljs-title"></span><br><span class="hljs-title">offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">magic</span> 7f454c460201010000000000000000000200b7<span class="hljs-title"></span><br><span class="hljs-title">mask</span> ffffffffffffff00fffffffffffffffffeffff<br><br>(3)新建<span class="hljs-title"> builder</span> 实例<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> create</span> --use --name=mybuilder-cn --driver<span class="hljs-title"> docker-container</span> --driver-opt<span class="hljs-title"> image=dockerpracticesig/buildkit:master</span><br>启动构建器<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> inspect</span> mybuilder --bootstrap<br>[+]<span class="hljs-title"> Building</span> 5.0s (1/1)<span class="hljs-title"> FINISHED</span><br> =&gt; [internal]<span class="hljs-title"> booting</span> buildkit                                                                                                                          5.0s<br> =&gt; =&gt;<span class="hljs-title"> pulling</span> image<span class="hljs-title"> moby/buildkit:buildx-stable-1</span>                                                                                                       4.4s<br> =&gt; =&gt;<span class="hljs-title"> creating</span> container<span class="hljs-title"> buildx_buildkit_mybuilder0</span>                                                                                                     0.6s<span class="hljs-title"></span><br><span class="hljs-title">Name:</span> <span class="hljs-title">  mybuilder</span><br>Driver:<span class="hljs-title"> docker-container</span><br><span class="hljs-title"></span><br><span class="hljs-title">Nodes:</span><br>Name:<span class="hljs-title">      mybuilder0</span><br>Endpoint:<span class="hljs-title">  unix:///var/run/docker.sock</span><br>Status:<span class="hljs-title">    running</span><br>Platforms:<span class="hljs-title"> linux/amd64,</span> linux/arm64,<span class="hljs-title"> linux/ppc64le,</span> linux/s390x,<span class="hljs-title"> linux/386,</span> linux/arm/v7,<span class="hljs-title"> linux/arm/v6</span><br><br>(4）新建<span class="hljs-title"> Dockerfile</span> 文件<span class="hljs-title"></span><br><span class="hljs-title">FROM</span> --platform=$TARGETPLATFORM<span class="hljs-title"> alpine</span><br><span class="hljs-title"></span><br><span class="hljs-title">RUN</span> uname -a &gt; /os.txt<span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">CMD</span> cat /os.txt<br><br>(5)本地创建镜像<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> build</span> -t<span class="hljs-title"> hello-arch-arm64</span> --platform=linux/arm64 -o<span class="hljs-title"> type=docker</span> .<br></code></pre></td></tr></table></figure><p>其他知识补充：</p><p>Qemu（quick emulator）是一个开源的托管虚拟机，通过纯软件来实现虚拟化模拟器，几乎可以模拟任何硬件设备。比如：Qemu可以模拟出一个ARM系统中的：CPU、内存、IO设备等，然后在这个模拟层之上，可以跑一台 ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。Qemu是使用纯软件模拟的，它的强项是模拟那些不涉及到外部的具体硬件设备的场景。因为QEMU是纯软件实现的，所有的指令都要经过QEMU，使得性能很差，而配合KVM则可以解决这一问题。</p><p>参考资料<br><a href="https://cloud.tencent.com/developer/article/1543689">https://cloud.tencent.com/developer/article/1543689</a><br><a href="https://yeasy.gitbook.io/docker_practice/buildx/multi-arch-images">https://yeasy.gitbook.io/docker_practice/buildx/multi-arch-images</a><br><a href="https://www.cnblogs.com/sewain/p/14206365.html">https://www.cnblogs.com/sewain/p/14206365.html</a></p><h3 id="ERRORS"><a href="#ERRORS" class="headerlink" title="ERRORS"></a>ERRORS</h3><p>error-1<br>W: GPG error: <a href="https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.<br>W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease: At least one invalid signature was encountered.<br>E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease’ is not signed.<br>N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br>N: See apt-secure(8) manpage for repository creation and user configuration details.</p><p>硬盘空间不足了</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc-options</title>
    <link href="/2022/07/14/gcc-options/"/>
    <url>/2022/07/14/gcc-options/</url>
    
    <content type="html"><![CDATA[<h3 id="gcc-的编译选项"><a href="#gcc-的编译选项" class="headerlink" title="gcc 的编译选项"></a>gcc 的编译选项</h3><p>gcc官方手册：<a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a></p><p>7.5手册：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options</a></p><p>链接选项：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options</a></p><h4 id="fPIC-和-fPIE"><a href="#fPIC-和-fPIE" class="headerlink" title="-fPIC 和-fPIE"></a>-fPIC 和-fPIE</h4><p>-fPIC 用在动态库的编译，产生位置无关的代码</p><p>-fPIE 用在可执行程序的编译</p><p>两者在效果上一样，都是把代码中的逻辑地址转为相对地址，但是作用上不一样。<br>-fPIC一般是动态库编译必须设置的，因为可能在链接时，多个模块之间的重定向可能会出现冲突。而-fPIE在可执行程序的编译中可加可不加，其将绝对地址转为相对地址，在一定程度上提高了安全性，另外相对寻址的方式可能会让程序在启动速度慢一点。</p><p>PIE 详解：<a href="https://www.redhat.com/en/blog/position-independent-executables-pie">https://www.redhat.com/en/blog/position-independent-executables-pie</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const_cast用法</title>
    <link href="/2022/07/11/cpp-const-cast/"/>
    <url>/2022/07/11/cpp-const-cast/</url>
    
    <content type="html"><![CDATA[<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>const_cast&lt;&gt;  &lt;&gt;必须是指针或引用</p><h2 id="const-std-shared-ptr去-const"><a href="#const-std-shared-ptr去-const" class="headerlink" title="const std::shared_ptr去 const"></a>const std::shared_ptr<const class_nam>去 const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; <span class="hljs-title">const_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(const_ptr).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//ptr-&gt;x = 100; //error</span><br>        <span class="hljs-comment">//std::shared_ptr&lt;A&gt; ptr = const_cast&lt;std::shared_ptr&lt;A&gt;&gt;(const_ptr);  //error</span><br>        std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; ptr = <span class="hljs-keyword">const_cast</span>&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; &amp;&gt;(const_ptr); <span class="hljs-comment">//必须是const_cast&lt;&amp;&gt; 必须加引用</span><br><br>        A &amp;a = <span class="hljs-built_in">const_cast</span>&lt;A &amp;&gt;(*const_ptr); <span class="hljs-comment">// const_cast&lt;&amp;&gt; 必须加引用</span><br>        a.x = <span class="hljs-number">100</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a.x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;const_ptr-&gt;x = &quot;</span> &lt;&lt; const_ptr-&gt;x &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp_mutable</title>
    <link href="/2022/07/06/cpp-mutable/"/>
    <url>/2022/07/06/cpp-mutable/</url>
    
    <content type="html"><![CDATA[<h3 id="mutable-关键字"><a href="#mutable-关键字" class="headerlink" title="mutable 关键字"></a>mutable 关键字</h3><p><a href="https://www.jianshu.com/p/b2883dbf3854">mutabel 介绍</a></p><h4 id="为什么std-mutex-前通常用mutable-修饰"><a href="#为什么std-mutex-前通常用mutable-修饰" class="headerlink" title="为什么std::mutex 前通常用mutable 修饰"></a>为什么std::mutex 前通常用mutable 修饰</h4><p>在const成员函数中，对mutex的加锁和释放锁操作会违背const的不可变语义，所以，只能将mutex定义为mutable，从而可以在const修饰的函数中加锁，实现线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cal</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Cal</span>(<span class="hljs-type">int</span> n) &#123;num = n;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc_num</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        ++num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">//const m 状态的改变会修改const 语义，但不报错？</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">mutable</span> std::mutex m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Cal c&#123;<span class="hljs-number">0</span>&#125;;<br>    std::cout &lt;&lt; c.<span class="hljs-built_in">get_num</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_debug_tools</title>
    <link href="/2022/07/05/debug-tools/"/>
    <url>/2022/07/05/debug-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="C-Debug命令和工具"><a href="#C-Debug命令和工具" class="headerlink" title="C++ Debug命令和工具"></a>C++ Debug命令和工具</h2><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>查看可执行文件或库的符号表</p><figure class="highlight ada"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ada">readelf -s ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>查看可执行文件或库的动态库表</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">readelf -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>查看汇编情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h3><p>查看动态库的链接情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ldd ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h3><p>在执行该文件前预加载库，要加具体的库名，LD_PRELOAD的值只在当前语句生效</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">env LD_PRELOAD=<span class="hljs-regexp">/home/</span>fenggq<span class="hljs-regexp">/libutil.so ./</span>a.out<br></code></pre></td></tr></table></figure><h3 id="查看系统默认链接的库路径"><a href="#查看系统默认链接的库路径" class="headerlink" title="查看系统默认链接的库路径"></a>查看系统默认链接的库路径</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br>    # output: include /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br>    # output: 所有的默认库路径<br></code></pre></td></tr></table></figure><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>使用gdb调试带输入参数的程序</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gdb --<span class="hljs-keyword">args</span> ./a.<span class="hljs-keyword">out</span> <span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure><h3 id="file查看文件属性"><a href="#file查看文件属性" class="headerlink" title="file查看文件属性"></a>file查看文件属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file msf<br>msf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped<br></code></pre></td></tr></table></figure><p>该文件被stripped ，去除掉了符号表信息</p><h3 id="strip-命令"><a href="#strip-命令" class="headerlink" title="strip 命令"></a>strip 命令</h3><p>去掉符号表和调试等信息<br><a href="https://blog.51cto.com/u_15614325/5272498">https://blog.51cto.com/u_15614325&#x2F;5272498</a></p><p>符号表和strip <a href="https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/">https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/</a></p><p>tmp_LD_PRELOAD&#x3D;${LD_PRELOAD}<br>unset LD_PRELOAD<br>nohup cyber_launch start fusion_tracker.launch &amp;<br>export LD_PRELOAD&#x3D;${tmp_LD_PRELOAD}</p><h3 id="core文件去哪了"><a href="#core文件去哪了" class="headerlink" title="core文件去哪了"></a>core文件去哪了</h3><p><a href="https://www.jianshu.com/p/7317910210a4">core文件去哪了</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_trick</title>
    <link href="/2022/06/29/vscode-trick/"/>
    <url>/2022/06/29/vscode-trick/</url>
    
    <content type="html"><![CDATA[<h3 id="vscode-中好用的工具和小技巧"><a href="#vscode-中好用的工具和小技巧" class="headerlink" title="vscode 中好用的工具和小技巧"></a>vscode 中好用的工具和小技巧</h3><p>1、code 命令启动vscode</p><p>开启方式的 ctrl+shift+p  输入code，选择 install<br>不好用的时候，uninstall 再 install 一遍</p><p><code>code [path]</code></p><p><a href="https://blog.csdn.net/weixin_42881768/article/details/119635248">https://blog.csdn.net/weixin_42881768/article/details/119635248</a></p><p>2、语法智能补全插件</p><p><code>tabnine</code></p><p>3、</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yuv2rgb</title>
    <link href="/2022/06/29/yuv2rgb/"/>
    <url>/2022/06/29/yuv2rgb/</url>
    
    <content type="html"><![CDATA[<h1 id="YUV详解"><a href="#YUV详解" class="headerlink" title="YUV详解"></a>YUV详解</h1><h3 id="YUV分类"><a href="#YUV分类" class="headerlink" title="YUV分类"></a>YUV分类</h3><h5 id="1、按采样方式分类"><a href="#1、按采样方式分类" class="headerlink" title="1、按采样方式分类"></a>1、按采样方式分类</h5><p>   （1） YUV444: 全量UV，类似于RGB，每个像素点都有一套自己的YUV<br><img src="https://img-blog.csdnimg.cn/000b2132c524457583a034fcb2bd787c.png#pic_center" alt="在这里插入图片描述"><br>   （2） YUV422: 50%的UV，与全量相比，UV数量减少一半，每行中由 2 个 Y 分量共用一套 UV 分量。<br><img src="https://img-blog.csdnimg.cn/eea18cfb6599473aab6374a6cc7b1fc2.png#pic_center" alt="在这里插入图片描述"></p><p>（3）YUV420: 25%的UV， UV的数量减少到1&#x2F;4，每行两个Y、每列两个Y，共由 4 个 Y 分量共用一套 UV 分量。<img src="https://img-blog.csdnimg.cn/e01002399f09464e8916f4421fa5e8c0.png#pic_center" alt="在这里插入图片描述"></p><h5 id="2、按内存中排列方式分类"><a href="#2、按内存中排列方式分类" class="headerlink" title="2、按内存中排列方式分类"></a>2、按内存中排列方式分类</h5><p>（1）Planar YUV 三个分量分开存放<br>（2）Semi-Planar Y 分量单独存放，UV 分量交错存放<br>（3）Packed YUV 三个分量全部交错存放</p><p>以YUV420为例：</p><h5 id="3、ffmpeg中h264解码后的YUV格式"><a href="#3、ffmpeg中h264解码后的YUV格式" class="headerlink" title="3、ffmpeg中h264解码后的YUV格式"></a>3、ffmpeg中h264解码后的YUV格式</h5><h3 id="YUV转RGB"><a href="#YUV转RGB" class="headerlink" title="YUV转RGB"></a>YUV转RGB</h3><p>色彩空间：<br>公式：</p><h5 id="ffmpeg接口"><a href="#ffmpeg接口" class="headerlink" title="ffmpeg接口"></a>ffmpeg接口</h5><h5 id="cuda实现"><a href="#cuda实现" class="headerlink" title="cuda实现"></a>cuda实现</h5><p>参考：<br><a href="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a><br><a href="https://cloud.tencent.com/developer/article/1612357">https://cloud.tencent.com/developer/article/1612357</a><br><a href="https://juejin.cn/post/6920848468797816846">https://juejin.cn/post/6920848468797816846</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf</title>
    <link href="/2022/06/29/protobuf/"/>
    <url>/2022/06/29/protobuf/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h2><p>Protocol Buffers(简称Protobuf) ，是Google出品的序列化框架。<br>简单来讲，就是支持序列化与反序列化，用于数据的存储、传输。<br>protobuf将数据接口定义在.proto文件中，然后再利用protoc翻译为所需要的程序语言代码（类似于接口描述语言？）</p><p><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial">官方Guide</a></p><h2 id="怎么用protobuf"><a href="#怎么用protobuf" class="headerlink" title="怎么用protobuf"></a>怎么用protobuf</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>…省略</p><h3 id="C-使用"><a href="#C-使用" class="headerlink" title="C++使用"></a>C++使用</h3><h4 id="数据类型定义"><a href="#数据类型定义" class="headerlink" title="数据类型定义"></a>数据类型定义</h4><p><a href="https://blog.csdn.net/wangchong_fly/article/details/47614699">数据类型对应关系</a></p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>step-1定义.proto</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// demo_msg.proto</span><br>syntax = <span class="hljs-string">&quot;proto2&quot;</span>; <span class="hljs-comment">//版本选择，proto2 or proto3</span><br>package fgq.demo; <span class="hljs-comment">// C++中的namespace,用.分隔</span><br><br>message PersonalInfo &#123;<br>required bytes name = <span class="hljs-number">1</span>;<br>optional bytes address = <span class="hljs-number">2</span>;<br>repeated bytes friends = <span class="hljs-number">3</span>;<br>&#125;;<br><span class="hljs-comment">//等号后面是field number,从1开始计数</span><br><span class="hljs-comment">//C++中字段名不区分大小写，即name和Name，在C++接口中都是name</span><br></code></pre></td></tr></table></figure><p>step-2 将.proto翻译为.cpp和.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc -I= demo_msg.proto的目录 --cpp_out=存放.cpp和.h的目录 demo_msg.proto的路径<br></code></pre></td></tr></table></figure><p>-I参数和gcc的-I参数类似？</p><p>step-3<br>.cpp中引入.pb.h头文件，就可以使用protobuf所提供的cpp接口了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;demo_msg.pb.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">g++ main.cpp -I [--cpp_out所指定的目录]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>atomic</title>
    <link href="/2022/06/29/atomic/"/>
    <url>/2022/06/29/atomic/</url>
    
    <content type="html"><![CDATA[<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>内存模型：指令执行顺序的模型</p><p>现代的处理器基本是并发式处理机器指令的,在一个cpu 时钟 issue 多条指令。</p><p>指令若总是严格按照书写顺序执行的，则称这样的内存模型为强顺序的(strong ordered),按照一定规则允许乱序的，称为弱顺序的(weak ordered)。</p><p>内存模型详细介绍：</p><ul><li><p><a href="https://www.zhihu.com/question/24301047">https://www.zhihu.com/question/24301047</a></p></li><li><p><a href="https://www.zhihu.com/question/24301047">https://zhuanlan.zhihu.com/p/264975254</a></p></li></ul><h3 id="C-atomix-内存顺序"><a href="#C-atomix-内存顺序" class="headerlink" title="C++ atomix 内存顺序"></a>C++ atomix 内存顺序</h3><p>根据允许指令的混乱程度，C++为原子操作指定了内存顺序（memory_order），其包含6种：</p><ul><li>momory_order_relaxed,</li><li>memory_order_consume,</li><li>memory_order_acquire,</li><li>memory_order_release,</li><li>memory_order_acq_rel,</li><li>memory_order_seq_cst.</li></ul><p><img src="https://img-blog.csdnimg.cn/56a139b6a7184bd5af35c4df4610a9aa.png" alt="在这里插入图片描述"></p><p>虽然共有 6 个选项,但它们表示的是三种内存模型: </p><p><strong>sequential consistent</strong>: memory_order_seq_cst</p><p>如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行。相当于所有的线程都用同一份内存，对同一个变量保持时刻可见</p><p><a href="https://www.zhihu.com/question/24301047">使用示例</a></p><p><strong>relaxed</strong>: memory_order_seq_cst</p><p>在同一线程内对同一变量的操作仍保持happens-before关系，但这与别的线程无关。 在 relaxed ordering 中唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排。</p><p><strong>acquire release</strong>: memory_order_consume, memory_order_acquire,<br>memory_order_release, memory_order_acq_rel</p><p>在这种序列模型下,原子 load 操作是 acquire 操作(memory_order_acquire), 原子 store 操作是release操作(memory_order_release).</p><p>原子read_modify_write操作(如fetch_add(), exchange())可以是 acquire, release 或两者皆是(memory_order_acq_rel). </p><p>同步是成对出现的,它出现在一个进行 release 操作和一个进行 acquire 操作的线程间。</p><h3 id="C-atomic-用法"><a href="#C-atomic-用法" class="headerlink" title="C++ atomic 用法"></a>C++ atomic 用法</h3><h3 id="atomic-和-mutex-区别"><a href="#atomic-和-mutex-区别" class="headerlink" title="atomic 和 mutex 区别"></a>atomic 和 mutex 区别</h3><p>atomic 可以实现数据结构的无锁设计，为什么还要用 mutex 呢？</p><p>std::atomic原子操作，主要是保护一个变量，互斥量的保护范围更大，可以一段代码或一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cmd_ffmpeg</title>
    <link href="/2022/06/17/cmd-ffmpeg/"/>
    <url>/2022/06/17/cmd-ffmpeg/</url>
    
    <content type="html"><![CDATA[<h2 id="ffmpeg命令行使用"><a href="#ffmpeg命令行使用" class="headerlink" title="ffmpeg命令行使用"></a>ffmpeg命令行使用</h2><p><a href="https://blog.csdn.net/avsuper/article/details/54918465?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-54918465-blog-119670672.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-54918465-blog-119670672.pc_relevant_antiscanv2&utm_relevant_index=6">FFMPEG命令行详细参数</a></p><h3 id="两种视频格式之间的转码"><a href="#两种视频格式之间的转码" class="headerlink" title="两种视频格式之间的转码"></a>两种视频格式之间的转码</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>callback</title>
    <link href="/2022/06/15/callback/"/>
    <url>/2022/06/15/callback/</url>
    
    <content type="html"><![CDATA[<h2 id="C-回调函数"><a href="#C-回调函数" class="headerlink" title="C++回调函数"></a>C++回调函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(* func)(<span class="hljs-type">int</span>)<br>返回值类型(* 函数指针变量名)(参数)<br></code></pre></td></tr></table></figure><h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;<br>             &lt;返回值类型 (参数) &gt;<br></code></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>1、普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>(* cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// std::function</span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">register_func1</span>(callback);<br>    <span class="hljs-built_in">register_func2</span>(callback);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(A a, <span class="hljs-type">void</span>(A::*cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    (a.*cb)(<span class="hljs-number">100</span>); <span class="hljs-comment">// Note: 要用括号; 要带*</span><br>&#125;<br><br><span class="hljs-comment">// std::function </span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    <span class="hljs-built_in">register_func1</span>(a, &amp;A::callback); <span class="hljs-comment">// 要传入两个参数</span><br><br>    <span class="hljs-keyword">auto</span> cb = std::<span class="hljs-built_in">bind</span>(&amp;A::callback, &amp;a, std::placeholders::_1); <span class="hljs-comment">// 使用std::bind将对象地址绑定到this位置。placehoders::_1 待传入参数的占位符。</span><br>    <span class="hljs-built_in">register_func2</span>(cb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>1、函数指针是C中定义的实际函数的地址. std :: function是一个包装器,可以容纳任何类型的可调用对象(可以像函数一样使用的对象)</p><p>2、函数指针也可以和std::bind配合使用，但是std::function功能更强大，和std::bind配合更方便</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_usage</title>
    <link href="/2022/05/06/hexo-usage/"/>
    <url>/2022/05/06/hexo-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="部署hexo环境"><a href="#部署hexo环境" class="headerlink" title="部署hexo环境"></a>部署hexo环境</h3><ol><li>首先安装node.js和Git<figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>node.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br><span class="hljs-comment">#查看安装的版本</span><br>node -v<br>git --version<br></code></pre></td></tr></table></figure></li><li>安装hexo<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure></li><li>创建博客目录，初始化<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>hexo init<br></code></pre></td></tr></table></figure></li></ol><h3 id="移植到另一台电脑"><a href="#移植到另一台电脑" class="headerlink" title="移植到另一台电脑"></a>移植到另一台电脑</h3><ol><li>备份好原来的 blog 目录 &#x3D;&gt; old_blog</li><li>新电脑配置好 hexo 环境，并新建好blog 目录 &#x3D;&gt; new_blog</li><li>将 old_blog 目录下的 _conifg.yml、source、和themes 复制到 new_blog 目录</li></ol><p>Note：可以将blog 目录直接备份在github repo 中，可以很方便的进行移植。</p><h3 id="hexo集成到docker镜像"><a href="#hexo集成到docker镜像" class="headerlink" title="hexo集成到docker镜像"></a>hexo集成到docker镜像</h3><p><a href="https://gitee.com/LakeVilladom/docker-hexo">docker-hexo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug记录：常量值截断(truncation of constant value)</title>
    <link href="/2022/05/05/bug-truncation-of-constant-value/"/>
    <url>/2022/05/05/bug-truncation-of-constant-value/</url>
    
    <content type="html"><![CDATA[<h3 id="char和unsigned-char"><a href="#char和unsigned-char" class="headerlink" title="char和unsigned char"></a>char和unsigned char</h3><p><strong>char的取值范围</strong>：-128~127<br>&ensp;&ensp;-128: 16进制0x80  二进制1000 0000<br>&ensp;&ensp;-127: 16进制0xff   &ensp;二进制1111 1111，注意第一位是符号位，0111 1111是127</p><p><strong>unsigned char的取值范围</strong>：0~255，16进制0x00 ~ 0xff</p><h3 id="内存中的0xf0-1111-0000"><a href="#内存中的0xf0-1111-0000" class="headerlink" title="内存中的0xf0: 1111 0000"></a>内存中的0xf0: 1111 0000</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x = <span class="hljs-number">0xf0</span>; <span class="hljs-comment">// 十进制数大小为240，超出了127，导致常量值截断</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">0xf0</span> == x)&#123; <span class="hljs-comment">// x86机器上判断为false，arm机器上可能判断为true</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;x == 0xf0&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout&lt;&lt; <span class="hljs-string">&quot;char x= &quot;</span> &lt;&lt; x <br>&lt;&lt; <span class="hljs-string">&quot;\tunsigned char x = &quot;</span> &lt;&lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)x <br>&lt;&lt; <span class="hljs-string">&quot;\tint x = &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)x &lt;&lt; std::endl; <span class="hljs-comment">// 在不同机器上可能出现不同值</span><br></code></pre></td></tr></table></figure><p>mac(m1 arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">-16</span>  <br></code></pre></td></tr></table></figure><p>linux(x86)打印结果和上面一致</p><p>arm盒子(arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp; char和unsigned char乱码，直接看int，一个取值-16，一个取值240</p><p><strong>取值为-16的情况：</strong></p><p>&ensp;&ensp;&ensp;&ensp; int类型时，-16的二进制为 1000 0000| 0000 0000| 0000 0000| 0001 0000，最后一个字节是0001 0000</p><p>&ensp;&ensp;&ensp;&ensp; 而1111 0000 取反为 0000 11111，加1正好是0001 0000，即0xf0的补码是0001 0000，因此在将(char)0xf0变为int类型时的十进制数-16，至于为什么是这样的规则我也不知道。<br><strong>取值为240的情况：</strong></p><p>&ensp;&ensp;&ensp;&ensp; int类型时，240的二进制为 0000 0000| 0000 0000| 0000 0000| 1111 0000，最后一个字节就是1111 0000</p><p>&ensp;&ensp;&ensp;&ensp;综上，有些机器在处理常量截断时是取补码，而有些机器是取正码，即不变。实际上，<code>char x = 0xf0</code>这种用法本身就是错误的，不应该使用，对二进制字节比较时最好选用<code>unsigned char</code>类型。</p><p>&ensp;&ensp;&ensp;&ensp;不过，在对内存中的二进制字节进行判断时，也可以使用 if(x &#x3D;&#x3D; (char)0xf0)这种形式。</p><p><strong>Note &amp; 猜测:</strong></p><p>&ensp;&ensp;&ensp;&ensp; <code>char x = 0xf0</code> 虽然发生了常量截断，但是内存中的值确实是0xf0，只不过在从内存中读取出来时不同类型有不同的取值。</p><p>参考：</p><p><a href="http://www.cplusplus.com/forum/beginner/48577/">http://www.cplusplus.com/forum/beginner/48577/</a><br><a href="https://zhidao.baidu.com/question/533897399.html">https://zhidao.baidu.com/question/533897399.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_in_mac</title>
    <link href="/2022/05/04/test-in-mac/"/>
    <url>/2022/05/04/test-in-mac/</url>
    
    <content type="html"><![CDATA[<p>a test for mac hexo<br>second test</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git_ssh_usage</title>
    <link href="/2021/11/26/git-ssh-usage/"/>
    <url>/2021/11/26/git-ssh-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="git在线练习平台"><a href="#git在线练习平台" class="headerlink" title="git在线练习平台"></a>git在线练习平台</h3><p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org</a></p><p><a href="https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw">git常用命令和基本概念</a></p><h3 id="代码托管平台push-时需要的-ssh-密钥"><a href="#代码托管平台push-时需要的-ssh-密钥" class="headerlink" title="代码托管平台push 时需要的 ssh 密钥"></a>代码托管平台push 时需要的 ssh 密钥</h3><h4 id="ssh-密钥生成"><a href="#ssh-密钥生成" class="headerlink" title="ssh 密钥生成"></a>ssh 密钥生成</h4><ol><li>生成ssh密钥  ssh-keygen -t rsa   可以直接一路回车</li><li>打印密钥内容  cat ~&#x2F;.ssh&#x2F;id_rsa.pub</li><li>复制密钥到托管平台</li><li>查看.ssh&#x2F;config文件，是否配置了你的ssh，没有配置不会被使用（在多人使用的情况下要注意）</li></ol><h4 id="ssh-配置"><a href="#ssh-配置" class="headerlink" title="ssh 配置"></a>ssh 配置</h4><h5 id="多个用户时，指定用户在代码托管平台所用的密钥"><a href="#多个用户时，指定用户在代码托管平台所用的密钥" class="headerlink" title="多个用户时，指定用户在代码托管平台所用的密钥"></a>多个用户时，指定用户在代码托管平台所用的密钥</h5><p>ssh-keygen 生成密钥时指定名称，比如加个后缀 .github来表示该密钥是用于github</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Host github.com<br>    User hansanf<br>    IdentityFile ~/.ssh/id_rsa.github<br></code></pre></td></tr></table></figure><h6 id="ssh-连接远程主机时别名登录和免密登录"><a href="#ssh-连接远程主机时别名登录和免密登录" class="headerlink" title="ssh 连接远程主机时别名登录和免密登录"></a>ssh 连接远程主机时别名登录和免密登录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 Host fgq<br>2     HostName 主机端ip<br>3     User 主机端用户名<br>4     Port 22<br>5     IdentityFile ~/.ssh/id_rsa.remote  <span class="hljs-comment"># 连接主机所用的密钥，需要将公钥放在主机端</span><br></code></pre></td></tr></table></figure><p>将公钥放在主机端 ~&#x2F;.ssh&#x2F; 目录下使用 <code>ssh-copy-id -i ~/.ssh/id_rsa.pub username@192.168.11.11</code>，或scp 传输到 .ssh 目录下, 然后就可以通过 <code>ssh fgq</code> 登录远程主机了</p><h6 id="ssh-通过跳板机登录远程主机"><a href="#ssh-通过跳板机登录远程主机" class="headerlink" title="ssh 通过跳板机登录远程主机"></a>ssh 通过跳板机登录远程主机</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host fgq<br>    HostName 192.168.2.100<br>    User caros<br>    Port 22<br>    ProxyCommand ssh middle@relay  %h:%p<br><br>Host relay<br>    HostName 192.168.1.10<br>    User middle<br>    Port 22<br></code></pre></td></tr></table></figure><p>上述配置实现<code>ssh fgq</code>时先登录relay 机器，然后再登录到 fgq 主机。</p><h3 id="github登录方式"><a href="#github登录方式" class="headerlink" title="github登录方式"></a>github登录方式</h3><p><a href="https://blog.csdn.net/nbaDWde/article/details/80360836?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https和ssh两种</a><br><a href="https://baijiahao.baidu.com/s?id=1717846683433344604&wfr=spider&for=pc">https密码设置</a></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h4><p>全局配置文件有<code>~/.gitconfig</code>和<code>~/.git-credentials</code>两个</p><p><code>~/.gitconfig</code>对应着<code>git config --global</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name fgq<br> <br>//删<br>git config  --global --<span class="hljs-built_in">unset</span> user.name<br> <br>//改<br>git config --global user.name fgq<br></code></pre></td></tr></table></figure><p>比如修改GitHub账号名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config  --global  user.name hansanf<br></code></pre></td></tr></table></figure><p><code>~/.gitconfig</code>文件就会相应的做出修改<br><img src="https://img-blog.csdnimg.cn/6e26501083b945e1a65f2c225387b949.png" alt="在这里插入图片描述"></p><p><code>~/.git-credentials</code>中文是资格证书，里面保存github的token，使每次登陆都可以免密, 该部分应该是https token,也可以直接使用上面介绍的 ssh 配置。</p><p>需要注意的是, 在hexo 的 deploy (_config.yml) 中, </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:hansanf/hansanf.github.io.git</span>    <span class="hljs-comment"># ssh 方式, 需要设置 ssh</span><br>    <span class="hljs-comment">#repo: https://github.com/hansanf/hansanf.github.io   #https 方式, 需要设置 git-credentials </span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>repo 的地址可以在 github 的 repo 页面，点击 Code, 查看对应的 https 地址和ssh 地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://GitHub用户名:具体的token@github.com<br></code></pre></td></tr></table></figure><h4 id="局部配置文件"><a href="#局部配置文件" class="headerlink" title="局部配置文件"></a>局部配置文件</h4><p>在使用 <code>git init 文件目录</code>命令配置的git工作区中，即<code>文件目录/.git/config</code>，是局部配置文件，对应着<code>git config --local</code>命令。</p><p><code>.gitignore</code>也是只对当前工作区起作用，可以把要忽略的文件名填进去，然后Git就会自动忽略这些文件</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 不忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><h3 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h3><h4 id="把修改-删除-新建文件添加到暂存区"><a href="#把修改-删除-新建文件添加到暂存区" class="headerlink" title="把修改&#x2F;删除&#x2F;新建文件添加到暂存区"></a>把修改&#x2F;删除&#x2F;新建文件添加到暂存区</h4><ul><li>修改和删除的  <code>git add -u</code>  –update</li><li>修改和新建的  <code>git add .</code> </li><li>修改、删除和新建的 <code>git add -A</code> -ALL</li></ul><h4 id="add后的东西撤销"><a href="#add后的东西撤销" class="headerlink" title="add后的东西撤销"></a>add后的东西撤销</h4><ul><li><code>git status</code> 查看暂存区有哪些文件</li><li><code>git reset HEAD</code> 暂存区所有文件都撤销</li><li><code>git reset HEAD /XXX/XXX.cpp</code> 撤销特定的文件</li><li>git checkout –</li></ul><p>恢复到前一个commit, 并且将当前commit 的提交全部变为 绿色 <code>git reset --soft HEAD^</code></p><p>恢复到前一个commit，并且将当前commit 的提交全部变为 红色 <code>git reset --mixed HEAD^</code></p><p>–soft 和 –mixed 不会修改文件内容，只会修改文件在仓库的状态</p><p>将某个文件从当前提交中删除, 有一条删除该文件的修改，但文件内容不会变 <code>git rm --cache test.txt</code></p><h4 id="提交到本地仓库（repository）"><a href="#提交到本地仓库（repository）" class="headerlink" title="提交到本地仓库（repository）"></a>提交到本地仓库（repository）</h4><p><code>git commit -m &quot;记录版本信息&quot;</code> 提交暂存区文件到本地仓库<br><code>git log</code> 查看commit-id和所有的版本信息</p><h4 id="提交仓库后，再次修改而不保留上次commit信息"><a href="#提交仓库后，再次修改而不保留上次commit信息" class="headerlink" title="提交仓库后，再次修改而不保留上次commit信息"></a>提交仓库后，再次修改而不保留上次commit信息</h4><ul><li><code>git commit --amend</code><br>在本地仓库内容没有合并入远程分支时，可以给上次commit的内容打补丁。打完补丁后，上次的commit-id和其版本信息都被本次的amend所覆盖<br>加上 –no-edit 可直接跳过修改comment</li></ul><h4 id="推到远程仓库，合入master"><a href="#推到远程仓库，合入master" class="headerlink" title="推到远程仓库，合入master"></a>推到远程仓库，合入master</h4><ul><li><code>git push origin HEAD:refs/for/master </code><br>origin是远程仓库的代名词<br>master远程仓库的分支</li></ul><h4 id="避免push到远程合入时有冲突，先拉远程最新分支"><a href="#避免push到远程合入时有冲突，先拉远程最新分支" class="headerlink" title="避免push到远程合入时有冲突，先拉远程最新分支"></a>避免push到远程合入时有冲突，先拉远程最新分支</h4><ul><li><code>git stash</code> 把本地修改的内容保存到堆栈中</li><li><code>git pull</code> 拉取远程最新代码，并merge到本地HEAD  <code>git pull = git fetch ; git merge </code></li><li><code>git stash pop</code> 修改内容从堆栈弹出<br>然后再 add，commit。这样可以基于当前的最新内容进行更改</li></ul><h4 id="merge时有冲突，手动修改冲突内容"><a href="#merge时有冲突，手动修改冲突内容" class="headerlink" title="merge时有冲突，手动修改冲突内容"></a>merge时有冲突，手动修改冲突内容</h4><p>打开冲突文件</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-section">=======</span><br>Creating a new branch is quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 是两个版本的冲突内容，上面是当前版本，下面是别的分支修改后的版本，删掉不需要的内容，和所有&#x3D;&#x3D;、&gt;&gt;·HEAD。</p><p>TODO: 怎么用还不太确定<br>    自动修改冲突，使用 git checkout –ours 或者 git checkout –theirs</p><h4 id="单独克隆一个分支"><a href="#单独克隆一个分支" class="headerlink" title="单独克隆一个分支"></a>单独克隆一个分支</h4><p>git clone –branch 分支名 –depth 分支深度<br>单独克隆一个分支后git pull只能拉取当前分支的内容，若需要其他分支，需要先fetch到本地：git fetch origin [remote-branch]:[local-branch]</p><h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>制作补丁：git diff &gt; xxx.patch<br>检查patch文件：git apply –stat xxx.patch<br>查看补丁是否能够干净顺利地应用到当前分支中: git apply –check xxx.patch<br>将补丁合入当前分支 git apply xxx.patch</p><h3 id="git-error-解决"><a href="#git-error-解决" class="headerlink" title="git error 解决"></a>git error 解决</h3><h4 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h4><p><a href="https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error">https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error</a></p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>参考：<br><a href="https://blog.csdn.net/themagickeyjianan/article/details/79683980?spm=1001.2014.3001.5506">修改git config配置文件</a></p><p><a href="https://blog.csdn.net/Lakers2015/article/details/111990909">Git 中的.gitignore文件的作用及配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量</title>
    <link href="/2021/11/25/linux-environment-path/"/>
    <url>/2021/11/25/linux-environment-path/</url>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="三个文件"><a href="#三个文件" class="headerlink" title="三个文件"></a>三个文件</h3><h4 id="1-etc-profile"><a href="#1-etc-profile" class="headerlink" title="1. /etc/profile"></a>1. <code>/etc/profile</code></h4><p>系统级别，可以所有用户起作用，网上有说是在用户登录时读取的。但在我电脑上使用<code>source /etc/profile</code>后只在当前终端起作用，新建终端仍不生效，为了以后在每个终端上都生效可以在<code>~/.bashrc</code>中添加<code>source /etc/profile</code>。<br>注意<code>~/.bashrc</code>和<code>/etc/profile</code>中还包括对终端其他方面的设置，比如显示格式、颜色</p><h4 id="2-etc-environment"><a href="#2-etc-environment" class="headerlink" title="2. /etc/environment"></a>2. <code>/etc/environment</code></h4><p>系统级别，应该是专门用于设置环境变量的，据说优先级高于<code>/etc/profile</code>，没验证过。</p><h4 id="3-bashrc"><a href="#3-bashrc" class="headerlink" title="3. ~/.bashrc"></a>3. <code>~/.bashrc</code></h4><p>只对当前用户生效，在个人电脑上直接修改这个文件即可，简单省事。</p><h3 id="环境变量书写格式"><a href="#环境变量书写格式" class="headerlink" title="环境变量书写格式"></a>环境变量书写格式</h3><p>最好在文件末尾添加</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin:/usr/bin<br></code></pre></td></tr></table></figure><p><code>PATH</code>表示环境变量，等号两边不要有空格（shell语法，赋值时等号两边不能有空格）<br><code>$PATH</code>表示取变量值，即如果上面定义了<code>PATH</code>，可以直接引用上面定义好的环境变量，所以这也是为什么要加在文件末尾<br><code>:</code>为分隔符，每一个环境变量的路径都要用<code>:</code>分开</p><p>上面这段代码等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin<br>PATH=<span class="hljs-variable">$PATH</span>:/usr/bin<br></code></pre></td></tr></table></figure><p>修改好后，使用source使其生效</p><h3 id="3-export命令"><a href="#3-export命令" class="headerlink" title="3.export命令"></a>3.export命令</h3><p>export命令使环境变量在当前终端生效，关闭终端后失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:环境变量路径<br></code></pre></td></tr></table></figure><p>注意，一定要加上<code>$PATH</code>,否则会使已有的环境变量全都失效，只剩下新添加的</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ln命令</title>
    <link href="/2021/11/25/cmd-ln/"/>
    <url>/2021/11/25/cmd-ln/</url>
    
    <content type="html"><![CDATA[<h3 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h3><h4 id="格式和参数"><a href="#格式和参数" class="headerlink" title="格式和参数"></a>格式和参数</h4><p>语法格式： ln [参数] <strong>[源</strong>文件或目录] [<strong>目标</strong>文件或目录]<br>ln a b  a&#x3D;&gt;b</p><table><thead><tr><th>参数</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td>空</td><td>hard</td><td>对源文件建立硬链接</td></tr><tr><td>-s</td><td>soft</td><td>对源文件建立软连接（符号链接）</td></tr><tr><td>-f</td><td>force</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-b</td><td>backup</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-i</td><td>Interactive</td><td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td></tr><tr><td>-v</td><td>verbose</td><td>详细信息模式，输出指令的详细执行过程</td></tr><tr><td>-d</td><td>direction</td><td>此选项允许“root”用户建立目录的硬链接</td></tr></tbody></table><h4 id="软连接、硬链接和拷贝的区别"><a href="#软连接、硬链接和拷贝的区别" class="headerlink" title="软连接、硬链接和拷贝的区别"></a>软连接、硬链接和拷贝的区别</h4><p><strong>软连接：</strong></p><ul><li>链接文件内存储的是原文件的inode，也就是说是用来指向原文件文件，这<strong>两个文件的inode是不一样</strong>的</li><li>软链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li><li>删除软链接的链接文件，被链接文件不会受到任何影响，但是修改软链接文件内容，被链接文件内容也会被修改</li><li>软链接可以跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接不可以。</li><li>软链接可以对目录进行链接，硬链接不可以。</li><li>删除软链接的被链接文件，链接文件会变成红色，这时打开链接文件会报错，报找不到被链接的文件这种错误</li></ul><p><strong>硬连接：</strong><br>-硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件，这两个文件的<strong>inode号是同一个</strong>（ls -i）</p><ul><li>硬链接以文件副本的形式存在，但不占用实际空间。</li><li>硬链接不允许普通用户给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li></ul><blockquote><p>A硬链B 删除B后A依然存在，且可用。<br>A软链B 删除B后A存在，但不可用了（相当于Windows下快捷方式指向的目标不存在了）</p></blockquote><p><strong>拷贝：</strong></p><ul><li>拷贝产生的文件是一个独立的文件，有自己的元信息和inode节点</li></ul><blockquote><p> 软连接和硬链接在使用时用哪一个，主要看是否需要链接目录，是否依赖相对路径，没有限制条件两者应该都可以使用。</p></blockquote><p>参考：<br><a href="https://www.linuxcool.com/ln">linux命令大全</a><br><a href="https://blog.csdn.net/geerniya/article/details/79093301">软链接、硬链接与复制的区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++可变参数</title>
    <link href="/2021/11/24/cpp-variable-arguments/"/>
    <url>/2021/11/24/cpp-variable-arguments/</url>
    
    <content type="html"><![CDATA[<h3 id="参数列表的…"><a href="#参数列表的…" class="headerlink" title="参数列表的…"></a>参数列表的…</h3><p>… 表示函数的参数个数可变，典型的如<code>printf()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * szFormat, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br><span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ; <br></code></pre></td></tr></table></figure><h3 id="使用…实现变参数函数的两种场景"><a href="#使用…实现变参数函数的两种场景" class="headerlink" title="使用…实现变参数函数的两种场景"></a>使用…实现变参数函数的两种场景</h3><h4 id="1-格式化字符串"><a href="#1-格式化字符串" class="headerlink" title="1. 格式化字符串"></a>1. 格式化字符串</h4><blockquote><p><strong>使用场景：</strong><br>类似于实现一个printf，输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, va_list ap)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">vasprintf</span>(&amp;buf, format, ap); <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>  <span class="hljs-comment">// 重载了func函数，不重载也行</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list ap;<br>    <span class="hljs-type">char</span> *res = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-built_in">va_start</span>(ap, format);<br>    res = <span class="hljs-built_in">func</span>(format, ap);  <br>    <span class="hljs-built_in">va_end</span>(ap);<br>    <span class="hljs-keyword">return</span> res ;  <br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br>    <span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %s \n&quot;</span>, str) ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果<br>result: info &#123;name:fgq, age:<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br>上面func()函数重载了，如果不是类成员函数，要注意函数定义的顺序，在func(const char* format, …)里要调用<code>func(const char* format, va_list ap)</code> ，因此<code>func(const char* format, ...)</code>要定义在后面。类内成员函数则可以是任意顺序。</p></blockquote><p>实际上完成占位符替换为数据的是<code>int vasprintf (char **buf, const char *format, va_list ap)</code>函数：<br><code>buf</code>：一个用于保存结果的字符串缓冲区<br><code>format</code>：一个格式化字符串<br><code>ap</code>:va_list类型的变量, va_list是一个宏，和va_start(va_list, arg)、va_arg(va_list, type)、va_end(va_list)这些宏在定义在头文件stdarg.h中，下面详细介绍通过这些宏来实现可变参数函数</p><h4 id="2-执行时指定可变参数类型"><a href="#2-执行时指定可变参数类型" class="headerlink" title="2.执行时指定可变参数类型"></a>2.执行时指定可变参数类型</h4><blockquote><p><strong>使用场景：</strong><br>将n个数进行相加，此时n是不确定的，如果用重载方法，可能要重载很多次，如下面的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例子：<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2, <span class="hljs-type">double</span> d3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br></code></pre></td></tr></table></figure><p>使用可变参数的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;  <span class="hljs-comment">//格式:count代表参数个数, ...代表n个参数</span><br> <br>va_list ap;  <span class="hljs-comment">//声明一个va_list变量</span><br><span class="hljs-built_in">va_start</span>(ap, count);  <span class="hljs-comment">//第二个参数表示形参的个数</span><br> <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <span class="hljs-comment">// 按顺序返回参数列表中的参数</span><br>res += <span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>);   <span class="hljs-comment">//第二个参数表示形参类型</span><br>&#125;<br><br><span class="hljs-built_in">va_end</span>(ap);  <span class="hljs-comment">//用于清理</span><br> <br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">输出结果：<br>6<br></code></pre></td></tr></table></figure><h3 id="使用initializer-list实现变参函数"><a href="#使用initializer-list实现变参函数" class="headerlink" title="使用initializer_list实现变参函数"></a>使用initializer_list实现变参函数</h3><p><code>initializer_list</code>是一个列表初始化容器，声明在initializer_list头文件中，可以采用迭代器的方式来遍历参数列表，克服了<code>...</code>需要指定参数个数的缺点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initializerSum</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; il)</span> </span>&#123;<br>   <br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = il.<span class="hljs-built_in">begin</span>(); ptr != il.<span class="hljs-built_in">end</span>(); ptr++)  <span class="hljs-comment">//类似于容器的操作</span><br>&#123;<br>sum += *ptr;<br>&#125;<br> <br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">initializerSum</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) ;  <span class="hljs-comment">// 初始化 initializer_list&lt;int&gt;</span><br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il &#123;<span class="hljs-number">1</span>&#125; ;<br>    res = <span class="hljs-built_in">initializerSum</span>(il);<br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    <span class="hljs-function">std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ill</span> <span class="hljs-params">(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)</span> </span>;<br>    res = <span class="hljs-built_in">initializerSum</span>(ill);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <br>    <span class="hljs-keyword">auto</span> illl = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    res = <span class="hljs-built_in">initializerSum</span>(illl);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="http://en.cppreference.com/w/cpp/utility/initializer_list">cppreference对inittializer_list的介绍</a></p><p><a href="https://blog.csdn.net/baidu_15952103/article/details/105886761">va_list函数学习（va_start，va_end, vasprintf）</a></p><p><a href="https://blog.csdn.net/alex1997222/article/details/78639991">C++可变参数的两种方法</a></p><p><a href="https://blog.csdn.net/anye3000/article/details/6593551">printf,sprintf,vsprintf 区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++宏的使用技巧</title>
    <link href="/2021/11/23/cpp-marco-tips/"/>
    <url>/2021/11/23/cpp-marco-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="宏的使用技巧"><a href="#宏的使用技巧" class="headerlink" title="宏的使用技巧"></a>宏的使用技巧</h3><blockquote><p>1、在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义<br>2、\ 用来换行<br>3、 # 把变量变为字符串</p></blockquote><h4 id="1-在switch中使代码更简洁"><a href="#1-在switch中使代码更简洁" class="headerlink" title="1.在switch中使代码更简洁"></a>1.在switch中使代码更简洁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br><span class="hljs-keyword">switch</span>(level)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XX(i,name) \</span><br><span class="hljs-meta">case i: \</span><br><span class="hljs-meta">return name; \</span><br><span class="hljs-meta"></span><br><span class="hljs-built_in">XX</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>) ; <br><span class="hljs-built_in">XX</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;INFO&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;WARN&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;ERROR&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;FATAL&quot;</span>) ;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> XX</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-把变量变为字符串"><a href="#2-把变量变为字符串" class="headerlink" title="2.#把变量变为字符串"></a>2.#把变量变为字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1000</span> ; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(a)&lt;&lt;endl; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(b)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式</title>
    <link href="/2021/11/19/template_pattern/"/>
    <url>/2021/11/19/template_pattern/</url>
    
    <content type="html"><![CDATA[<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p><strong>意图:</strong> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决:</strong> 一些方法通用，却在每一个子类都重新写了这一方法。</p><blockquote><p><strong>例子</strong><br>建造房子的流程都是一样的，比如：打地基-&gt;砌砖头-&gt;盖屋顶<br>但是不同种类的房子，比如茅草房和别墅，在这三个步骤中所要做的具体事情不一样<br>此时就可以应用模板模式，在接口类（基类）中抽象出统一的流程，在子类中再重写具体步骤的方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IGame</span>&#123;  <span class="hljs-comment">// 接口类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-comment">//模板：固定不变的部分，定义统一的游戏流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">initialize</span>();<br>        <span class="hljs-built_in">startPlay</span>();<br>        <span class="hljs-built_in">endPlay</span>(); <br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IGame</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basketball</span>:<span class="hljs-keyword">public</span> IGame&#123;  <br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Basketball</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Football</span>:<span class="hljs-keyword">public</span> IGame&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Football</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    IGame *pb ;  <br>    Basketball basketball ; <br>    Football Football ; <br>    pb = &amp;basketball ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    pb = &amp;Football ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打印输出：<br><br><span class="hljs-keyword">Basketball </span>initialize<br><span class="hljs-keyword">Basketball </span>startPlay<br><span class="hljs-keyword">Basketball </span>endPlay<br>Football initialize<br>Football startPlay<br>Football endPlay<br></code></pre></td></tr></table></figure><hr><p><strong>总结：</strong><br>模板模式在类库的设计中很常见，在模板模式中，库设计者会给使用者提供固定的流程和需要重写的接口，使用者通常只需要：<br>1、继承父类；<br>2、重写某一个或某几个接口；<br>3、调用包含了所有流程的方法，比如<code>play()</code></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的设计原则和分类</title>
    <link href="/2021/11/19/design-pattern-priciple-classification/"/>
    <url>/2021/11/19/design-pattern-priciple-classification/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式的设计原则和分类"><a href="#设计模式的设计原则和分类" class="headerlink" title="设计模式的设计原则和分类"></a>设计模式的设计原则和分类</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h4 id="1、依赖倒置原则（DIP）"><a href="#1、依赖倒置原则（DIP）" class="headerlink" title="1、依赖倒置原则（DIP）"></a>1、依赖倒置原则（DIP）</h4><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul><h4 id="2、开放封闭原则（OCP）"><a href="#2、开放封闭原则（OCP）" class="headerlink" title="2、开放封闭原则（OCP）"></a>2、开放封闭原则（OCP）</h4><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><h4 id="3、单一职责原则（SRP）"><a href="#3、单一职责原则（SRP）" class="headerlink" title="3、单一职责原则（SRP）"></a>3、单一职责原则（SRP）</h4><ul><li>一个类应该仅有一个引起他变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h4 id="4、Liskov替换原则（LSP）"><a href="#4、Liskov替换原则（LSP）" class="headerlink" title="4、Liskov替换原则（LSP）"></a>4、Liskov替换原则（LSP）</h4><ul><li>子类必须能够替换他们的基类（IS-A）。</li><li>继承表达类型抽象。</li></ul><h4 id="5、接口隔离原则（ISP）"><a href="#5、接口隔离原则（ISP）" class="headerlink" title="5、接口隔离原则（ISP）"></a>5、接口隔离原则（ISP）</h4><ul><li>不应该强迫客户程序依赖他们不用的方法。</li><li>接口应该小而完备。</li></ul><h4 id="6、迪米特洛原则（最少知识原则）"><a href="#6、迪米特洛原则（最少知识原则）" class="headerlink" title="6、迪米特洛原则（最少知识原则）"></a>6、迪米特洛原则（最少知识原则）</h4><ul><li>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</li><li>优先使用对象组合，而不是类继承。类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><h4 id="7、封装变化点"><a href="#7、封装变化点" class="headerlink" title="7、封装变化点"></a>7、封装变化点</h4><ul><li>使用封装来创建对象之间的分解层，让设计者可以在分层的一侧进行修改，而不会对另一侧产生不良的影响，减少层次间的耦合。</li></ul><h4 id="8、针对接口（抽象类）编程，而不是针对实现编程"><a href="#8、针对接口（抽象类）编程，而不是针对实现编程" class="headerlink" title="8、针对接口（抽象类）编程，而不是针对实现编程"></a>8、针对接口（抽象类）编程，而不是针对实现编程</h4><ul><li>不将变量类型生命为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无须获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”。</li><li>和依赖倒置原则相辅相成。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>三分类：<a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a></p><p>李建忠老师的九分类：</p><table><thead><tr><th>模式分类</th><th>包括</th></tr></thead><tbody><tr><td><strong>组件协作</strong></td><td>模板模式<br>策略模式<br>观察者模式</td></tr><tr><td><strong>单一职责</strong></td><td>装饰者模式<br> 桥接模式</td></tr><tr><td><strong>对象创建</strong></td><td>工厂模式<br>抽象工厂模式<br>原型模式<br>建造者模式</td></tr><tr><td><strong>对象性能</strong></td><td>单例模式<br>享元模式</td></tr><tr><td><strong>接口隔离</strong></td><td>门面模式<br>代理模式<br>适配器模式<br>中介者模式</td></tr><tr><td><strong>状态变化</strong></td><td>状态模式<br>备忘录模式</td></tr><tr><td><strong>数据结构</strong></td><td>组合模式<br>迭代器模式<br>职责链模式</td></tr><tr><td><strong>行为变化</strong></td><td>命令模式<br>访问器模式</td></tr><tr><td><strong>领域问题</strong></td><td>解析器模式</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_opencv</title>
    <link href="/2021/11/12/vscode-opencv/"/>
    <url>/2021/11/12/vscode-opencv/</url>
    
    <content type="html"><![CDATA[<h3 id="win10-vscode-加载opencv库"><a href="#win10-vscode-加载opencv库" class="headerlink" title="win10 vscode 加载opencv库"></a>win10 vscode 加载opencv库</h3><p>从头到尾的配置：<br>1、Visual Studio Code 配置<br>2、openCV 配置<br>3、MinGw 配置<br>4、cmake 配置<br>完整过程参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>如果使用vscode已经可以编译c++程序了，即可以省略掉大部分vscode和的MinGW的配置过程（只要vscode中配置好opencv的头文件路径和库路径即可）</p><p>opencv的配置过程，实际上就是库的加载过程，如果是已经编译好的opencv库，只要配置好头文件路径和库文件路径即可，如果是下载的源文件，则需要通过cmake进行编译。<br>cmake编译opencv参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>opencv已经编译好了之后，把头文件路径和库文件路径加到系统的环境变量中。</p><p>最后配置vscode的三个.json文件：<code>launch.json</code>、<code>tasks.json</code>、<code>c_cpp_properties.json</code></p><p>各自的配置如下：<br><code>launch.json</code>：主要注意<strong>miDebuggerPath</strong>和<strong>program</strong>两项</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">Use</span> <span class="hljs-string">IntelliSense</span> <span class="hljs-string">to</span> <span class="hljs-string">learn</span> <span class="hljs-string">about</span> <span class="hljs-string">possible</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">Hover</span> <span class="hljs-string">to</span> <span class="hljs-string">view</span> <span class="hljs-string">descriptions</span> <span class="hljs-string">of</span> <span class="hljs-string">existing</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-string">more</span> <span class="hljs-string">information</span>, <span class="hljs-attr">visit:</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        <br>        <br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;:</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;:</span> [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;:</span> [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;:</span> <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gdb.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;:</span> [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;:</span> <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json</code>：<br>主要修改<strong>args</strong>中大i、大L和小l<br>这里实际上就是g++ -I 头文件路径 -L 库文件路径 -l 库文件名<br>注意实际库文件的命名和这里写库文件名的区别   实际库文件名&#x3D;lib库文件名.dll.a</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">See</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">documentation</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">tasks.json</span> <span class="hljs-string">format</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;command&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>    <span class="hljs-attr">&quot;args&quot;:</span> [<br>        <span class="hljs-string">&quot;-g&quot;</span>, <br>        <span class="hljs-string">&quot;-std=c++11&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <br>        <span class="hljs-string">&quot;-o&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,  <br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>,<br>        <span class="hljs-string">&quot;-L&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\x64\\MinGW\\lib&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_core3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_dnn3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_features2d3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_flann3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_highgui3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgcodecs3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgproc3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ml3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_objdetect3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_photo3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_shape3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_stitching3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_superres3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_video3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videoio3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videostab3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ts3416&quot;</span><br><br>  <br>    ],<span class="hljs-string">//</span> <span class="hljs-string">编译命令参数</span><br>    <span class="hljs-string">&quot;problemMatcher&quot;</span><span class="hljs-string">:</span>&#123;<br>        <span class="hljs-attr">&quot;owner&quot;:</span> <span class="hljs-string">&quot;cpp&quot;</span>,<br>        <span class="hljs-string">&quot;fileLocation&quot;</span><span class="hljs-string">:</span>[<br>            <span class="hljs-string">&quot;relative&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;pattern&quot;</span><span class="hljs-string">:</span>[<br>            &#123;<br>                <span class="hljs-attr">&quot;regexp&quot;:</span> <span class="hljs-string">&quot;^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$&quot;</span>,<br>                <span class="hljs-attr">&quot;file&quot;:</span> <span class="hljs-number">1</span>,<br>                <span class="hljs-attr">&quot;location&quot;:</span> <span class="hljs-number">2</span>,<br>                <span class="hljs-attr">&quot;message&quot;:</span> <span class="hljs-number">3</span><br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;group&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;kind&quot;:</span> <span class="hljs-string">&quot;build&quot;</span>,<br>        <span class="hljs-attr">&quot;isDefault&quot;:</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>：<br>主要修改<strong>includePath</strong>和<strong>compilerPath</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;win&quot;</span>,<br>            <span class="hljs-attr">&quot;includePath&quot;:</span> [<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>         <br>            ],<br>            <span class="hljs-attr">&quot;defines&quot;:</span> [],<br>            <span class="hljs-attr">&quot;compilerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gcc.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;cStandard&quot;:</span> <span class="hljs-string">&quot;c11&quot;</span>,<br>            <span class="hljs-attr">&quot;cppStandard&quot;:</span> <span class="hljs-string">&quot;c++17&quot;</span>,<br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;:</span> <span class="hljs-string">&quot;clang-x64&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不是完全照搬上述的配置，需要注意：</p><ul><li><code>launch.json</code>的<strong>preLaunchTask</strong>和<code>tasks.json</code>中的<strong>label</strong>内容需要一致，否则报错，比如修改<code>launch.json</code>的<strong>preLaunchTask</strong>为g++.exe，则会报错<br><img src="https://img-blog.csdnimg.cn/0539074e59fe455882f429a521c318b4.png" alt="在这里插入图片描述"><br>三个json文件的作用：<br><code>tasks.json</code> (build instructions)<br><code>launch.json</code> (debugger settings)<br><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings</li></ul><p>vscode配置官方教程：<a href="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之类图表示</title>
    <link href="/2021/11/07/UML/"/>
    <url>/2021/11/07/UML/</url>
    
    <content type="html"><![CDATA[<h3 id="类图属性"><a href="#类图属性" class="headerlink" title="类图属性"></a>类图属性</h3><p>一个大矩形里面分三层：</p><ul><li>类名</li><li>成员名：可见性 名称 ：类型 [ &#x3D; 默认值]</li><li>方法名：可见性  名称(参数列表) [ ： 返回类型]<br><img src="https://img-blog.csdnimg.cn/c59f02761f6b4d5c926297de49d48cfa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>可见性：</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected（friendly也归入这类）</li></ul><h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><h4 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h4><p>依赖关系使用<strong>带箭头的虚线</strong>来表示，箭头从使用类指向被依赖的类。</p><p><strong>人依赖手机：</strong><br><img src="https://img-blog.csdnimg.cn/f53bd1f094a946b9a8121fe7f7c3beb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>依赖（Dependency）关系是一种<strong>使用关系</strong>，它是对象之间耦合度最弱的一种关联方式，被使用对象的有无，不影响使用对象，是临时性的关联。</p><h4 id="2、关联"><a href="#2、关联" class="headerlink" title="2、关联"></a>2、关联</h4><p>依赖关系使用<strong>带箭头的实线</strong>来表示，箭头从使用类指向被关联的类，可以单向关联，也可以双向关联。</p><p>双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示。</p><p><strong>老师和学生双向关联：</strong>每个老师可以教多个学生，每个学生也可向多个老师学<br><img src="https://img-blog.csdnimg.cn/59ed529d91fb40fcb133824a7fc0f59b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>关联（Association）关系是对象之间的一种<strong>引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。被引用者不存在时，引用者可以存在，但是没有意义。</p><h4 id="3、聚合"><a href="#3、聚合" class="headerlink" title="3、聚合"></a>3、聚合</h4><p>聚合关系可以用<strong>带空心菱形的实线</strong>来表示，菱形指向整体。</p><p><strong>大学包含教师：</strong><br><img src="https://img-blog.csdnimg.cn/5979cb34f002423bb819274d3a3798d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是<strong>整体和部分之间的关系</strong>，是 has-a 的关系。当部分类不存在，整体类也不能存在，但是部分可以脱离整体而独立存在。比如大学不能脱离教师而存在，但是没有大学教师依然能够独立存在。</p><h4 id="4、组合"><a href="#4、组合" class="headerlink" title="4、组合"></a>4、组合</h4><p>组合关系用<strong>带实心菱形的实线来表示</strong>，菱形指向整体<br><strong>头和嘴：</strong><br><img src="https://img-blog.csdnimg.cn/9accac46ce1d4eb382cdf8d1c00623b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象也不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><h4 id="5、泛化"><a href="#5、泛化" class="headerlink" title="5、泛化"></a>5、泛化</h4><p>泛化关系用<strong>带空心三角箭头的实线</strong>来表示，箭头从子类指向父类。</p><p><strong>人和学生、老师：</strong><br><img src="https://img-blog.csdnimg.cn/b27b8f34dcfd4134b179533991d8d045.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是<strong>父类与子类之间的关系，是一种继承关系</strong>，是 is-a 的关系。</p><h4 id="6、实现"><a href="#6、实现" class="headerlink" title="6、实现"></a>6、实现</h4><p>实现关系使用<strong>带空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><strong>鸟和飞：</strong><br><img src="https://img-blog.csdnimg.cn/2380c43ba2dc4c07b395882e3930059c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>实现（Realization）关系是<strong>接口与实现类之间的关系</strong>。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。可以将实现类看做方法。</p><p>参考：<br><a href="https://www.cnblogs.com/shindo/p/5579191.html">https://www.cnblogs.com/shindo/p/5579191.html</a><br><a href="https://blog.csdn.net/sinat_21107433/article/details/102576624">https://blog.csdn.net/sinat_21107433&#x2F;article&#x2F;details&#x2F;102576624</a><br><a href="http://c.biancheng.net/view/1319.html">http://c.biancheng.net/view/1319.html</a><br><a href="https://www.jianshu.com/p/641682f9c918">https://www.jianshu.com/p/641682f9c918</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update_nodejs</title>
    <link href="/2021/11/01/update-nodejs/"/>
    <url>/2021/11/01/update-nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu升级nodejs"><a href="#Ubuntu升级nodejs" class="headerlink" title="Ubuntu升级nodejs"></a>Ubuntu升级nodejs</h2><h3 id="下载nodejs压缩文件"><a href="#下载nodejs压缩文件" class="headerlink" title="下载nodejs压缩文件"></a>下载nodejs压缩文件</h3><p>打开nodejs官网，打开<code>DOWNLOADS</code>页面，选择一个版本，右键复制链接地址，然后使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">wget https://nodejs.org/dist/v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><p>下载到本地</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><h3 id="将node和npm设置为全局"><a href="#将node和npm设置为全局" class="headerlink" title="将node和npm设置为全局"></a>将node和npm设置为全局</h3><p>将新的node可执行文件<strong>硬链接</strong>到&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node,如果提示连接已存在，可将&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node删掉，再重新连接(删除前建议先备份)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/node /usr/local/bin/node<br> <br>sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/npm /usr/local/bin/npm  <br></code></pre></td></tr></table></figure><p><strong>&#x2F;bin&#x2F;usr和&#x2F;bin&#x2F;local&#x2F;usr的区别：</strong><br>&emsp;&emsp; &#x2F;usr&#x2F;bin下面的都是系统预装的可执行程序，会随着系统升级而改变。<br>&emsp;&emsp; &#x2F;usr&#x2F;local&#x2F;bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。<br>&emsp;&emsp; &#x2F;如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fgq@ubuntu:~/hexo_blog$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br></code></pre></td></tr></table></figure><p>&emsp;&emsp; 这里&#x2F;usr&#x2F;local&#x2F;bin优先于&#x2F;usr&#x2F;bin, 一般都是如此</p><p><strong>另外一种设为全局的方法：使用别名alias</strong> </p><p>当前终端生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> node=解压后路径/node-v16.13.0-linux-x64/bin/node<br><span class="hljs-built_in">alias</span> npm=解压后路径/node-v16.13.0-linux-x64/bin/npm<br></code></pre></td></tr></table></figure><p>永久生效：<br>&emsp;&emsp;修改主目录下.bashrc文件(~&#x2F;.bashrc)，添加上述两句<br>&emsp;&emsp; 然后 <code>source  ~/.bashrc</code><br><strong>note:</strong> 等号两边没有空格 </p><blockquote><p>node和nodejs之间没有区别，node全称就是nodejs。nodejs是一个基于Chrome V8引擎的JavaScript运行环境</p></blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_37035946/article/details/99451703">1、https://blog.csdn.net/qq_37035946&#x2F;article&#x2F;details&#x2F;99451703</a><br><a href="https://blog.csdn.net/nzjdsds/article/details/88345400">2、https://blog.csdn.net/nzjdsds/article/details/88345400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux_tips</title>
    <link href="/2021/11/01/linux-tips/"/>
    <url>/2021/11/01/linux-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>for linux tips </p><h5 id="格式化环境变量"><a href="#格式化环境变量" class="headerlink" title="格式化环境变量"></a>格式化环境变量</h5><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span>|awk -F<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;for(i=1;i&lt;=NF;i++)print <span class="hljs-variable">$i</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="清空共享内存"><a href="#清空共享内存" class="headerlink" title="清空共享内存"></a>清空共享内存</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ipcs|awk &#x27;</span><span class="hljs-template-variable">&#123;print $1&#125;</span><span class="language-xml">&#x27;|xargs -I </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> sudo ipcrm -M </span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="查看系统启动时间"><a href="#查看系统启动时间" class="headerlink" title="查看系统启动时间"></a>查看系统启动时间</h5><p><code>ps -p PID -o lstart</code></p><p>top 的 TIME 是占用 cpu 时间</p><p>(加sudo 权限)修改系统时间和时区: <a href="https://www.cnblogs.com/ljy2013/p/4615149.html">https://www.cnblogs.com/ljy2013/p/4615149.html</a></p><h5 id="磁盘-U盘-挂载"><a href="#磁盘-U盘-挂载" class="headerlink" title="磁盘&#x2F;U盘 挂载"></a>磁盘&#x2F;U盘 挂载</h5><p>查看磁盘列表 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo fdisk -l</span><br></code></pre></td></tr></table></figure><p>挂载 mount</p><p>卸载 umount</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mount 磁盘名称 挂载路径<br>sudo umount 磁盘名称<br>比如: <br>sudo mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/home/</span>work/<br>sudo umount <span class="hljs-regexp">/dev/</span>sda1    <br></code></pre></td></tr></table></figure><p>不小心拔下在复制数据的移动硬盘出现无法加载的错误</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MFTMirrdoesnotmatchMFTMirrdoesnotmatchMFT (<span class="hljs-built_in">record</span> <span class="hljs-number">0</span>).<br>Failed <span class="hljs-keyword">to</span> mount &#x27;/dev/sda1&#x27;: Input/output <span class="hljs-keyword">error</span><br>NTFS <span class="hljs-keyword">is</span> either inconsistent, <span class="hljs-keyword">or</span> there <span class="hljs-keyword">is</span> a hardware fault, <span class="hljs-keyword">or</span> <span class="hljs-keyword">it</span>&#x27;s a<br>SoftRAID/FakeRAID hardware. In <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> case <span class="hljs-built_in">run</span> chkdsk /f <span class="hljs-keyword">on</span> Windows<br><span class="hljs-keyword">then</span> reboot <span class="hljs-keyword">into</span> Windows twice. The usage <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> /f parameter <span class="hljs-keyword">is</span> very<br>important! If <span class="hljs-keyword">the</span> device <span class="hljs-keyword">is</span> a SoftRAID/FakeRAID <span class="hljs-keyword">then</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">activate</span><br><span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> mount a different device under <span class="hljs-keyword">the</span> /dev/mapper/ directory, (e.g.<br>/dev/mapper/nvidia_eahaabcc1). Please see <span class="hljs-keyword">the</span> &#x27;dmraid&#x27; documentation<br><span class="hljs-keyword">for</span> more details.<br></code></pre></td></tr></table></figure><p>LINUX下<code>sudo ntfsfix /dev/sda1</code></p><h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h5><p>标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2</p><p>2&gt;&amp;1  意思是把 标准错误输出 重定向到 标准输出.</p><p>&amp;&gt;file  意思是把标准输出 和 标准错误输出 都重定向到文件file中</p><h5 id="查看core-dump信息"><a href="#查看core-dump信息" class="headerlink" title="查看core-dump信息"></a>查看core-dump信息</h5><p><a href="https://www.jianshu.com/p/7317910210a4">https://www.jianshu.com/p/7317910210a4</a></p><p><code>ulimit -c unlimited</code></p><p>设置core路径</p><p>方法1：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>sysctl.conf<br>    kernel.core_pattern=<span class="hljs-regexp">/tmp/</span>core-%e-%p-%t  <br>不加路径就在当前路径下生成core文件，与可执行程序的路径无关<br><br>执行：sysctl -p 让配置立刻生效。<br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br></code></pre></td></tr></table></figure><p>加载core文件，直接查看程序core dump时的堆栈信息<br>gdb  app  core_file</p><h5 id="磁盘分区和安装文件系统"><a href="#磁盘分区和安装文件系统" class="headerlink" title="磁盘分区和安装文件系统"></a>磁盘分区和安装文件系统</h5><p><a href="https://blog.csdn.net/qq_43527718/article/details/122850052">https://blog.csdn.net/qq_43527718/article/details/122850052</a></p><p>sudo fdisk &#x2F;dev&#x2F;nvme0n1</p><p>n  添加分区</p><p>p 打印分区表 查看分区成功否</p><p>w 保存</p><p>mkfs -t ext4 &#x2F;dev&#x2F;nvme0n1p1  给第一个分区安装文件系统</p><p>sudo blkid &#x2F;dev&#x2F;nvme0n1p1  查看nvme0n1p1属性</p><h5 id="命令行启动向日葵"><a href="#命令行启动向日葵" class="headerlink" title="命令行启动向日葵"></a>命令行启动向日葵</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ps -ef | <span class="hljs-keyword">grep</span> sun<br>root       <span class="hljs-number">836</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">18</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/oray_rundaemon -m server<br>root       <span class="hljs-number">856</span>   <span class="hljs-number">836</span>  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">08</span>:<span class="hljs-number">43</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/sunloginclient -m service<br><br>杀掉两个进程后执行<br>(开机自启动服务):<br>sudo systemctl start runsunloginclient.service<br>sudo systemctl enable runsunloginclient.service<br></code></pre></td></tr></table></figure><h5 id="查看所支持的-nvidia-驱动"><a href="#查看所支持的-nvidia-驱动" class="headerlink" title="查看所支持的 nvidia 驱动"></a>查看所支持的 nvidia 驱动</h5><p>ubuntu-drivers devices</p><p>recommend 可以直接用 apt 安装</p><div class="code-wrapper"><pre><code class="hljs">nvidia 驱动官网下载:https://www.nvidia.cn/Download/index.aspx?lang=cn#</code></pre></div><h5 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装cuda</h5><p>在nvidia官网选择需要的cuda版本下载<br><a href="https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal">https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal</a></p><p>安装方式选择runfile</p><p>安装后 cuda路径为&#x2F;usr&#x2F;local&#x2F;cuda-XXXX</p><h5 id="安装cudnn"><a href="#安装cudnn" class="headerlink" title="安装cudnn"></a>安装cudnn</h5><p>在nvidia官网选择需要的cudnn版本下载<br><a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>下载解压后，将文件夹内cuda&#x2F;include&#x2F;里的所有文件拷贝到&#x2F;usr&#x2F;local&#x2F;cuda-10.2&#x2F;include&#x2F;文件夹内，将cuda&#x2F;lib64&#x2F;里的所有文件拷贝到&#x2F;usr&#x2F;local&#x2F;cuda-10.2&#x2F;lib64&#x2F;文件夹内</p><h5 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h5><p>apt 的目录</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/</span>apt/<span class="hljs-keyword">source</span>.list 源列表，apt update 所使用的源<br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists index 位置，即 apt update所更新的包的标签<br><span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archive  apt-get install 下载安装包的路径<br></code></pre></td></tr></table></figure><p>命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">apt-cache show 包名，展示的是<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists 目录下所对应的标签的信息<br>apt list 当前所使用的源所能获取到的软件包(deb)<br>apt install 包<br>apt remove 包<br></code></pre></td></tr></table></figure><p>小 tip：当编译提示缺少什么库的时候的，apt list|grep 库 试下, 一般是 libxxx-dev，可以试下 apt install libxxx-dev</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类和对象的内存布局</title>
    <link href="/2021/11/01/cpp-memory-layout/"/>
    <url>/2021/11/01/cpp-memory-layout/</url>
    
    <content type="html"><![CDATA[<h3 id="用g-查看内存布局的方法："><a href="#用g-查看内存布局的方法：" class="headerlink" title="用g++查看内存布局的方法："></a>用g++查看内存布局的方法：</h3><p>&emsp;&emsp;g++ 版本&gt;8.0：<code>g++ -fdump-lang-class vptr.cpp</code><br>&emsp;&emsp;g++ 版本&lt;8.0：<code>g++ -fdump-class-hierarchy vptr.cpp</code><br><a href="https://blog.csdn.net/Ineedapassward/article/details/118417116">参考：https://blog.csdn.net/Ineedapassward/article/details/118417116</a></p><h3 id="类的内存布局"><a href="#类的内存布局" class="headerlink" title="类的内存布局"></a>类的内存布局</h3><p><a href="https://blog.csdn.net/shichao1470/article/details/91563282">参考：https://blog.csdn.net/shichao1470/article/details/91563282</a></p><h3 id="菱形继承下对象的内存布局"><a href="#菱形继承下对象的内存布局" class="headerlink" title="菱形继承下对象的内存布局"></a>菱形继承下对象的内存布局</h3><p><a href="https://blog.csdn.net/j4ya_/article/details/80177897">参考：https://blog.csdn.net/j4ya_&#x2F;article&#x2F;details&#x2F;80177897</a></p><h3 id="菱形继承下类的内存布局"><a href="#菱形继承下类的内存布局" class="headerlink" title="菱形继承下类的内存布局"></a>菱形继承下类的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;X::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Y::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">funcY</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span>: <span class="hljs-keyword">public</span> X,  <span class="hljs-keyword">public</span> Y&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Z::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(Base)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(X)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Y)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Z)&lt;&lt;endl ; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>64位系统下运行，sizeof(int *) 等于8，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">8<br>8<br>8<br>16<br></code></pre></td></tr></table></figure><p><strong>问题：</strong><br>&emsp;&emsp;类Base的size为8，是因为有一个虚表指针，<br>&emsp;&emsp;类X和类Y的size也为8，也是因为各自只有一个虚表指针？<br>&emsp;&emsp;类Z的size为16，是为甚？不采用虚继承的时候结果不变，为甚？<br>使用g++ 查看内存布局，结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Vtable <span class="hljs-keyword">for</span> Z<br>Z::_ZTV1Z: <span class="hljs-number">6</span> entries<br><span class="hljs-number">0</span>     (int <span class="hljs-comment">(*)(...))0</span><br><span class="hljs-comment">8     (int (*)</span>(...))(&amp; _ZTI1Z)<br><span class="hljs-number">16</span>    (int <span class="hljs-comment">(*)(...))Z::func</span><br><span class="hljs-comment">24    (int (*)</span>(...))-<span class="hljs-number">8</span><br><span class="hljs-number">32</span>    (int <span class="hljs-comment">(*)(...))(&amp; _ZTI1Z)</span><br><span class="hljs-comment">40    (int (*)</span>(...))Z::_ZThn8_N1Z4funcEv<br><br><span class="hljs-keyword">Class</span> Z<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br>Z (<span class="hljs-number">0</span>x0x3feb780) <span class="hljs-number">0</span><br>    vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">16</span>)<br>  X (<span class="hljs-number">0</span>x0x3feb7c0) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>      primary-<span class="hljs-keyword">for</span> Z (<span class="hljs-number">0</span>x0x3feb780)<br>    Base (<span class="hljs-number">0</span>x0x3fdca48) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> X (<span class="hljs-number">0</span>x0x3feb7c0)<br>  Y (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>      vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>    Base (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>为啥</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Y</span> (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-empty<br>    <span class="hljs-attribute">vptr</span>=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>  <span class="hljs-attribute">Base</span> (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-empty<br>      <span class="hljs-attribute">primary</span>-for Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>这里是什么东西啊？</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error_non_const_lvalue</title>
    <link href="/2021/10/31/error-non-const-lvalue/"/>
    <url>/2021/10/31/error-non-const-lvalue/</url>
    
    <content type="html"><![CDATA[<h4 id="error：cannot-bind-non-const-lvalue-reference-of-type-‘xxx-‘-to-an-rvalue-of-type-‘xxx‘"><a href="#error：cannot-bind-non-const-lvalue-reference-of-type-‘xxx-‘-to-an-rvalue-of-type-‘xxx‘" class="headerlink" title="error：cannot bind non-const lvalue reference of type ‘xxx&amp;‘ to an rvalue of type ‘xxx‘"></a>error：cannot bind non-const lvalue reference of type ‘xxx&amp;‘ to an rvalue of type ‘xxx‘</h4><p>非常量左值引用不能赋给右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base()&quot;</span>&lt;&lt;endl ; <br>    &#125;; <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base &amp;other)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base(Base &amp;other)&quot;</span>&lt;&lt;endl ; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b0 ; <br>    <span class="hljs-comment">// 三种调用拷贝构造创建对象的方式</span><br>    <span class="hljs-function">Base <span class="hljs-title">b1</span><span class="hljs-params">(b0)</span> </span>;  <br>    Base b2 = b0 ; <br>    Base b3 = <span class="hljs-built_in">Base</span>(b0) ;   <span class="hljs-comment">// 当拷贝构造函数为 Base(Base &amp;other) 而不是Base(const Base &amp;other)时，报错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原因：</strong><br>&emsp;&emsp;如果一个参数是以非const引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。但如果你把一个临时变量当作非const引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，<strong>c++ 编译器加入了临时变量不能作为非const引用的这个语义限制。</strong></p><p><a href="https://blog.csdn.net/digitalkee/article/details/105092400">参考：https://blog.csdn.net/digitalkee/article/details/105092400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缺少模板参数列表</title>
    <link href="/2021/10/28/template_typename_T/"/>
    <url>/2021/10/28/template_typename_T/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/da1fd3f3cf3244ecac3814f3e1ed0f0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* data */</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">vector</span>(<span class="hljs-comment">/* args */</span>);<br>    ~ <span class="hljs-built_in">vector</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T <span class="hljs-type">const</span>&amp; )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 不加这一行 会报错：“缺少模板参数列表”</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>参考 <a href="https://blog.csdn.net/u013891092/article/details/51583666/">https://blog.csdn.net/u013891092/article/details/51583666/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
