<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++和shell脚本的输入参数设置</title>
    <link href="/2022/11/21/cpp-shell-input-args/"/>
    <url>/2022/11/21/cpp-shell-input-args/</url>
    
    <content type="html"><![CDATA[<h2 id="c-可执行文件输入参数"><a class="markdownIt-Anchor" href="#c-可执行文件输入参数"></a> C++ 可执行文件输入参数</h2><h3 id="1-getopt_long函数"><a class="markdownIt-Anchor" href="#1-getopt_long函数"></a> 1. getopt_long()函数</h3><p>使用手册： <a href="https://linux.die.net/man/3/getopt_long">https://linux.die.net/man/3/getopt_long</a></p><h3 id="2-设置参数选项"><a class="markdownIt-Anchor" href="#2-设置参数选项"></a> 2. 设置参数选项</h3><p>参数选项的形式可以分为两种，一是 -n, 二是 --name</p><p>-n 这种需要设置短选项字符串；–name 这种需要设置长选项结构体。</p><h4 id="21-段选项字符串"><a class="markdownIt-Anchor" href="#21-段选项字符串"></a> 2.1 段选项字符串</h4><p>书写规则：</p><ul><li>多个短选项可以连在一起</li><li>如果某个要解析的选项需要一个参数，则在选项名后面跟一个冒号</li><li>如果某个要解析的选项的参数可选，则在选项名后面跟两个冒号</li></ul><p>一般如这种形式:<br /><code>const char* short_options = &quot;hx:t:c:&quot;</code><br />该字符串解释为：</p><div class="code-wrapper"><pre><code class="hljs">-h -t t_arg-c c_arg</code></pre></div><p>细心的话为发现多了h后面还有一个x:没有被说明，因为h(help)后面不需要接参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* short_options = <span class="hljs-string">&quot;hx:n:h:&quot;</span>;    <span class="hljs-comment">// 带参数的，要使用的命令，需要在这里声明</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">option</span> long_options[] = &#123;<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;,<br>        &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg-usage</title>
    <link href="/2022/09/02/ffmpeg-usage/"/>
    <url>/2022/09/02/ffmpeg-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="ffmpeg-命令行"><a class="markdownIt-Anchor" href="#ffmpeg-命令行"></a> ffmpeg 命令行</h3><p><code>ffplay -f rawvideo -pixel_format bgr24 -video_size 1280x1280 -framerate 10 video_cuda_1.rgb</code><br />播放rgb格式的视频</p><p><code>ffplay -f h264 -width 1920 -height 1080 record_424_sensor_ipcamera_h264_10_128_156_101.h264</code><br />播放 h264格式的视频</p><p><code>ffmpeg -i Free_Test_Data_15MB_MP4.h264 -framerate 30 -vcodec copy -f mp4 output.mp4</code><br />转码 h264 =&gt; mp4<br /><code>ffmpeg -i Free_Test_Data_15MB_MP4.mp4 -vcodec libx264 -acodec aac Free_Test_Data_15MB_MP4.264</code><br />转码 mp4 =&gt; h264</p>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>performace-test</title>
    <link href="/2022/08/30/performace-test/"/>
    <url>/2022/08/30/performace-test/</url>
    
    <content type="html"><![CDATA[<h3 id="nvidia-system"><a class="markdownIt-Anchor" href="#nvidia-system"></a> nvidia-system</h3>]]></content>
    
    
    
    <tags>
      
      <tag>nsight</tag>
      
      <tag>nsys</tag>
      
      <tag>sysbench</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hhd-ssd-emmc</title>
    <link href="/2022/08/30/hhd-ssd-emmc/"/>
    <url>/2022/08/30/hhd-ssd-emmc/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>HDD，即硬盘驱动器（HardDiskDrive），一般指机械硬盘；多层盘，每层一个磁头<br />SSD，即固态硬盘（Solid State Drives）；<br />EMMC，(Embedded Multi Media Card) 一种内嵌式存储器标准规格；<br />NAND，即Nand-flash，闪存的一种。<br />SSD 和 EMMC 都是基于NAND 的</p><h3 id="ssd-为什么越写越慢磁盘空间快慢时变慢"><a class="markdownIt-Anchor" href="#ssd-为什么越写越慢磁盘空间快慢时变慢"></a> ssd 为什么越写越慢?（磁盘空间快慢时变慢）</h3><p><a href="http://www.ssdfans.com/?p=90902">http://www.ssdfans.com/?p=90902</a><br />因为垃圾回收机制</p><h3 id="hhd为什么随机读写很慢"><a class="markdownIt-Anchor" href="#hhd为什么随机读写很慢"></a> hhd为什么随机读写很慢</h3><p><a href="https://zhuanlan.zhihu.com/p/20085866">https://zhuanlan.zhihu.com/p/20085866</a><br />因为磁头要来来回回移动</p><h3 id="ssd的分类"><a class="markdownIt-Anchor" href="#ssd的分类"></a> ssd的分类</h3><p><a href="https://www.kingston.com.cn/cn/community/articledetail/articleid/48543">https://www.kingston.com.cn/cn/community/articledetail/articleid/48543</a><br />SSD 技术：NVMe、SATA、M.2<br />NVMe (Non-Volatile Memory Express) 是一种通信接口和驱动程序，为基于 PCIe 的 SSD 定义了命令集和功能集<br />PICe（NVMe） 比 SATA 更快</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssd</tag>
      
      <tag>emmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-pip</title>
    <link href="/2022/08/28/python-pip/"/>
    <url>/2022/08/28/python-pip/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>有条件直接使用 conda的虚拟环境</p><h3 id="python2安装pip"><a class="markdownIt-Anchor" href="#python2安装pip"></a> python2安装pip</h3><p>wget <a href="https://bootstrap.pypa.io/pip/2.7/get-pip.py">https://bootstrap.pypa.io/pip/2.7/get-pip.py</a><br />下载成功后执行 python2 <a href="http://get-pip.py">get-pip.py</a></p><p>指定python 安装numpy库：<br />python2 -m pip install numpy</p><h3 id="python3安装-pip"><a class="markdownIt-Anchor" href="#python3安装-pip"></a> python3安装 pip</h3><p>apt install python3-pip</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc_libgcc_s.so.1</title>
    <link href="/2022/07/19/gcc-libgcc-s-so-1/"/>
    <url>/2022/07/19/gcc-libgcc-s-so-1/</url>
    
    <content type="html"><![CDATA[<h3 id="libgcc_sso1是什么"><a class="markdownIt-Anchor" href="#libgcc_sso1是什么"></a> libgcc_s.so.1是什么</h3><p><a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">The GCC low-level runtime library</a></p><p>会在有需要的时候自动启动的C 运行时库，可以替代某些机器完成整数、浮点运算，还有一些其他的功能。</p><h3 id="运行时库"><a class="markdownIt-Anchor" href="#运行时库"></a> 运行时库</h3><p>应用程序和操作系统之间的桥梁，对操作系统硬件的抽象，包括对IO 操作、程序启动和程序退出、栈等的实现。不同的操作系统对应不同的运行时库，但提供的接口基本一致，比如windows 和linux 的运行时库，都提供fread 功能，但是其实现应该是不一样的，fread 就包括在运行时库中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-usage</title>
    <link href="/2022/07/14/docker-usage/"/>
    <url>/2022/07/14/docker-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="docker-用法"><a class="markdownIt-Anchor" href="#docker-用法"></a> docker 用法</h3><p>docker教程： <a href="https://yeasy.gitbook.io/docker_practice/image/build">https://yeasy.gitbook.io/docker_practice/image/build</a></p><h3 id="运行容器"><a class="markdownIt-Anchor" href="#运行容器"></a> 运行容器</h3><p>初次运行<br /><code>docker run -itd image-id bash</code><br />//i 交互 t 终端 d 运行但不关闭，不进入docker</p><p><code>docker exec -it conatainer-id bash</code><br />// 进入docker,退出不关闭</p><p><code>docker run -id image-id bash</code><br />// 进入docker，退出关闭</p><h3 id="删除镜像和容器"><a class="markdownIt-Anchor" href="#删除镜像和容器"></a> 删除镜像和容器</h3><p><a href="https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/">https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/</a></p><p><code>docker stop container-id</code><br />// 关闭容器<br /><code>docker rm container-id</code><br />// 删除容器<br /><code>docker rmi image-id</code><br />// 删除镜像<br /><code>docker stop $(docker ps -a -q)</code><br />// 停止所有容器运行<br /><code>docker rm $(docker ps -a -q)</code><br />// 删除所有容器</p><h3 id="根据dockerfile制作镜像"><a class="markdownIt-Anchor" href="#根据dockerfile制作镜像"></a> 根据Dockerfile制作镜像</h3><p><code>docker buildx build -t hansanf/cuda-11.1:11.1.1-devel-cudnn-ubuntu18.04 --platform=x86_64 . --push</code><br />// buildx是制作多架构工具，可以不用<br />// -t tag, [仓库名]:[镜像tag]<br />// --platform buildx要制作的哪个平台的镜像<br />// . Dockerfile的路径<br />// --push 制作的镜像push到远程仓库，不会保留在本地，可以用 -o type=docker 替换</p><h3 id="pull和push"><a class="markdownIt-Anchor" href="#pull和push"></a> pull和push</h3><p><code>docker pull [仓库名]:[tag]</code></p><p><code>docker push [仓库名]:[tag]</code></p><h3 id="关闭-打开和重启docker"><a class="markdownIt-Anchor" href="#关闭-打开和重启docker"></a> 关闭、打开和重启docker</h3><p>启动<br /><code>sudo systemctl start docker</code><br />关闭<br /><code>sudo service docker stop</code></p><p>重启</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">sudo systemctl daemon-reload<span class="hljs-comment">;</span><br>sudo systemctl restart  docker<span class="hljs-comment">;</span><br>sudo sudo service docker restart<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="errors"><a class="markdownIt-Anchor" href="#errors"></a> ERRORS</h3><p>error-1<br />W: GPG error: <a href="https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease: At least one invalid signature was encountered.<br />E: The repository ‘<a href="https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64">https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64</a>  InRelease’ is not signed.<br />N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br />N: See apt-secure(8) manpage for repository creation and user configuration details.<br />W: GPG error: <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease: At least one invalid signature was encountered.<br />E: The repository ‘<a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> bionic-security InRelease’ is not signed.<br />N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br />N: See apt-secure(8) manpage for repository creation and user configuration details.<br />W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease: At least one invalid signature was encountered.<br />E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic InRelease’ is not signed.<br />N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br />N: See apt-secure(8) manpage for repository creation and user configuration details.<br />W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease: At least one invalid signature was encountered.<br />E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-updates InRelease’ is not signed.<br />N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br />N: See apt-secure(8) manpage for repository creation and user configuration details.<br />W: GPG error: <a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease: At least one invalid signature was encountered.<br />E: The repository ‘<a href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a> bionic-backports InRelease’ is not signed.<br />N: Updating from such a repository can’t be done securely, and is therefore disabled by default.<br />N: See apt-secure(8) manpage for repository creation and user configuration details.<br />硬盘空间不足了</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc-options</title>
    <link href="/2022/07/14/gcc-options/"/>
    <url>/2022/07/14/gcc-options/</url>
    
    <content type="html"><![CDATA[<h3 id="gcc-的编译选项"><a class="markdownIt-Anchor" href="#gcc-的编译选项"></a> gcc 的编译选项</h3><p>gcc官方手册：<a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a></p><p>7.5手册：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options</a></p><p>链接选项：<a href="https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options">https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options</a></p><h4 id="-fpic-和-fpie"><a class="markdownIt-Anchor" href="#-fpic-和-fpie"></a> -fPIC 和-fPIE</h4><p>-fPIC 用在动态库的编译，产生位置无关的代码</p><p>-fPIE 用在可执行程序的编译</p><p>两者在效果上一样，都是把代码中的逻辑地址转为相对地址，但是作用上不一样。<br />-fPIC一般是动态库编译必须设置的，因为可能在链接时，多个模块之间的重定向可能会出现冲突。而-fPIE在可执行程序的编译中可加可不加，其将绝对地址转为相对地址，在一定程度上提高了安全性，另外相对寻址的方式可能会让程序在启动速度慢一点。</p><p>PIE 详解：<a href="https://www.redhat.com/en/blog/position-independent-executables-pie">https://www.redhat.com/en/blog/position-independent-executables-pie</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const_cast用法</title>
    <link href="/2022/07/11/cpp-const-cast/"/>
    <url>/2022/07/11/cpp-const-cast/</url>
    
    <content type="html"><![CDATA[<h2 id="const_cast"><a class="markdownIt-Anchor" href="#const_cast"></a> const_cast</h2><p>const_cast&lt;&gt;  &lt;&gt;必须是指针或引用</p><h2 id="const-stdshared_ptrconst-class_nam去-const"><a class="markdownIt-Anchor" href="#const-stdshared_ptrconst-class_nam去-const"></a> const std::shared_ptr<const class_nam>去 const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; <span class="hljs-title">const_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(const_ptr).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//ptr-&gt;x = 100; //error</span><br>        <span class="hljs-comment">//std::shared_ptr&lt;A&gt; ptr = const_cast&lt;std::shared_ptr&lt;A&gt;&gt;(const_ptr);  //error</span><br>        std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; ptr = <span class="hljs-keyword">const_cast</span>&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; &amp;&gt;(const_ptr); <span class="hljs-comment">//必须是const_cast&lt;&amp;&gt; 必须加引用</span><br><br>        A &amp;a = <span class="hljs-built_in">const_cast</span>&lt;A &amp;&gt;(*const_ptr); <span class="hljs-comment">// const_cast&lt;&amp;&gt; 必须加引用</span><br>        a.x = <span class="hljs-number">100</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a.x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;const_ptr-&gt;x = &quot;</span> &lt;&lt; const_ptr-&gt;x &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp_mutable</title>
    <link href="/2022/07/06/cpp-mutable/"/>
    <url>/2022/07/06/cpp-mutable/</url>
    
    <content type="html"><![CDATA[<h3 id="mutable-关键字"><a class="markdownIt-Anchor" href="#mutable-关键字"></a> mutable 关键字</h3><p><a href="https://www.jianshu.com/p/b2883dbf3854">mutabel 介绍</a></p><h4 id="为什么stdmutex-前通常用mutable-修饰"><a class="markdownIt-Anchor" href="#为什么stdmutex-前通常用mutable-修饰"></a> 为什么std::mutex 前通常用mutable 修饰</h4><p>在const成员函数中，对mutex的加锁和释放锁操作会违背const的不可变语义，所以，只能将mutex定义为mutable，从而可以在const修饰的函数中加锁，实现线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cal</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Cal</span>(<span class="hljs-type">int</span> n) &#123;num = n;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc_num</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        ++num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">//const m 状态的改变会修改const 语义，但不报错？</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">mutable</span> std::mutex m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Cal c&#123;<span class="hljs-number">0</span>&#125;;<br>    std::cout &lt;&lt; c.<span class="hljs-built_in">get_num</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_debug_tools</title>
    <link href="/2022/07/05/debug-tools/"/>
    <url>/2022/07/05/debug-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="c-debug命令和工具"><a class="markdownIt-Anchor" href="#c-debug命令和工具"></a> C++ Debug命令和工具</h2><h3 id="readelf"><a class="markdownIt-Anchor" href="#readelf"></a> readelf</h3><p>查看可执行文件或库的符号表</p><figure class="highlight ada"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ada">readelf -s ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>查看可执行文件或库的动态库表</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">readelf -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="objdump"><a class="markdownIt-Anchor" href="#objdump"></a> objdump</h3><p>查看汇编情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="ldd"><a class="markdownIt-Anchor" href="#ldd"></a> ldd</h3><p>查看动态库的链接情况</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ldd ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><h3 id="ld_preload"><a class="markdownIt-Anchor" href="#ld_preload"></a> LD_PRELOAD</h3><p>在执行该文件前预加载库，要加具体的库名，LD_PRELOAD的值只在当前语句生效</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">env LD_PRELOAD=<span class="hljs-regexp">/home/</span>fenggq<span class="hljs-regexp">/libutil.so ./</span>a.out<br></code></pre></td></tr></table></figure><h3 id="查看系统默认链接的库路径"><a class="markdownIt-Anchor" href="#查看系统默认链接的库路径"></a> 查看系统默认链接的库路径</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br>    # output: include /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br>    # output: 所有的默认库路径<br></code></pre></td></tr></table></figure><h3 id="gdb"><a class="markdownIt-Anchor" href="#gdb"></a> gdb</h3><p>使用gdb调试带输入参数的程序</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gdb --<span class="hljs-keyword">args</span> ./a.<span class="hljs-keyword">out</span> <span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure><h3 id="file查看文件属性"><a class="markdownIt-Anchor" href="#file查看文件属性"></a> file查看文件属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file msf<br>msf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped<br></code></pre></td></tr></table></figure><p>该文件被stripped ，去除掉了符号表信息</p><h3 id="strip-命令"><a class="markdownIt-Anchor" href="#strip-命令"></a> strip 命令</h3><p>去掉符号表和调试等信息<br /><a href="https://blog.51cto.com/u_15614325/5272498">https://blog.51cto.com/u_15614325/5272498</a></p><p>符号表和strip <a href="https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/">https://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/</a></p><p>tmp_LD_PRELOAD={LD_PRELOAD}unset LD_PRELOADnohup cyber_launch start fusion_tracker.launch &export LD_PRELOAD={tmp_LD_PRELOAD}</p><h3 id="core文件去哪了"><a class="markdownIt-Anchor" href="#core文件去哪了"></a> core文件去哪了</h3><p><a href="https://www.jianshu.com/p/7317910210a4">core文件去哪了</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_trick</title>
    <link href="/2022/06/29/vscode-trick/"/>
    <url>/2022/06/29/vscode-trick/</url>
    
    <content type="html"><![CDATA[<h3 id="vscode-中好用的工具和小技巧"><a class="markdownIt-Anchor" href="#vscode-中好用的工具和小技巧"></a> vscode 中好用的工具和小技巧</h3><p>1、code 命令启动vscode</p><p>开启方式的 ctrl+shift+p  输入code，选择 install<br />不好用的时候，uninstall 再 install 一遍</p><p><code>code [path]</code></p><p><a href="https://blog.csdn.net/weixin_42881768/article/details/119635248">https://blog.csdn.net/weixin_42881768/article/details/119635248</a></p><p>2、语法智能补全插件</p><p><code>tabnine</code></p><p>3、</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yuv2rgb</title>
    <link href="/2022/06/29/yuv2rgb/"/>
    <url>/2022/06/29/yuv2rgb/</url>
    
    <content type="html"><![CDATA[<h1 id="yuv详解"><a class="markdownIt-Anchor" href="#yuv详解"></a> YUV详解</h1><h3 id="yuv分类"><a class="markdownIt-Anchor" href="#yuv分类"></a> YUV分类</h3><h5 id="1-按采样方式分类"><a class="markdownIt-Anchor" href="#1-按采样方式分类"></a> 1、按采样方式分类</h5><p>（1） YUV444: 全量UV，类似于RGB，每个像素点都有一套自己的YUV<br /><img src="https://img-blog.csdnimg.cn/000b2132c524457583a034fcb2bd787c.png#pic_center" alt="在这里插入图片描述" /><br />（2） YUV422: 50%的UV，与全量相比，UV数量减少一半，每行中由 2 个 Y 分量共用一套 UV 分量。<br /><img src="https://img-blog.csdnimg.cn/eea18cfb6599473aab6374a6cc7b1fc2.png#pic_center" alt="在这里插入图片描述" /></p><p>（3）YUV420: 25%的UV， UV的数量减少到1/4，每行两个Y、每列两个Y，共由 4 个 Y 分量共用一套 UV 分量。<img src="https://img-blog.csdnimg.cn/e01002399f09464e8916f4421fa5e8c0.png#pic_center" alt="在这里插入图片描述" /></p><h5 id="2-按内存中排列方式分类"><a class="markdownIt-Anchor" href="#2-按内存中排列方式分类"></a> 2、按内存中排列方式分类</h5><p>（1）Planar YUV 三个分量分开存放<br />（2）Semi-Planar Y 分量单独存放，UV 分量交错存放<br />（3）Packed YUV 三个分量全部交错存放</p><p>以YUV420为例：</p><h5 id="3-ffmpeg中h264解码后的yuv格式"><a class="markdownIt-Anchor" href="#3-ffmpeg中h264解码后的yuv格式"></a> 3、ffmpeg中h264解码后的YUV格式</h5><h3 id="yuv转rgb"><a class="markdownIt-Anchor" href="#yuv转rgb"></a> YUV转RGB</h3><p>色彩空间：<br />公式：</p><h5 id="ffmpeg接口"><a class="markdownIt-Anchor" href="#ffmpeg接口"></a> ffmpeg接口</h5><h5 id="cuda实现"><a class="markdownIt-Anchor" href="#cuda实现"></a> cuda实现</h5><p>参考：<br /><a href="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a><br /><a href="https://cloud.tencent.com/developer/article/1612357">https://cloud.tencent.com/developer/article/1612357</a><br /><a href="https://juejin.cn/post/6920848468797816846">https://juejin.cn/post/6920848468797816846</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf</title>
    <link href="/2022/06/29/protobuf/"/>
    <url>/2022/06/29/protobuf/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是protobuf"><a class="markdownIt-Anchor" href="#什么是protobuf"></a> 什么是protobuf</h2><p>Protocol Buffers(简称Protobuf) ，是Google出品的序列化框架。<br />简单来讲，就是支持序列化与反序列化，用于数据的存储、传输。<br />protobuf将数据接口定义在.proto文件中，然后再利用protoc翻译为所需要的程序语言代码（类似于接口描述语言？）</p><p><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial">官方Guide</a></p><h2 id="怎么用protobuf"><a class="markdownIt-Anchor" href="#怎么用protobuf"></a> 怎么用protobuf</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>…省略</p><h3 id="c使用"><a class="markdownIt-Anchor" href="#c使用"></a> C++使用</h3><h4 id="数据类型定义"><a class="markdownIt-Anchor" href="#数据类型定义"></a> 数据类型定义</h4><p><a href="https://blog.csdn.net/wangchong_fly/article/details/47614699">数据类型对应关系</a></p><h4 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> demo</h4><p>step-1定义.proto</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// demo_msg.proto</span><br>syntax = <span class="hljs-string">&quot;proto2&quot;</span>; <span class="hljs-comment">//版本选择，proto2 or proto3</span><br>package fgq.demo; <span class="hljs-comment">// C++中的namespace,用.分隔</span><br><br>message PersonalInfo &#123;<br>required bytes name = <span class="hljs-number">1</span>;<br>optional bytes address = <span class="hljs-number">2</span>;<br>repeated bytes friends = <span class="hljs-number">3</span>;<br>&#125;;<br><span class="hljs-comment">//等号后面是field number,从1开始计数</span><br><span class="hljs-comment">//C++中字段名不区分大小写，即name和Name，在C++接口中都是name</span><br></code></pre></td></tr></table></figure><p>step-2 将.proto翻译为.cpp和.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc -I= demo_msg.proto的目录 --cpp_out=存放.cpp和.h的目录 demo_msg.proto的路径<br></code></pre></td></tr></table></figure><p>-I参数和gcc的-I参数类似？</p><p>step-3<br />.cpp中引入.pb.h头文件，就可以使用protobuf所提供的cpp接口了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;demo_msg.pb.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">g++ main.cpp -I [--cpp_out所指定的目录]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>atomic</title>
    <link href="/2022/06/29/atomic/"/>
    <url>/2022/06/29/atomic/</url>
    
    <content type="html"><![CDATA[<h3 id="内存模型"><a class="markdownIt-Anchor" href="#内存模型"></a> 内存模型</h3><p>内存模型：指令执行顺序的模型</p><p>现代的处理器基本是并发式处理机器指令的,在一个cpu 时钟 issue 多条指令。</p><p>指令若总是严格按照书写顺序执行的，则称这样的内存模型为强顺序的(strong ordered),按照一定规则允许乱序的，称为弱顺序的(weak ordered)。</p><p>内存模型详细介绍：</p><ul><li><p><a href="https://www.zhihu.com/question/24301047">https://www.zhihu.com/question/24301047</a></p></li><li><p><a href="https://www.zhihu.com/question/24301047">https://zhuanlan.zhihu.com/p/264975254</a></p></li></ul><h3 id="c-atomix-内存顺序"><a class="markdownIt-Anchor" href="#c-atomix-内存顺序"></a> C++ atomix 内存顺序</h3><p>根据允许指令的混乱程度，C++为原子操作指定了内存顺序（memory_order），其包含6种：</p><ul><li>momory_order_relaxed,</li><li>memory_order_consume,</li><li>memory_order_acquire,</li><li>memory_order_release,</li><li>memory_order_acq_rel,</li><li>memory_order_seq_cst.</li></ul><p><img src="https://img-blog.csdnimg.cn/56a139b6a7184bd5af35c4df4610a9aa.png" alt="在这里插入图片描述" /></p><p>虽然共有 6 个选项,但它们表示的是三种内存模型:</p><p><strong>sequential consistent</strong>: memory_order_seq_cst</p><p>如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行。相当于所有的线程都用同一份内存，对同一个变量保持时刻可见</p><p><a href="https://www.zhihu.com/question/24301047">使用示例</a></p><p><strong>relaxed</strong>: memory_order_seq_cst</p><p>在同一线程内对同一变量的操作仍保持happens-before关系，但这与别的线程无关。 在 relaxed ordering 中唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排。</p><p><strong>acquire release</strong>: memory_order_consume, memory_order_acquire,<br />memory_order_release, memory_order_acq_rel</p><p>在这种序列模型下,原子 load 操作是 acquire 操作(memory_order_acquire), 原子 store 操作是release操作(memory_order_release).</p><p>原子read_modify_write操作(如fetch_add(), exchange())可以是 acquire, release 或两者皆是(memory_order_acq_rel).</p><p>同步是成对出现的,它出现在一个进行 release 操作和一个进行 acquire 操作的线程间。</p><h3 id="c-atomic-用法"><a class="markdownIt-Anchor" href="#c-atomic-用法"></a> C++ atomic 用法</h3><h3 id="atomic-和-mutex-区别"><a class="markdownIt-Anchor" href="#atomic-和-mutex-区别"></a> atomic 和 mutex 区别</h3><p>atomic 可以实现数据结构的无锁设计，为什么还要用 mutex 呢？</p><p>std::atomic原子操作，主要是保护一个变量，互斥量的保护范围更大，可以一段代码或一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cmd_ffmpeg</title>
    <link href="/2022/06/17/cmd-ffmpeg/"/>
    <url>/2022/06/17/cmd-ffmpeg/</url>
    
    <content type="html"><![CDATA[<h2 id="ffmpeg命令行使用"><a class="markdownIt-Anchor" href="#ffmpeg命令行使用"></a> ffmpeg命令行使用</h2><p><a href="https://blog.csdn.net/avsuper/article/details/54918465?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;utm_relevant_index=6">FFMPEG命令行详细参数</a></p><h3 id="两种视频格式之间的转码"><a class="markdownIt-Anchor" href="#两种视频格式之间的转码"></a> 两种视频格式之间的转码</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>callback</title>
    <link href="/2022/06/15/callback/"/>
    <url>/2022/06/15/callback/</url>
    
    <content type="html"><![CDATA[<h2 id="c回调函数"><a class="markdownIt-Anchor" href="#c回调函数"></a> C++回调函数</h2><h3 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(* func)(<span class="hljs-type">int</span>)<br>返回值类型(* 函数指针变量名)(参数)<br></code></pre></td></tr></table></figure><h3 id="stdfunction"><a class="markdownIt-Anchor" href="#stdfunction"></a> std::function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;<br>             &lt;返回值类型 (参数) &gt;<br></code></pre></td></tr></table></figure><h3 id="常见用法"><a class="markdownIt-Anchor" href="#常见用法"></a> 常见用法</h3><p>1、普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>(* cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// std::function</span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">register_func1</span>(callback);<br>    <span class="hljs-built_in">register_func2</span>(callback);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(A a, <span class="hljs-type">void</span>(A::*cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    (a.*cb)(<span class="hljs-number">100</span>); <span class="hljs-comment">// Note: 要用括号; 要带*</span><br>&#125;<br><br><span class="hljs-comment">// std::function </span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    <span class="hljs-built_in">register_func1</span>(a, &amp;A::callback); <span class="hljs-comment">// 要传入两个参数</span><br><br>    <span class="hljs-keyword">auto</span> cb = std::<span class="hljs-built_in">bind</span>(&amp;A::callback, &amp;a, std::placeholders::_1); <span class="hljs-comment">// 使用std::bind将对象地址绑定到this位置。placehoders::_1 待传入参数的占位符。</span><br>    <span class="hljs-built_in">register_func2</span>(cb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h3><p>1、函数指针是C中定义的实际函数的地址. std :: function是一个包装器,可以容纳任何类型的可调用对象(可以像函数一样使用的对象)</p><p>2、函数指针也可以和std::bind配合使用，但是std::function功能更强大，和std::bind配合更方便</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_usage</title>
    <link href="/2022/05/06/hexo-usage/"/>
    <url>/2022/05/06/hexo-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="部署hexo环境"><a class="markdownIt-Anchor" href="#部署hexo环境"></a> 部署hexo环境</h3><h3 id="设置github"><a class="markdownIt-Anchor" href="#设置github"></a> 设置github</h3><h3 id="移植到另一台电脑"><a class="markdownIt-Anchor" href="#移植到另一台电脑"></a> 移植到另一台电脑</h3><p><a href="https://baijiahao.baidu.com/s?id=1717846683433344604&amp;wfr=spider&amp;for=pc">https://www.jianshu.com/p/c3b6e7f84321</a></p><h3 id="github登录方式"><a class="markdownIt-Anchor" href="#github登录方式"></a> github登录方式</h3><p><a href="https://blog.csdn.net/nbaDWde/article/details/80360836?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https和ssh两种</a><br /><a href="https://baijiahao.baidu.com/s?id=1717846683433344604&amp;wfr=spider&amp;for=pc">https密码设置</a></p><h3 id="hexo集成到docker镜像"><a class="markdownIt-Anchor" href="#hexo集成到docker镜像"></a> hexo集成到docker镜像</h3><p><a href="https://gitee.com/LakeVilladom/docker-hexo">docker-hexo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug记录：常量值截断(truncation of constant value)</title>
    <link href="/2022/05/05/bug-truncation-of-constant-value/"/>
    <url>/2022/05/05/bug-truncation-of-constant-value/</url>
    
    <content type="html"><![CDATA[<h3 id="char和unsigned-char"><a class="markdownIt-Anchor" href="#char和unsigned-char"></a> char和unsigned char</h3><p><strong>char的取值范围</strong>：-128~127<br />  -128: 16进制0x80  二进制1000 0000<br />  -127: 16进制0xff    二进制1111 1111，注意第一位是符号位，0111 1111是127</p><p><strong>unsigned char的取值范围</strong>：0~255，16进制0x00 ~ 0xff</p><h3 id="内存中的0xf0-1111-0000"><a class="markdownIt-Anchor" href="#内存中的0xf0-1111-0000"></a> 内存中的0xf0: 1111 0000</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x = <span class="hljs-number">0xf0</span>; <span class="hljs-comment">// 十进制数大小为240，超出了127，导致常量值截断</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">0xf0</span> == x)&#123; <span class="hljs-comment">// x86机器上判断为false，arm机器上可能判断为true</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;x == 0xf0&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout&lt;&lt; <span class="hljs-string">&quot;char x= &quot;</span> &lt;&lt; x <br>&lt;&lt; <span class="hljs-string">&quot;\tunsigned char x = &quot;</span> &lt;&lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)x <br>&lt;&lt; <span class="hljs-string">&quot;\tint x = &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)x &lt;&lt; std::endl; <span class="hljs-comment">// 在不同机器上可能出现不同值</span><br></code></pre></td></tr></table></figure><p>mac(m1 arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">-16</span>  <br></code></pre></td></tr></table></figure><p>linux(x86)打印结果和上面一致</p><p>arm盒子(arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p>     char和unsigned char乱码，直接看int，一个取值-16，一个取值240</p><p><strong>取值为-16的情况：</strong></p><p>     int类型时，-16的二进制为 1000 0000| 0000 0000| 0000 0000| 0001 0000，最后一个字节是0001 0000</p><p>     而1111 0000 取反为 0000 11111，加1正好是0001 0000，即0xf0的补码是0001 0000，因此在将(char)0xf0变为int类型时的十进制数-16，至于为什么是这样的规则我也不知道。<br /><strong>取值为240的情况：</strong></p><p>     int类型时，240的二进制为 0000 0000| 0000 0000| 0000 0000| 1111 0000，最后一个字节就是1111 0000</p><p>    综上，有些机器在处理常量截断时是取补码，而有些机器是取正码，即不变。实际上，<code>char x = 0xf0</code>这种用法本身就是错误的，不应该使用，对二进制字节比较时最好选用<code>unsigned char</code>类型。</p><p>    不过，在对内存中的二进制字节进行判断时，也可以使用 if(x == (char)0xf0)这种形式。</p><p><strong>Note &amp; 猜测:</strong></p><p>     <code>char x = 0xf0</code> 虽然发生了常量截断，但是内存中的值确实是0xf0，只不过在从内存中读取出来时不同类型有不同的取值。</p><p>参考：</p><p><a href="http://www.cplusplus.com/forum/beginner/48577/">http://www.cplusplus.com/forum/beginner/48577/</a><br /><a href="https://zhidao.baidu.com/question/533897399.html">https://zhidao.baidu.com/question/533897399.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_in_mac</title>
    <link href="/2022/05/04/test-in-mac/"/>
    <url>/2022/05/04/test-in-mac/</url>
    
    <content type="html"><![CDATA[<p>a test for mac hexo<br />second test</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git_ssh_usage</title>
    <link href="/2021/11/26/git-ssh-usage/"/>
    <url>/2021/11/26/git-ssh-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="git在线练习平台"><a class="markdownIt-Anchor" href="#git在线练习平台"></a> git在线练习平台</h3><p><a href="https://learngitbranching.js.org">https://learngitbranching.js.org</a></p><p><a href="https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw">git常用命令和基本概念</a></p><h3 id="代码托管平台push-时需要的-ssh-密钥"><a class="markdownIt-Anchor" href="#代码托管平台push-时需要的-ssh-密钥"></a> 代码托管平台push 时需要的 ssh 密钥</h3><h4 id="ssh-密钥生成"><a class="markdownIt-Anchor" href="#ssh-密钥生成"></a> ssh 密钥生成</h4><ol><li>生成ssh密钥  ssh-keygen -t rsa   可以直接一路回车</li><li>打印密钥内容  cat ~/.ssh/id_rsa.pub</li><li>复制密钥到托管平台</li><li>查看.ssh/config文件，是否配置了你的ssh，没有配置不会被使用（在多人使用的情况下要注意）</li></ol><h4 id="ssh-配置"><a class="markdownIt-Anchor" href="#ssh-配置"></a> ssh 配置</h4><h5 id="多个用户时指定用户在代码托管平台所用的密钥"><a class="markdownIt-Anchor" href="#多个用户时指定用户在代码托管平台所用的密钥"></a> 多个用户时，指定用户在代码托管平台所用的密钥</h5><p>ssh-keygen 生成密钥时指定名称，比如加个后缀 .github来表示该密钥是用于github</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Host github.com<br>    User hansanf<br>    IdentityFile ~/.ssh/id_rsa.github<br></code></pre></td></tr></table></figure><h6 id="ssh-连接远程主机时别名登录和免密登录"><a class="markdownIt-Anchor" href="#ssh-连接远程主机时别名登录和免密登录"></a> ssh 连接远程主机时别名登录和免密登录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 Host fgq<br>2     HostName 主机端ip<br>3     User 主机端用户名<br>4     Port 22<br>5     IdentityFile ~/.ssh/id_rsa.remote  <span class="hljs-comment"># 连接主机所用的密钥，需要将公钥放在主机端</span><br></code></pre></td></tr></table></figure><p>将公钥放在主机端 ~/.ssh/ 目录下使用 <code>ssh-copy-id -i ~/.ssh/id_rsa.pub username@192.168.11.11</code>，或scp 传输到 .ssh 目录下, 然后就可以通过 <code>ssh fgq</code> 登录远程主机了</p><h6 id="ssh-通过跳板机登录远程主机"><a class="markdownIt-Anchor" href="#ssh-通过跳板机登录远程主机"></a> ssh 通过跳板机登录远程主机</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host fgq<br>    HostName 192.168.2.100<br>    User caros<br>    Port 22<br>    ProxyCommand ssh middle@relay  %h:%p<br><br>Host relay<br>    HostName 192.168.1.10<br>    User middle<br>    Port 22<br></code></pre></td></tr></table></figure><p>上述配置实现<code>ssh fgq</code>时先登录relay 机器，然后再登录到 fgq 主机。</p><h3 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h3><h4 id="全局配置文件"><a class="markdownIt-Anchor" href="#全局配置文件"></a> 全局配置文件</h4><p>全局配置文件有<code>~/.gitconfig</code>和<code>~/.git-credentials</code>两个</p><p><code>~/.gitconfig</code>对应着<code>git config --global</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name fgq<br> <br>//删<br>git config  --global --<span class="hljs-built_in">unset</span> user.name<br> <br>//改<br>git config --global user.name fgq<br></code></pre></td></tr></table></figure><p>比如修改GitHub账号名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config  --global  user.name hansanf<br></code></pre></td></tr></table></figure><p><code>~/.gitconfig</code>文件就会相应的做出修改<br /><img src="https://img-blog.csdnimg.cn/6e26501083b945e1a65f2c225387b949.png" alt="在这里插入图片描述" /></p><p><code>~/.git-credentials</code>中文是资格证书，里面保存github的token，使每次登陆都可以免密, 该部分应该是https token, 应该可以直接使用上面介绍的 ssh 配置，而不需要该部分操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://GitHub用户名:具体的token@github.com<br></code></pre></td></tr></table></figure><h4 id="局部配置文件"><a class="markdownIt-Anchor" href="#局部配置文件"></a> 局部配置文件</h4><p>在使用 <code>git init 文件目录</code>命令配置的git工作区中，即<code>文件目录/.git/config</code>，是局部配置文件，对应着<code>git config --local</code>命令。</p><p><code>.gitignore</code>也是只对当前工作区起作用，可以把要忽略的文件名填进去，然后Git就会自动忽略这些文件</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 不忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><h3 id="git-命令"><a class="markdownIt-Anchor" href="#git-命令"></a> git 命令</h3><h4 id="把修改删除新建文件添加到暂存区"><a class="markdownIt-Anchor" href="#把修改删除新建文件添加到暂存区"></a> 把修改/删除/新建文件添加到暂存区</h4><ul><li>修改和删除的  <code>git add -u</code>  --update</li><li>修改和新建的  <code>git add .</code></li><li>修改、删除和新建的 <code>git add -A</code> -ALL</li></ul><h4 id="add后的东西撤销"><a class="markdownIt-Anchor" href="#add后的东西撤销"></a> add后的东西撤销</h4><ul><li><code>git status</code> 查看暂存区有哪些文件</li><li><code>git reset HEAD</code> 暂存区所有文件都撤销</li><li><code>git reset HEAD /XXX/XXX.cpp</code> 撤销特定的文件</li><li>git checkout –</li></ul><p>恢复到前一个commit, 并且将当前commit 的提交全部变为 绿色 <code>git reset --soft HEAD^</code><br />恢复到前一个commit，并且将当前commit 的提交全部变为 红色 <code>git reset --mixed HEAD^</code><br />–soft 和 --mixed 不会修改文件内容，只会修改文件在仓库的状态<br />将某个文件从当前提交中删除, 有一条删除该文件的修改，但文件内容不会变 <code>git rm --cache test.txt</code></p><h4 id="提交到本地仓库repository"><a class="markdownIt-Anchor" href="#提交到本地仓库repository"></a> 提交到本地仓库（repository）</h4><p><code>git commit -m &quot;记录版本信息&quot;</code> 提交暂存区文件到本地仓库<br /><code>git log</code> 查看commit-id和所有的版本信息</p><h4 id="提交仓库后再次修改而不保留上次commit信息"><a class="markdownIt-Anchor" href="#提交仓库后再次修改而不保留上次commit信息"></a> 提交仓库后，再次修改而不保留上次commit信息</h4><ul><li><code>git commit --amend</code><br />在本地仓库内容没有合并入远程分支时，可以给上次commit的内容打补丁。打完补丁后，上次的commit-id和其版本信息都被本次的amend所覆盖<br />加上 --no-edit 可直接跳过修改comment</li></ul><h4 id="推到远程仓库合入master"><a class="markdownIt-Anchor" href="#推到远程仓库合入master"></a> 推到远程仓库，合入master</h4><ul><li><code>git push origin HEAD:refs/for/master</code><br />origin是远程仓库的代名词<br />master远程仓库的分支</li></ul><h4 id="避免push到远程合入时有冲突先拉远程最新分支"><a class="markdownIt-Anchor" href="#避免push到远程合入时有冲突先拉远程最新分支"></a> 避免push到远程合入时有冲突，先拉远程最新分支</h4><ul><li><code>git stash</code> 把本地修改的内容保存到堆栈中</li><li><code>git pull</code> 拉取远程最新代码，并merge到本地HEAD  <code>git pull = git fetch ; git merge</code></li><li><code>git stash pop</code> 修改内容从堆栈弹出<br />然后再 add，commit。这样可以基于当前的最新内容进行更改</li></ul><h4 id="merge时有冲突手动修改冲突内容"><a class="markdownIt-Anchor" href="#merge时有冲突手动修改冲突内容"></a> merge时有冲突，手动修改冲突内容</h4><p>打开冲突文件</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-section">=======</span><br>Creating a new branch is quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure><p>======= 是两个版本的冲突内容，上面是当前版本，下面是别的分支修改后的版本，删掉不需要的内容，和所有==、&gt;&gt;·HEAD。</p><p>TODO: 怎么用还不太确定<br />自动修改冲突，使用 git checkout --ours 或者 git checkout --theirs</p><h4 id="单独克隆一个分支"><a class="markdownIt-Anchor" href="#单独克隆一个分支"></a> 单独克隆一个分支</h4><p>git clone --branch 分支名 --depth 分支深度<br />单独克隆一个分支后git pull只能拉取当前分支的内容，若需要其他分支，需要先fetch到本地：git fetch origin [remote-branch]:[local-branch]</p><h4 id="打补丁"><a class="markdownIt-Anchor" href="#打补丁"></a> 打补丁</h4><p>制作补丁：git diff &gt; xxx.patch<br />检查patch文件：git apply --stat xxx.patch<br />查看补丁是否能够干净顺利地应用到当前分支中: git apply --check xxx.patch<br />将补丁合入当前分支 git apply xxx.patch</p><h3 id="git-error-解决"><a class="markdownIt-Anchor" href="#git-error-解决"></a> git error 解决</h3><h4 id="fatal-refusing-to-merge-unrelated-histories"><a class="markdownIt-Anchor" href="#fatal-refusing-to-merge-unrelated-histories"></a> fatal: refusing to merge unrelated histories</h4><p><a href="https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error">https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error</a></p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>参考：<br /><a href="https://blog.csdn.net/themagickeyjianan/article/details/79683980?spm=1001.2014.3001.5506">修改git config配置文件</a></p><p><a href="https://blog.csdn.net/Lakers2015/article/details/111990909">Git 中的.gitignore文件的作用及配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量</title>
    <link href="/2021/11/25/linux-environment-path/"/>
    <url>/2021/11/25/linux-environment-path/</url>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2><h3 id="三个文件"><a class="markdownIt-Anchor" href="#三个文件"></a> 三个文件</h3><h4 id="1-etcprofile"><a class="markdownIt-Anchor" href="#1-etcprofile"></a> 1. <code>/etc/profile</code></h4><p>系统级别，可以所有用户起作用，网上有说是在用户登录时读取的。但在我电脑上使用<code>source /etc/profile</code>后只在当前终端起作用，新建终端仍不生效，为了以后在每个终端上都生效可以在<code>~/.bashrc</code>中添加<code>source /etc/profile</code>。<br />注意<code>~/.bashrc</code>和<code>/etc/profile</code>中还包括对终端其他方面的设置，比如显示格式、颜色</p><h4 id="2-etcenvironment"><a class="markdownIt-Anchor" href="#2-etcenvironment"></a> 2. <code>/etc/environment</code></h4><p>系统级别，应该是专门用于设置环境变量的，据说优先级高于<code>/etc/profile</code>，没验证过。</p><h4 id="3-~bashrc"><a class="markdownIt-Anchor" href="#3-~bashrc"></a> 3. <code>~/.bashrc</code></h4><p>只对当前用户生效，在个人电脑上直接修改这个文件即可，简单省事。</p><h3 id="环境变量书写格式"><a class="markdownIt-Anchor" href="#环境变量书写格式"></a> 环境变量书写格式</h3><p>最好在文件末尾添加</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin:/usr/bin<br></code></pre></td></tr></table></figure><p><code>PATH</code>表示环境变量，等号两边不要有空格（shell语法，赋值时等号两边不能有空格）<br /><code>$PATH</code>表示取变量值，即如果上面定义了<code>PATH</code>，可以直接引用上面定义好的环境变量，所以这也是为什么要加在文件末尾<br /><code>:</code>为分隔符，每一个环境变量的路径都要用<code>:</code>分开</p><p>上面这段代码等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin<br>PATH=<span class="hljs-variable">$PATH</span>:/usr/bin<br></code></pre></td></tr></table></figure><p>修改好后，使用source使其生效</p><h3 id="3export命令"><a class="markdownIt-Anchor" href="#3export命令"></a> 3.export命令</h3><p>export命令使环境变量在当前终端生效，关闭终端后失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:环境变量路径<br></code></pre></td></tr></table></figure><p>注意，一定要加上<code>$PATH</code>,否则会使已有的环境变量全都失效，只剩下新添加的</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ln命令</title>
    <link href="/2021/11/25/cmd-ln/"/>
    <url>/2021/11/25/cmd-ln/</url>
    
    <content type="html"><![CDATA[<h3 id="ln命令"><a class="markdownIt-Anchor" href="#ln命令"></a> ln命令</h3><h4 id="格式和参数"><a class="markdownIt-Anchor" href="#格式和参数"></a> 格式和参数</h4><p>语法格式： ln [参数] <strong>[源</strong>文件或目录] [<strong>目标</strong>文件或目录]<br />ln a b  a=&gt;b</p><table><thead><tr><th>参数</th><th>全称</th><th>作用</th></tr></thead><tbody><tr><td>空</td><td>hard</td><td>对源文件建立硬链接</td></tr><tr><td>-s</td><td>soft</td><td>对源文件建立软连接（符号链接）</td></tr><tr><td>-f</td><td>force</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-b</td><td>backup</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr><td>-i</td><td>Interactive</td><td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td></tr><tr><td>-v</td><td>verbose</td><td>详细信息模式，输出指令的详细执行过程</td></tr><tr><td>-d</td><td>direction</td><td>此选项允许“root”用户建立目录的硬链接</td></tr></tbody></table><h4 id="软连接-硬链接和拷贝的区别"><a class="markdownIt-Anchor" href="#软连接-硬链接和拷贝的区别"></a> 软连接、硬链接和拷贝的区别</h4><p><strong>软连接：</strong></p><ul><li>链接文件内存储的是原文件的inode，也就是说是用来指向原文件文件，这<strong>两个文件的inode是不一样</strong>的</li><li>软链接以路径的形式存在，类似于Windows操作系统中的快捷方式。</li><li>删除软链接的链接文件，被链接文件不会受到任何影响，但是修改软链接文件内容，被链接文件内容也会被修改</li><li>软链接可以跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接不可以。</li><li>软链接可以对目录进行链接，硬链接不可以。</li><li>删除软链接的被链接文件，链接文件会变成红色，这时打开链接文件会报错，报找不到被链接的文件这种错误</li></ul><p><strong>硬连接：</strong><br />-硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件，这两个文件的<strong>inode号是同一个</strong>（ls -i）</p><ul><li>硬链接以文件副本的形式存在，但不占用实际空间。</li><li>硬链接不允许普通用户给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li></ul><blockquote><p>A硬链B 删除B后A依然存在，且可用。<br />A软链B 删除B后A存在，但不可用了（相当于Windows下快捷方式指向的目标不存在了）</p></blockquote><p><strong>拷贝：</strong></p><ul><li>拷贝产生的文件是一个独立的文件，有自己的元信息和inode节点</li></ul><blockquote><p>软连接和硬链接在使用时用哪一个，主要看是否需要链接目录，是否依赖相对路径，没有限制条件两者应该都可以使用。</p></blockquote><p>参考：<br /><a href="https://www.linuxcool.com/ln">linux命令大全</a><br /><a href="https://blog.csdn.net/geerniya/article/details/79093301">软链接、硬链接与复制的区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++可变参数</title>
    <link href="/2021/11/24/cpp-variable-arguments/"/>
    <url>/2021/11/24/cpp-variable-arguments/</url>
    
    <content type="html"><![CDATA[<h3 id="参数列表的"><a class="markdownIt-Anchor" href="#参数列表的"></a> 参数列表的…</h3><p>… 表示函数的参数个数可变，典型的如<code>printf()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * szFormat, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br><span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ; <br></code></pre></td></tr></table></figure><h3 id="使用实现变参数函数的两种场景"><a class="markdownIt-Anchor" href="#使用实现变参数函数的两种场景"></a> 使用…实现变参数函数的两种场景</h3><h4 id="1-格式化字符串"><a class="markdownIt-Anchor" href="#1-格式化字符串"></a> 1. 格式化字符串</h4><blockquote><p><strong>使用场景：</strong><br />类似于实现一个printf，输入一串格式化的字符串，经过处理后可以将 %s %f %d等占位符替换为对应的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, va_list ap)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">vasprintf</span>(&amp;buf, format, ap); <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>  <span class="hljs-comment">// 重载了func函数，不重载也行</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list ap;<br>    <span class="hljs-type">char</span> *res = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-built_in">va_start</span>(ap, format);<br>    res = <span class="hljs-built_in">func</span>(format, ap);  <br>    <span class="hljs-built_in">va_end</span>(ap);<br>    <span class="hljs-keyword">return</span> res ;  <br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br>    <span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %s \n&quot;</span>, str) ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果<br>result: info &#123;name:fgq, age:<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br />上面func()函数重载了，如果不是类成员函数，要注意函数定义的顺序，在func(const char* format, …)里要调用<code>func(const char* format, va_list ap)</code> ，因此<code>func(const char* format, ...)</code>要定义在后面。类内成员函数则可以是任意顺序。</p></blockquote><p>实际上完成占位符替换为数据的是<code>int vasprintf (char **buf, const char *format, va_list ap)</code>函数：<br /><code>buf</code>：一个用于保存结果的字符串缓冲区<br /><code>format</code>：一个格式化字符串<br /><code>ap</code>:va_list类型的变量, va_list是一个宏，和va_start(va_list, arg)、va_arg(va_list, type)、va_end(va_list)这些宏在定义在头文件stdarg.h中，下面详细介绍通过这些宏来实现可变参数函数</p><h4 id="2执行时指定可变参数类型"><a class="markdownIt-Anchor" href="#2执行时指定可变参数类型"></a> 2.执行时指定可变参数类型</h4><blockquote><p><strong>使用场景：</strong><br />将n个数进行相加，此时n是不确定的，如果用重载方法，可能要重载很多次，如下面的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例子：<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2, <span class="hljs-type">double</span> d3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br></code></pre></td></tr></table></figure><p>使用可变参数的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;  <span class="hljs-comment">//格式:count代表参数个数, ...代表n个参数</span><br> <br>va_list ap;  <span class="hljs-comment">//声明一个va_list变量</span><br><span class="hljs-built_in">va_start</span>(ap, count);  <span class="hljs-comment">//第二个参数表示形参的个数</span><br> <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <span class="hljs-comment">// 按顺序返回参数列表中的参数</span><br>res += <span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>);   <span class="hljs-comment">//第二个参数表示形参类型</span><br>&#125;<br><br><span class="hljs-built_in">va_end</span>(ap);  <span class="hljs-comment">//用于清理</span><br> <br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">输出结果：<br>6<br></code></pre></td></tr></table></figure><h3 id="使用initializer_list实现变参函数"><a class="markdownIt-Anchor" href="#使用initializer_list实现变参函数"></a> 使用initializer_list实现变参函数</h3><p><code>initializer_list</code>是一个列表初始化容器，声明在initializer_list头文件中，可以采用迭代器的方式来遍历参数列表，克服了<code>...</code>需要指定参数个数的缺点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initializerSum</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; il)</span> </span>&#123;<br>   <br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = il.<span class="hljs-built_in">begin</span>(); ptr != il.<span class="hljs-built_in">end</span>(); ptr++)  <span class="hljs-comment">//类似于容器的操作</span><br>&#123;<br>sum += *ptr;<br>&#125;<br> <br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">initializerSum</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) ;  <span class="hljs-comment">// 初始化 initializer_list&lt;int&gt;</span><br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il &#123;<span class="hljs-number">1</span>&#125; ;<br>    res = <span class="hljs-built_in">initializerSum</span>(il);<br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    <span class="hljs-function">std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ill</span> <span class="hljs-params">(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)</span> </span>;<br>    res = <span class="hljs-built_in">initializerSum</span>(ill);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <br>    <span class="hljs-keyword">auto</span> illl = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    res = <span class="hljs-built_in">initializerSum</span>(illl);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br /><a href="http://en.cppreference.com/w/cpp/utility/initializer_list">cppreference对inittializer_list的介绍</a></p><p><a href="https://blog.csdn.net/baidu_15952103/article/details/105886761">va_list函数学习（va_start，va_end, vasprintf）</a></p><p><a href="https://blog.csdn.net/alex1997222/article/details/78639991">C++可变参数的两种方法</a></p><p><a href="https://blog.csdn.net/anye3000/article/details/6593551">printf,sprintf,vsprintf 区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++宏的使用技巧</title>
    <link href="/2021/11/23/marco-tips/"/>
    <url>/2021/11/23/marco-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="宏的使用技巧"><a class="markdownIt-Anchor" href="#宏的使用技巧"></a> 宏的使用技巧</h3><blockquote><p>1、在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义<br />2、\ 用来换行<br />3、 # 把变量变为字符串</p></blockquote><h4 id="1在switch中使代码更简洁"><a class="markdownIt-Anchor" href="#1在switch中使代码更简洁"></a> 1.在switch中使代码更简洁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br><span class="hljs-keyword">switch</span>(level)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XX(i,name) \</span><br><span class="hljs-meta">case i: \</span><br><span class="hljs-meta">return name; \</span><br><span class="hljs-meta"></span><br><span class="hljs-built_in">XX</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>) ; <br><span class="hljs-built_in">XX</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;INFO&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;WARN&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;ERROR&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;FATAL&quot;</span>) ;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> XX</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2把变量变为字符串"><a class="markdownIt-Anchor" href="#2把变量变为字符串"></a> 2.#把变量变为字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1000</span> ; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(a)&lt;&lt;endl; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(b)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式</title>
    <link href="/2021/11/19/template_pattern/"/>
    <url>/2021/11/19/template_pattern/</url>
    
    <content type="html"><![CDATA[<h3 id="模板模式"><a class="markdownIt-Anchor" href="#模板模式"></a> 模板模式</h3><p><strong>意图:</strong> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决:</strong> 一些方法通用，却在每一个子类都重新写了这一方法。</p><blockquote><p><strong>例子</strong><br />建造房子的流程都是一样的，比如：打地基-&gt;砌砖头-&gt;盖屋顶<br />但是不同种类的房子，比如茅草房和别墅，在这三个步骤中所要做的具体事情不一样<br />此时就可以应用模板模式，在接口类（基类）中抽象出统一的流程，在子类中再重写具体步骤的方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IGame</span>&#123;  <span class="hljs-comment">// 接口类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-comment">//模板：固定不变的部分，定义统一的游戏流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">initialize</span>();<br>        <span class="hljs-built_in">startPlay</span>();<br>        <span class="hljs-built_in">endPlay</span>(); <br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IGame</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basketball</span>:<span class="hljs-keyword">public</span> IGame&#123;  <br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Basketball</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Football</span>:<span class="hljs-keyword">public</span> IGame&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Football</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    IGame *pb ;  <br>    Basketball basketball ; <br>    Football Football ; <br>    pb = &amp;basketball ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    pb = &amp;Football ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打印输出：<br><br><span class="hljs-keyword">Basketball </span>initialize<br><span class="hljs-keyword">Basketball </span>startPlay<br><span class="hljs-keyword">Basketball </span>endPlay<br>Football initialize<br>Football startPlay<br>Football endPlay<br></code></pre></td></tr></table></figure><hr /><p><strong>总结：</strong><br />模板模式在类库的设计中很常见，在模板模式中，库设计者会给使用者提供固定的流程和需要重写的接口，使用者通常只需要：<br />1、继承父类；<br />2、重写某一个或某几个接口；<br />3、调用包含了所有流程的方法，比如<code>play()</code></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的设计原则和分类</title>
    <link href="/2021/11/19/design-pattern-priciple-classification/"/>
    <url>/2021/11/19/design-pattern-priciple-classification/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式的设计原则和分类"><a class="markdownIt-Anchor" href="#设计模式的设计原则和分类"></a> 设计模式的设计原则和分类</h2><h3 id="设计原则"><a class="markdownIt-Anchor" href="#设计原则"></a> 设计原则</h3><h4 id="1-依赖倒置原则dip"><a class="markdownIt-Anchor" href="#1-依赖倒置原则dip"></a> 1、依赖倒置原则（DIP）</h4><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul><h4 id="2-开放封闭原则ocp"><a class="markdownIt-Anchor" href="#2-开放封闭原则ocp"></a> 2、开放封闭原则（OCP）</h4><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><h4 id="3-单一职责原则srp"><a class="markdownIt-Anchor" href="#3-单一职责原则srp"></a> 3、单一职责原则（SRP）</h4><ul><li>一个类应该仅有一个引起他变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h4 id="4-liskov替换原则lsp"><a class="markdownIt-Anchor" href="#4-liskov替换原则lsp"></a> 4、Liskov替换原则（LSP）</h4><ul><li>子类必须能够替换他们的基类（IS-A）。</li><li>继承表达类型抽象。</li></ul><h4 id="5-接口隔离原则isp"><a class="markdownIt-Anchor" href="#5-接口隔离原则isp"></a> 5、接口隔离原则（ISP）</h4><ul><li>不应该强迫客户程序依赖他们不用的方法。</li><li>接口应该小而完备。</li></ul><h4 id="6-迪米特洛原则最少知识原则"><a class="markdownIt-Anchor" href="#6-迪米特洛原则最少知识原则"></a> 6、迪米特洛原则（最少知识原则）</h4><ul><li>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</li><li>优先使用对象组合，而不是类继承。类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><h4 id="7-封装变化点"><a class="markdownIt-Anchor" href="#7-封装变化点"></a> 7、封装变化点</h4><ul><li>使用封装来创建对象之间的分解层，让设计者可以在分层的一侧进行修改，而不会对另一侧产生不良的影响，减少层次间的耦合。</li></ul><h4 id="8-针对接口抽象类编程而不是针对实现编程"><a class="markdownIt-Anchor" href="#8-针对接口抽象类编程而不是针对实现编程"></a> 8、针对接口（抽象类）编程，而不是针对实现编程</h4><ul><li>不将变量类型生命为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无须获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”。</li><li>和依赖倒置原则相辅相成。</li></ul><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>三分类：<a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a></p><p>李建忠老师的九分类：</p><table><thead><tr><th>模式分类</th><th>包括</th></tr></thead><tbody><tr><td><strong>组件协作</strong></td><td>模板模式<br>策略模式<br>观察者模式</td></tr><tr><td><strong>单一职责</strong></td><td>装饰者模式<br> 桥接模式</td></tr><tr><td><strong>对象创建</strong></td><td>工厂模式<br>抽象工厂模式<br>原型模式<br>建造者模式</td></tr><tr><td><strong>对象性能</strong></td><td>单例模式<br>享元模式</td></tr><tr><td><strong>接口隔离</strong></td><td>门面模式<br>代理模式<br>适配器模式<br>中介者模式</td></tr><tr><td><strong>状态变化</strong></td><td>状态模式<br>备忘录模式</td></tr><tr><td><strong>数据结构</strong></td><td>组合模式<br>迭代器模式<br>职责链模式</td></tr><tr><td><strong>行为变化</strong></td><td>命令模式<br>访问器模式</td></tr><tr><td><strong>领域问题</strong></td><td>解析器模式</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_opencv</title>
    <link href="/2021/11/12/vscode-opencv/"/>
    <url>/2021/11/12/vscode-opencv/</url>
    
    <content type="html"><![CDATA[<h3 id="win10-vscode-加载opencv库"><a class="markdownIt-Anchor" href="#win10-vscode-加载opencv库"></a> win10 vscode 加载opencv库</h3><p>从头到尾的配置：<br />1、Visual Studio Code 配置<br />2、openCV 配置<br />3、MinGw 配置<br />4、cmake 配置<br />完整过程参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>如果使用vscode已经可以编译c++程序了，即可以省略掉大部分vscode和的MinGW的配置过程（只要vscode中配置好opencv的头文件路径和库路径即可）</p><p>opencv的配置过程，实际上就是库的加载过程，如果是已经编译好的opencv库，只要配置好头文件路径和库文件路径即可，如果是下载的源文件，则需要通过cmake进行编译。<br />cmake编译opencv参考：<a href="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>opencv已经编译好了之后，把头文件路径和库文件路径加到系统的环境变量中。</p><p>最后配置vscode的三个.json文件：<code>launch.json</code>、<code>tasks.json</code>、<code>c_cpp_properties.json</code></p><p>各自的配置如下：<br /><code>launch.json</code>：主要注意<strong>miDebuggerPath</strong>和<strong>program</strong>两项</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">Use</span> <span class="hljs-string">IntelliSense</span> <span class="hljs-string">to</span> <span class="hljs-string">learn</span> <span class="hljs-string">about</span> <span class="hljs-string">possible</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">Hover</span> <span class="hljs-string">to</span> <span class="hljs-string">view</span> <span class="hljs-string">descriptions</span> <span class="hljs-string">of</span> <span class="hljs-string">existing</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-string">more</span> <span class="hljs-string">information</span>, <span class="hljs-attr">visit:</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        <br>        <br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;:</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;:</span> [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;:</span> [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;:</span> <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gdb.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;:</span> [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;:</span> <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tasks.json</code>：<br />主要修改<strong>args</strong>中大i、大L和小l<br />这里实际上就是g++ -I 头文件路径 -L 库文件路径 -l 库文件名<br />注意实际库文件的命名和这里写库文件名的区别   实际库文件名=lib库文件名.dll.a</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">See</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">documentation</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">tasks.json</span> <span class="hljs-string">format</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;command&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>    <span class="hljs-attr">&quot;args&quot;:</span> [<br>        <span class="hljs-string">&quot;-g&quot;</span>, <br>        <span class="hljs-string">&quot;-std=c++11&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <br>        <span class="hljs-string">&quot;-o&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,  <br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>,<br>        <span class="hljs-string">&quot;-L&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\x64\\MinGW\\lib&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_core3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_dnn3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_features2d3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_flann3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_highgui3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgcodecs3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgproc3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ml3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_objdetect3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_photo3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_shape3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_stitching3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_superres3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_video3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videoio3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videostab3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ts3416&quot;</span><br><br>  <br>    ],<span class="hljs-string">//</span> <span class="hljs-string">编译命令参数</span><br>    <span class="hljs-string">&quot;problemMatcher&quot;</span><span class="hljs-string">:</span>&#123;<br>        <span class="hljs-attr">&quot;owner&quot;:</span> <span class="hljs-string">&quot;cpp&quot;</span>,<br>        <span class="hljs-string">&quot;fileLocation&quot;</span><span class="hljs-string">:</span>[<br>            <span class="hljs-string">&quot;relative&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;pattern&quot;</span><span class="hljs-string">:</span>[<br>            &#123;<br>                <span class="hljs-attr">&quot;regexp&quot;:</span> <span class="hljs-string">&quot;^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$&quot;</span>,<br>                <span class="hljs-attr">&quot;file&quot;:</span> <span class="hljs-number">1</span>,<br>                <span class="hljs-attr">&quot;location&quot;:</span> <span class="hljs-number">2</span>,<br>                <span class="hljs-attr">&quot;message&quot;:</span> <span class="hljs-number">3</span><br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;group&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;kind&quot;:</span> <span class="hljs-string">&quot;build&quot;</span>,<br>        <span class="hljs-attr">&quot;isDefault&quot;:</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><p><code>c_cpp_properties.json</code>：<br />主要修改<strong>includePath</strong>和<strong>compilerPath</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;win&quot;</span>,<br>            <span class="hljs-attr">&quot;includePath&quot;:</span> [<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>         <br>            ],<br>            <span class="hljs-attr">&quot;defines&quot;:</span> [],<br>            <span class="hljs-attr">&quot;compilerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gcc.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;cStandard&quot;:</span> <span class="hljs-string">&quot;c11&quot;</span>,<br>            <span class="hljs-attr">&quot;cppStandard&quot;:</span> <span class="hljs-string">&quot;c++17&quot;</span>,<br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;:</span> <span class="hljs-string">&quot;clang-x64&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不是完全照搬上述的配置，需要注意：</p><ul><li><code>launch.json</code>的<strong>preLaunchTask</strong>和<code>tasks.json</code>中的<strong>label</strong>内容需要一致，否则报错，比如修改<code>launch.json</code>的<strong>preLaunchTask</strong>为g++.exe，则会报错<br /><img src="https://img-blog.csdnimg.cn/0539074e59fe455882f429a521c318b4.png" alt="在这里插入图片描述" /><br />三个json文件的作用：<br /><code>tasks.json</code> (build instructions)<br /><code>launch.json</code> (debugger settings)<br /><code>c_cpp_properties.json</code> (compiler path and IntelliSense settings</li></ul><p>vscode配置官方教程：<a href="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之类图表示</title>
    <link href="/2021/11/07/UML/"/>
    <url>/2021/11/07/UML/</url>
    
    <content type="html"><![CDATA[<h3 id="类图属性"><a class="markdownIt-Anchor" href="#类图属性"></a> 类图属性</h3><p>一个大矩形里面分三层：</p><ul><li>类名</li><li>成员名：可见性 名称 ：类型 [ = 默认值]</li><li>方法名：可见性  名称(参数列表) [ ： 返回类型]<br /><img src="https://img-blog.csdnimg.cn/c59f02761f6b4d5c926297de49d48cfa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></li></ul><p>可见性：</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected（friendly也归入这类）</li></ul><h3 id="类之间关系"><a class="markdownIt-Anchor" href="#类之间关系"></a> 类之间关系</h3><h4 id="1-依赖"><a class="markdownIt-Anchor" href="#1-依赖"></a> 1、依赖</h4><p>依赖关系使用<strong>带箭头的虚线</strong>来表示，箭头从使用类指向被依赖的类。</p><p><strong>人依赖手机：</strong><br /><img src="https://img-blog.csdnimg.cn/f53bd1f094a946b9a8121fe7f7c3beb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /><br />依赖（Dependency）关系是一种<strong>使用关系</strong>，它是对象之间耦合度最弱的一种关联方式，被使用对象的有无，不影响使用对象，是临时性的关联。</p><h4 id="2-关联"><a class="markdownIt-Anchor" href="#2-关联"></a> 2、关联</h4><p>依赖关系使用<strong>带箭头的实线</strong>来表示，箭头从使用类指向被关联的类，可以单向关联，也可以双向关联。</p><p>双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示。</p><p><strong>老师和学生双向关联：<strong>每个老师可以教多个学生，每个学生也可向多个老师学<br /><img src="https://img-blog.csdnimg.cn/59ed529d91fb40fcb133824a7fc0f59b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /><br />关联（Association）关系是对象之间的一种</strong>引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。被引用者不存在时，引用者可以存在，但是没有意义。</p><h4 id="3-聚合"><a class="markdownIt-Anchor" href="#3-聚合"></a> 3、聚合</h4><p>聚合关系可以用<strong>带空心菱形的实线</strong>来表示，菱形指向整体。</p><p><strong>大学包含教师：</strong><br /><img src="https://img-blog.csdnimg.cn/5979cb34f002423bb819274d3a3798d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是<strong>整体和部分之间的关系</strong>，是 has-a 的关系。当部分类不存在，整体类也不能存在，但是部分可以脱离整体而独立存在。比如大学不能脱离教师而存在，但是没有大学教师依然能够独立存在。</p><h4 id="4-组合"><a class="markdownIt-Anchor" href="#4-组合"></a> 4、组合</h4><p>组合关系用<strong>带实心菱形的实线来表示</strong>，菱形指向整体<br /><strong>头和嘴：</strong><br /><img src="https://img-blog.csdnimg.cn/9accac46ce1d4eb382cdf8d1c00623b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象也不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><h4 id="5-泛化"><a class="markdownIt-Anchor" href="#5-泛化"></a> 5、泛化</h4><p>泛化关系用<strong>带空心三角箭头的实线</strong>来表示，箭头从子类指向父类。</p><p><strong>人和学生、老师：</strong><br /><img src="https://img-blog.csdnimg.cn/b27b8f34dcfd4134b179533991d8d045.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是<strong>父类与子类之间的关系，是一种继承关系</strong>，是 is-a 的关系。</p><h4 id="6-实现"><a class="markdownIt-Anchor" href="#6-实现"></a> 6、实现</h4><p>实现关系使用<strong>带空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><strong>鸟和飞：</strong><br /><img src="https://img-blog.csdnimg.cn/2380c43ba2dc4c07b395882e3930059c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p><p>实现（Realization）关系是<strong>接口与实现类之间的关系</strong>。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。可以将实现类看做方法。</p><p>参考：<br /><a href="https://www.cnblogs.com/shindo/p/5579191.html">https://www.cnblogs.com/shindo/p/5579191.html</a><br /><a href="https://blog.csdn.net/sinat_21107433/article/details/102576624">https://blog.csdn.net/sinat_21107433/article/details/102576624</a><br /><a href="http://c.biancheng.net/view/1319.html">http://c.biancheng.net/view/1319.html</a><br /><a href="https://www.jianshu.com/p/641682f9c918">https://www.jianshu.com/p/641682f9c918</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update_nodejs</title>
    <link href="/2021/11/01/update-nodejs/"/>
    <url>/2021/11/01/update-nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu升级nodejs"><a class="markdownIt-Anchor" href="#ubuntu升级nodejs"></a> Ubuntu升级nodejs</h2><h3 id="下载nodejs压缩文件"><a class="markdownIt-Anchor" href="#下载nodejs压缩文件"></a> 下载nodejs压缩文件</h3><p>打开nodejs官网，打开<code>DOWNLOADS</code>页面，选择一个版本，右键复制链接地址，然后使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">wget https://nodejs.org/dist/v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><p>下载到本地</p><h3 id="解压"><a class="markdownIt-Anchor" href="#解压"></a> 解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><h3 id="将node和npm设置为全局"><a class="markdownIt-Anchor" href="#将node和npm设置为全局"></a> 将node和npm设置为全局</h3><p>将新的node可执行文件<strong>硬链接</strong>到/usr/local/bin/node,如果提示连接已存在，可将/usr/local/bin/node删掉，再重新连接(删除前建议先备份)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/node /usr/local/bin/node<br> <br>sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/npm /usr/local/bin/npm  <br></code></pre></td></tr></table></figure><p><strong>/bin/usr和/bin/local/usr的区别：</strong><br />   /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。<br />   /usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。<br />   /如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fgq@ubuntu:~/hexo_blog$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br></code></pre></td></tr></table></figure><p>   这里/usr/local/bin优先于/usr/bin, 一般都是如此</p><p><strong>另外一种设为全局的方法：使用别名alias</strong></p><p>当前终端生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> node=解压后路径/node-v16.13.0-linux-x64/bin/node<br><span class="hljs-built_in">alias</span> npm=解压后路径/node-v16.13.0-linux-x64/bin/npm<br></code></pre></td></tr></table></figure><p>永久生效：<br />  修改主目录下.bashrc文件(~/.bashrc)，添加上述两句<br />   然后 <code>source ~/.bashrc</code><br /><strong>note:</strong> 等号两边没有空格</p><blockquote><p>node和nodejs之间没有区别，node全称就是nodejs。nodejs是一个基于Chrome V8引擎的JavaScript运行环境</p></blockquote><p>参考：<br /><a href="https://blog.csdn.net/qq_37035946/article/details/99451703">1、https://blog.csdn.net/qq_37035946/article/details/99451703</a><br /><a href="https://blog.csdn.net/nzjdsds/article/details/88345400">2、https://blog.csdn.net/nzjdsds/article/details/88345400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux_tips</title>
    <link href="/2021/11/01/linux-tips/"/>
    <url>/2021/11/01/linux-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> linux</h3><p>for linux tips</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类和对象的内存布局</title>
    <link href="/2021/11/01/cpp-memory-layout/"/>
    <url>/2021/11/01/cpp-memory-layout/</url>
    
    <content type="html"><![CDATA[<h3 id="用g查看内存布局的方法"><a class="markdownIt-Anchor" href="#用g查看内存布局的方法"></a> 用g++查看内存布局的方法：</h3><p>  g++ 版本&gt;8.0：<code>g++ -fdump-lang-class vptr.cpp</code><br />  g++ 版本&lt;8.0：<code>g++ -fdump-class-hierarchy vptr.cpp</code><br /><a href="https://blog.csdn.net/Ineedapassward/article/details/118417116">参考：https://blog.csdn.net/Ineedapassward/article/details/118417116</a></p><h3 id="类的内存布局"><a class="markdownIt-Anchor" href="#类的内存布局"></a> 类的内存布局</h3><p><a href="https://blog.csdn.net/shichao1470/article/details/91563282">参考：https://blog.csdn.net/shichao1470/article/details/91563282</a></p><h3 id="菱形继承下对象的内存布局"><a class="markdownIt-Anchor" href="#菱形继承下对象的内存布局"></a> 菱形继承下对象的内存布局</h3><p><a href="https://blog.csdn.net/j4ya_/article/details/80177897">参考：https://blog.csdn.net/j4ya_/article/details/80177897</a></p><h3 id="菱形继承下类的内存布局"><a class="markdownIt-Anchor" href="#菱形继承下类的内存布局"></a> 菱形继承下类的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;X::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Y::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">funcY</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span>: <span class="hljs-keyword">public</span> X,  <span class="hljs-keyword">public</span> Y&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Z::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(Base)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(X)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Y)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Z)&lt;&lt;endl ; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>64位系统下运行，sizeof(int *) 等于8，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">8<br>8<br>8<br>16<br></code></pre></td></tr></table></figure><p><strong>问题：</strong><br />  类Base的size为8，是因为有一个虚表指针，<br />  类X和类Y的size也为8，也是因为各自只有一个虚表指针？<br />  类Z的size为16，是为甚？不采用虚继承的时候结果不变，为甚？<br />使用g++ 查看内存布局，结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Vtable <span class="hljs-keyword">for</span> Z<br>Z::_ZTV1Z: <span class="hljs-number">6</span> entries<br><span class="hljs-number">0</span>     (int <span class="hljs-comment">(*)(...))0</span><br><span class="hljs-comment">8     (int (*)</span>(...))(&amp; _ZTI1Z)<br><span class="hljs-number">16</span>    (int <span class="hljs-comment">(*)(...))Z::func</span><br><span class="hljs-comment">24    (int (*)</span>(...))-<span class="hljs-number">8</span><br><span class="hljs-number">32</span>    (int <span class="hljs-comment">(*)(...))(&amp; _ZTI1Z)</span><br><span class="hljs-comment">40    (int (*)</span>(...))Z::_ZThn8_N1Z4funcEv<br><br><span class="hljs-keyword">Class</span> Z<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br>Z (<span class="hljs-number">0</span>x0x3feb780) <span class="hljs-number">0</span><br>    vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">16</span>)<br>  X (<span class="hljs-number">0</span>x0x3feb7c0) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>      primary-<span class="hljs-keyword">for</span> Z (<span class="hljs-number">0</span>x0x3feb780)<br>    Base (<span class="hljs-number">0</span>x0x3fdca48) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> X (<span class="hljs-number">0</span>x0x3feb7c0)<br>  Y (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>      vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>    Base (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>为啥</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Y</span> (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-empty<br>    <span class="hljs-attribute">vptr</span>=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>  <span class="hljs-attribute">Base</span> (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-empty<br>      <span class="hljs-attribute">primary</span>-for Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>这里是什么东西啊？</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error_non_const_lvalue</title>
    <link href="/2021/10/31/error-non-const-lvalue/"/>
    <url>/2021/10/31/error-non-const-lvalue/</url>
    
    <content type="html"><![CDATA[<h4 id="errorcannot-bind-non-const-lvalue-reference-of-type-xxx-to-an-rvalue-of-type-xxx"><a class="markdownIt-Anchor" href="#errorcannot-bind-non-const-lvalue-reference-of-type-xxx-to-an-rvalue-of-type-xxx"></a> error：cannot bind non-const lvalue reference of type ‘xxx&amp;‘ to an rvalue of type ‘xxx‘</h4><p>非常量左值引用不能赋给右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base()&quot;</span>&lt;&lt;endl ; <br>    &#125;; <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base &amp;other)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base(Base &amp;other)&quot;</span>&lt;&lt;endl ; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b0 ; <br>    <span class="hljs-comment">// 三种调用拷贝构造创建对象的方式</span><br>    <span class="hljs-function">Base <span class="hljs-title">b1</span><span class="hljs-params">(b0)</span> </span>;  <br>    Base b2 = b0 ; <br>    Base b3 = <span class="hljs-built_in">Base</span>(b0) ;   <span class="hljs-comment">// 当拷贝构造函数为 Base(Base &amp;other) 而不是Base(const Base &amp;other)时，报错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原因：</strong><br />  如果一个参数是以非const引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。但如果你把一个临时变量当作非const引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，<strong>c++ 编译器加入了临时变量不能作为非const引用的这个语义限制。</strong></p><p><a href="https://blog.csdn.net/digitalkee/article/details/105092400">参考：https://blog.csdn.net/digitalkee/article/details/105092400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缺少模板参数列表</title>
    <link href="/2021/10/28/template_typename_T/"/>
    <url>/2021/10/28/template_typename_T/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/da1fd3f3cf3244ecac3814f3e1ed0f0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* data */</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">vector</span>(<span class="hljs-comment">/* args */</span>);<br>    ~ <span class="hljs-built_in">vector</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T <span class="hljs-type">const</span>&amp; )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 不加这一行 会报错：“缺少模板参数列表”</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>参考 <a href="https://blog.csdn.net/u013891092/article/details/51583666/">https://blog.csdn.net/u013891092/article/details/51583666/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
