<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vi_usage</title>
    <link href="/2024/04/24/vi-usage/"/>
    <url>/2024/04/24/vi-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="以普通用户身份打开以-root-用户身份保存">以普通用户身份打开，以root 用户身份保存</h2><p>:w !sudo tee %</p><p>:w - 这是写入命令。由于没有给出参数，vim将把整个文件写入标准输出；</p><p>!sudo - 将 sudo 命令作为 shell 命令而不是 vim 命令运行；</p><p>tee - tee命令用于读取标准输入并将其写入标准输出或文件；</p><p>% - vim 将其替换为您正在编辑的当前文件的名称。</p><p>:w 命令将整个文件写入STDOUT（标准输出）；然后，我们使用sudo命令（因为我们编辑的毕竟是一个系统文件）来获得临时权限。</p><p>百分号（%）表示文件名，tee 命令从 STDOUT 获取 vim 的输出并将其写入 %文件。</p><h2 id="保存文件前显示差异">保存文件前显示差异</h2><p>:w !diff % -</p><p>:w用于保存/写入，在这个特定场景中，如果命令中没有指定文件名，则输出将写入STDIN（标准输入）文件；</p><p>:!<command> 是执行 shell 命令的语法，在这个例子中，我们在 shell中运行 diff 命令；</p><p>% 表示未修改的当前文件的名称；试试这个：:!echo %</p><ul><li>是 diff 命令的 STDIN 文件。</li></ul><p>因此，该命令首先将所有[未保存]内容写入STDIN文件。然后diff命令读取当前文件（%）并将其与STDIN（-）文件进行比较。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试磁盘读写速度</title>
    <link href="/2024/04/18/disk_io/"/>
    <url>/2024/04/18/disk_io/</url>
    
    <content type="html"><![CDATA[<h2 id="dd-测试硬盘写入速度">dd-测试硬盘写入速度</h2><p>dd bs=1M count=128 if=/dev/zero of=test conv=fdatasync</p><h2 id="iostat-查看设备io">iostat 查看设备IO</h2><p><ahref="https://linuxtools-rst.readthedocs.io/zh-cn/latest/tool/iostat.html">参考链接</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cuda-notes</title>
    <link href="/2024/01/31/cuda-notes/"/>
    <url>/2024/01/31/cuda-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="杂记">杂记</h1><p>1.可以在kernel里设置同步点进行数据间的同步，__syncthreads()通常用于调整在相同块之间的线程通信2.一个批处理中每一个多处理器可以处理多少个块，取决于每个线程中分配了多少个寄存器和已知内核中每个时钟需要多少的共享内存 3.warp本质上是一组被同时调用的线程组，符合SIMD（或叫 SIMT单执行多线程）并行模型，所有线程中都执行相同的指令，每一条warp包含数量相同的线程；warp周期性切换执行；关键要理解<strong>相同指令的执行</strong>，也就意味着如果出现不同的执行分支，同一warp 中的一部分线程会阻塞等待一另部分执行完才能执行后面的相同指令4.线程块更像是一个逻辑上的概念，其大小可以设置，其中的线程被分配一块<strong>共享内存</strong>，其线程数往往大于warp大小（常规cuda设计下，线程块大小为32），也就意味着一个块中的会划分出多个warp、 5.一个块内的 warp次序是未定义的，但可以通过协调全局或共享内存的读取进行同步；在一个栅格块内的块次序是未定义的，并且不存在同步机制</p><p>6.内存模型一条执行在设备上的线程，只允许通过如下的内存空间使用设备的DRAM 和On-Chip内存，如图2-2 所 示：  读写每条线程的寄存器，  读写每条线程的本地内存， 读写每个块的共享内存，  读写每个栅格的全局内存， 只读每个栅格的常量内存，  只读每个栅格的纹理内存。</p><p><img src="image.png" alt="Alt text" /> 全局内存在设备的 DRAM上；常量内存和纹理内存都是只读内存全局内存不会被缓存；常量内存和纹理内存中的数据会被缓存；缓存是无法被直接访问的，cuda中的缓存数据来源是常量内存和纹理内存</p><p>7.循环展开的： #pragma unroll默认下，编译器为已知的行程计数展开小型循环。 #pragma unroll 5 For (int i= 0; i &lt; n; ++i) 循环将展开5 次。 如果#pragma unroll后面没有附值，当行程计数（n）为常数时，循环完全展开，否则不会展 开。</p><p>8.-use_fast_math编译选项，将替换math库中的标准标本为低准确性而更快速的版本</p><p>9.page-locked memory： 在cpu 内存中分配的内存，不会被换出，gpu使用时通过PCIE 进行通信 10.unified memory(managed memory)：可以翻译为托管内存，将分配的驻留位置移动到需要它的处理器，当gpu需要访问时就会把该块内存数据移动到gpu 内存上，当 cpu需要访问时就把这块内存数据移动到cpu 内存上。</p><p>11.以下操作在不同的流中也不能进行并发：page-locked主机内存分配，设备内存的分配，设备内存的设置，设备到设备的内存拷贝，或它们之间的事件纪录。12.数据拷贝和数值计算、两个方向的拷贝（gpu-&gt;cpu 和cpu-&gt;gpu，两个gpu-&gt;cpu 或者一个gpu-&gt;cpu、一个cpu-&gt;gpu这种）可以同时进行。13.cudaThreadSynchronize调用后可以确保前面所有的流都已完成。</p><p>12.设置CUDA_LAUNCH_BLOCKING 环境变量为1，强制cuda同步运行</p><p>13.为保证编译器生成最低数量的指令，对于结构体大于16字节的，应该用__align__ (16)定义,例如: <figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__align</span>(<span class="hljs-number">16</span>)__ &#123;<br>  <span class="hljs-type">float</span> a;<br>  <span class="hljs-type">float</span> b;<br>  <span class="hljs-type">float</span> c<br>  <span class="hljs-type">float</span> d<br>  <span class="hljs-type">float</span> e;<br>&#125;;<br>被编译成为二个<span class="hljs-number">128</span>-bit 加载指令而不是五个<span class="hljs-number">32</span>-bit 加载指令。 <br></code></pre></td></tr></table></figure></p><p>14.bank 冲突分两种，一种是共享内存bank 冲突，共享内存在物理上被分为32 个（刚好等于一个线程束中的线程数目，即内建变量 warpSize的值）同样宽度的、能被同时访问的内存 bank，当同一个 warp中的不同线程访问同一个 bank中的不同的地址时（访问同一个地址则会发生广播），就会发生 bank冲突；另一种是寄存器 bank 冲突，每个 SM 有独立的 registerfile，每个reigister file 被分为多个 bank，寄存器编号 id%4即为该寄存器所属的 bank，如 R0 属于 Bank 0，R5 属于 Bank1），当一条指令所需的源寄存器有两个以上来自于同一 bank则会产生conflict，比如FFMA R1, R0, R4, R1 这样的指令就回产生寄存器 Bankconflict（同同访问了 R0 和 R4，同属于 bank 0 的寄存器）</p><p>http://www.zh0ngtian.tech/posts/96744e8c.html</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tensorrt_tutorial</title>
    <link href="/2024/01/19/tensorrt-tutorial/"/>
    <url>/2024/01/19/tensorrt-tutorial/</url>
    
    <content type="html"><![CDATA[<h2 id="sample-编译">sample 编译</h2><p>https://github.com/NVIDIA/TensorRT/tree/release/8.0?tab=readme-ov-file#prerequisites</p><ol type="1"><li>github 上下载对应仓库，然后根据对应的 cuda版本选择对应的tag进行下载。<br />比如选择 release/8.0，如果有 docker 环境，可以利用官方提供的 docker镜像进行；裸机的话需要安装cuda、cudnn、tensorrt 三件套</li></ol><p>找到开发机中对应的 tensorrt lib 的路径，exportTRT_LIBPATH=/usr/lib/aarch64-linux-gnu/</p><ol start="2" type="1"><li>拉取三方依赖库的repo：git submodule update --init --recursive</li></ol><p>一般需要 vpn 才能下载下来</p><ol start="3" type="1"><li>release/8.0版本需要修改两个地方</li></ol><p>在 CMakeLists.txt中</p><p>设置nvcc 路径：set(CMAKE_CUDA_COMPILER/usr/local/cuda-10.2/bin/nvcc)<br />设置cub 的路径：set(CUB_ROOT_DIR${CMAKE_CURRENT_SOURCE_DIR}/third_party/cub CACHE STRING "directory ofCUB installation")</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pod_trivial_stardard_layout</title>
    <link href="/2024/01/10/pod-trivial-stardard-layout/"/>
    <url>/2024/01/10/pod-trivial-stardard-layout/</url>
    
    <content type="html"><![CDATA[<h2 id="plain-old-data-pod"><strong>Plain Old Data (POD)</strong></h2><p>pod 包含 trivial(普通)类型和standard layout</p><p>概念介绍：https://learn.microsoft.com/zh-cn/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170</p><p>trivial类型的结构体支持用memcpy来操作二进制，并对齐进行序列化和反序列，但不能被C程序调用</p><p>standard layout 类型的结构体支持被C 程序调用，但是不能用memcpy进行二进制操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>include-what-you-see</title>
    <link href="/2023/12/27/include-what-you-see/"/>
    <url>/2023/12/27/include-what-you-see/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><h1 id="如何安装">如何安装</h1><p>根据gitlab首页的提示：https://github.com/include-what-you-use/include-what-you-use</p><p>找到 <strong>How to buildstandalone</strong>，首先要知道IWYS是基于clang 和 llvm构建，所以如果环境中已经安装好了</p><h1 id="如何使用">如何使用</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux_deps</title>
    <link href="/2023/12/27/linux-deps/"/>
    <url>/2023/12/27/linux-deps/</url>
    
    <content type="html"><![CDATA[<h3 id="libncurses5-dev">libncurses5-dev</h3><p>源码编译 https://blog.51cto.com/liuzhenlife/1892078下载地址： http://ftp.gnu.org/gnu/ncurses/</p><p> http://ftp.gnu.org/gnu/ncurses/ncurses-6.0.tar.gz</p><figure class="highlight autoit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># tar -zxvf ncurses-6.0.tar.gz</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># cd ncurses-6.0</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta"># ./configure --with-shared --without-debug --without-ada --enable-overwrite  </span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta">#  make</span><br>[root<span class="hljs-symbol">@bogon</span> liuzhen]<span class="hljs-meta">#  make install</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>camera_params.md</title>
    <link href="/2023/10/09/camera-params-md/"/>
    <url>/2023/10/09/camera-params-md/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[E=mc^2\]</span></p><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h2 id="空间转换坐标系转换">空间转换/坐标系转换</h2><p>图像是由相机采集而来，那么就有一个疑问了，三维物理世界下的物体是怎么映射到一张二维图像上的，是怎么映射到具体的像素点的。这个映射的过程，就涉及到了几个坐标系/空间的转换。</p><h2 id="相机参数">相机参数</h2><h3 id="去畸变">去畸变</h3><p>为什么去畸变</p><p>怎么去畸变</p>]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>doxygen-usage</title>
    <link href="/2023/09/18/doxygen-usage/"/>
    <url>/2023/09/18/doxygen-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="vscode生成doxygen注释">vscode生成doxygen注释</h2><h2 id="doxygen-生成类图">doxygen 生成类图</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>doxygen<br><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>graphviz<br>doxygen -g ConfigName<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>memory_check_tools</title>
    <link href="/2023/09/06/memory-check-tools/"/>
    <url>/2023/09/06/memory-check-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="asan">ASan</h2><p>AddressSanitizer 的缩写。</p><blockquote><p>官方资料：https://github.com/google/sanitizers/wiki/AddressSanitizer</p></blockquote><h3 id="常规用法">常规用法</h3><p><strong>分为三步:</strong> 1. 添加编译选项，配合-g使用效果更价<figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"># set(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fno-omit-frame-pointer -fsanitize=undefined -fsanitize=leak -fsanitize=address -fsanitize-recover=address -lasan&quot;</span>)<br>add<span class="hljs-constructor">_compile_options(-<span class="hljs-params">fno</span>-<span class="hljs-params">omit</span>-<span class="hljs-params">frame</span>-<span class="hljs-params">pointer</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">undefined</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">leak</span> -<span class="hljs-params">fsanitize</span>=<span class="hljs-params">address</span> -<span class="hljs-params">fsanitize</span>-<span class="hljs-params">recover</span>=<span class="hljs-params">address</span> -<span class="hljs-params">lasan</span>)</span><br></code></pre></td></tr></table></figure> 支持</p><ol start="2" type="1"><li><p>目标程序运行前需要预加载 libasan.so <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export LD_PRELOAD=<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc/</span>aarch64-linux-gnu<span class="hljs-regexp">/7/</span>libasan.so<br></code></pre></td></tr></table></figure></p></li><li><p>通过环境变量对 asan 进行配置 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=halt_on_error=0   #和<span class="hljs-attribute">-fsanitize-recover</span>=address配合使用，遇到 <span class="hljs-built_in">error</span> 仍然向下执行<br><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=halt_on_error=0:verbosity=1     #设置多个选项<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="选项含义">选项含义</h3><h4 id="编译选项">编译选项</h4><blockquote><p>官方flag文档：https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</p></blockquote><h4 id="runtime选项">runtime选项</h4><p>ASAN_OPTIONS所支持的选项，通过help 查看 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=help=1    #查看帮助<br></code></pre></td></tr></table></figure></p><h3 id="asan-输出分析">asan 输出分析</h3><p><img src="image-1.png" alt="alt text" /> chatgpt: Addressable(可寻址的): 表示可以被访问和修改的内存区域。在这里用 "00" 表示。</p><p>Partially addressable (部分可寻址的):表示只有部分字节可以被访问和修改。在这里用 "01" 到 "07" 表示。</p><p>Heap left redzone (堆左侧红区):在堆分配的内存块的左侧，用于检测堆溢出。标记为 "fa"。</p><p>Freed heap region (已释放的堆区域): 表示已经被释放的堆内存。标记为"fd"。</p><p>Stack left redzone (栈左侧红区):在栈分配的内存块的左侧，用于检测栈溢出。标记为 "f1"。</p><p>Stack mid redzone (栈中间红区):在栈分配的内存块的中间，用于检测栈溢出。标记为 "f2"。</p><p>Stack right redzone (栈右侧红区):在栈分配的内存块的右侧，用于检测栈溢出。标记为 "f3"。</p><p>Stack after return (返回后的栈): 用于检测函数返回后对栈的访问。标记为"f5"。</p><p>Stack use after scope (作用域结束后的栈使用):表示在变量作用域结束后对栈的访问。标记为 "f8"。</p><p>Global redzone (全局变量红区): 用于检测对全局变量的溢出。标记为"f9"。</p><p>Global init order (全局变量初始化顺序):用于检测全局变量的初始化顺序问题。标记为 "f6"。</p><p>Poisoned by user (用户引起的中毒): 表示由用户引起的内存污染。标记为"f7"。</p><p>Container overflow (容器溢出):表示容器类型（比如数组、列表等）的溢出。标记为 "fc"。</p><p>Array cookie (数组饼干): 用于检测数组的越界访问。标记为 "ac"。</p><p>Intra object redzone (对象内红区):在对象内部，用于检测对象成员之间的溢出。标记为 "bb"。</p><p>ASan internal (ASan 内部):ASan（AddressSanitizer）内部使用的标记。标记为 "fe"。</p><p>Left alloca redzone (alloca 左侧红区): 在使用 alloca函数分配的内存块的左侧，用于检测溢出。标记为 "ca"。</p><p>Right alloca redzone (alloca 右侧红区): 在使用 alloca函数分配的内存块的右侧，用于检测溢出。标记为 "cb"。</p><p>Shadow gap (影子间隙): 用于对齐。标记为 "cc"。</p><h2 id="valgrind">valgrind</h2>]]></content>
    
    
    
    <tags>
      
      <tag>内存检查工具</tag>
      
      <tag>内存泄露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake_usgae</title>
    <link href="/2023/08/17/cmake-usgae/"/>
    <url>/2023/08/17/cmake-usgae/</url>
    
    <content type="html"><![CDATA[<h2 id="cmake-变量">cmake 变量</h2><h3 id="预定义变量">预定义变量</h3><h4 id="cmake--d-变量">cmake -D 变量</h4><p>cmake -D变量名=值 的形式 1. CMAKE_BUILD_TYPE<br />=Release 或者 =Debug 2. CMAKE_INSTALL_PREFIX<br />=path<br />install 安装目录的前缀</p><h4 id="环境变量">环境变量</h4><ol type="1"><li>CPM_SOURCE_CACHE<br />设置cmp 拉取依赖的保存路径<br />unset CPM_SOURCE_CACHE<br />set CPM_SOURCE_CACHE=/home/hans/_deps/</li><li></li></ol><h3 id="自定义变量">自定义变量</h3><h4 id="外部定义">外部定义</h4><p>变量类型有两种，bool类型和string类型，在外部定义时，即通过命令行<code>cmake -DXXX -DYYY</code>的形式传递变量时，其并不区分变量类型，可在CMakeList.txt和 .cmake文件进行使用，帮助进行<strong>条件编译和宏定义传递</strong>。<figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 判断 XXX 变量是否定义</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> XXX)  <br>  <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;XXX is defined, val=$&#123;XXX&#125;.&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> (<span class="hljs-keyword">DEFINED</span> XXX))<br>  <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;XXX is not defined.&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 判断 YYY 变量是否定义，一般 YYY 为字符串时判断是否DEFINED</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> YYY)<br>  <span class="hljs-keyword">add_definitions</span>(-DXXX=<span class="hljs-number">100</span>) <span class="hljs-comment"># cpp带值宏定义</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># 判断 YYY 变量是否为OFF，一般 YYY 为布尔类型时判断是否为 ON/OFF</span><br><span class="hljs-keyword">if</span> (YYY) <span class="hljs-comment"># if (NOT YYY)</span><br>  <span class="hljs-keyword">add_definitions</span>(-DUSE_XXX) <span class="hljs-comment"># cpp不带值宏定义</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></p><h4 id="内部定义">内部定义</h4><p>bool 类型通过 OPTION 命令进行定义 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 语法: </span><br>  <span class="hljs-keyword">OPTION</span>(var_name <span class="hljs-string">&quot;var comments&quot;</span> 初始值: <span class="hljs-keyword">OFF</span>/<span class="hljs-keyword">ON</span>)<br><span class="hljs-comment"># 示例: </span><br>  <span class="hljs-keyword">OPTION</span>(USE_GPU <span class="hljs-string">&quot;whether to use gpu&quot;</span> <span class="hljs-keyword">OFF</span>)<br></code></pre></td></tr></table></figure></p><p>string 类型通过 SET 命令进行定义 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><br><span class="hljs-keyword">SET</span>(var_name <span class="hljs-string">&quot;var_value&quot;</span>)<br><span class="hljs-keyword">SET</span>(BUILD_PLATFORM <span class="hljs-string">&quot;x86&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;select build cpu type&quot;</span>)<br><span class="hljs-comment"># 设置CXX_FLAGS, 如果options 太多, 可以分行写, \后面注意什么也不要加</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; \</span><br><span class="hljs-string">    -fno-omit-frame-pointer -fsanitize=undefined \</span><br><span class="hljs-string">    -fsanitize=leak -fsanitize=address -fsanitize-recover=address -lasan&quot;</span>)<br></code></pre></td></tr></table></figure></p><p>命令不区分大小写，变量区分大小写</p><p>gcc编译阶段打印宏定义的内容https://www.cnblogs.com/suiyek/p/14164160.html</p><h3 id="message-打印信息">message 打印信息</h3><p>message(STATUS "")</p><h3 id="编译选项">编译选项</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">## nvcc 对 -isystem 和 -I 选项的支持<br># nvcc 支持<br>set(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; \</span><br><span class="hljs-string">  -isystem/l4t/targetfs/usr/include/aarch64-linux-gnu \</span><br><span class="hljs-string">&quot;</span>)<br># nvcc 不支持<br>add<span class="hljs-constructor">_compile_options(-I<span class="hljs-operator">/</span><span class="hljs-params">l4t</span><span class="hljs-operator">/</span><span class="hljs-params">targetfs</span><span class="hljs-operator">/</span><span class="hljs-params">usr</span><span class="hljs-operator">/</span><span class="hljs-params">include</span><span class="hljs-operator">/</span><span class="hljs-params">aarch64</span>-<span class="hljs-params">linux</span>-<span class="hljs-params">gnu</span>)</span><br></code></pre></td></tr></table></figure><h3 id="链接">链接</h3><h4 id="默认链接的是静态库还是动态库">默认链接的是静态库还是动态库</h4><p>CMake在查找库时默认会优先找动态库（如.so文件或.dll文件），如果找不到或者特别指定了静态库，它会链接到静态库（如.a或.lib文件）。你可以通过<code>find_library</code>等命令及其相关参数来控制链接到静态库或动态库，或者添加定义来指定链接库的类型。</p><h4 id="add_library-默认生成的静态库还是动态库">add_library默认生成的静态库还是动态库</h4><p><code>cmake</code> 中 <code>add_library</code>命令默认生成的是静态库还是动态库取决于项目设置和 CMake 版本。在 CMake3.0 及以上版本中，如果未指定库类型，它将根据变量<code>BUILD_SHARED_LIBS</code>的设置来决定，默认情况下，此变量不设定时<code>add_library</code>生成的是静态库。如果<code>BUILD_SHARED_LIBS</code>被设置为ON，那么<code>add_library</code>不带库类型的情况下将生成动态库。</p><p>可以这样设置来决定默认的库类型：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(BUILD_SHARED_LIBS <span class="hljs-keyword">ON</span>) <span class="hljs-comment"># 默认生成动态库</span><br></code></pre></td></tr></table></figure><p>或者，在<code>add_library</code>时直接指定库的类型：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mylibrary STATIC mysource.cpp) <span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(mylibrary SHARED mysource.cpp) <span class="hljs-comment"># 生成动态库</span><br></code></pre></td></tr></table></figure><p>在不指定<code>STATIC</code>或<code>SHARED</code>，并且没有设置<code>BUILD_SHARED_LIBS</code>变量时，<code>add_library()</code>会创建静态库。</p><h3 id="属性">属性</h3><h4 id="二进制依赖库能否传递宏定义">二进制依赖库能否传递宏定义</h4><ul><li><p><code>target_compile_definitions</code>：这是传递宏定义的推荐方式。使用它时，可以设置私有（PRIVATE）宏，它们只会影响当前目标；接口（INTERFACE）宏，它们会影响链接了当前库的其他目标，但不会影响当前目标；或者是公共（PUBLIC）宏，它们既影响当前目标又影响链接了当前库的其他目标。</p></li><li><p><code>add_definitions</code>：这个指令会给当前目录下所有目标添加宏定义，但是它不会传递给依赖的目标。且它的作用范围是全局的，会影响到后续所有的目标。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加解密简介</title>
    <link href="/2023/08/16/encrypt-introduce/"/>
    <url>/2023/08/16/encrypt-introduce/</url>
    
    <content type="html"><![CDATA[<h2 id="加解密相关算法介绍">加解密相关算法介绍</h2><h3 id="base64">base64</h3><h4 id="作用和目的">作用和目的</h4><p>Base64是一种将二进制数据转换为字符串表示的格式转换算法，其最初是为了解决电子邮件中无法直接使用非ASCII字符的问题。一段数据先经过Base64编码为ASCII字符串后，可以在接收端，通过Base64解码还原为原数据后，而<strong>无需担心二进制兼容</strong>问题，避免数据的歧义和失真。</p><p>由于base64的易存储性和易传输性，常常将其用到加密数据的存储和传输场景。</p><p>使用Base64编码后的字符串通过索引表可以直接还原为明文，因此严格意义上讲base64并不是一种加密方法。</p><h4 id="实现方式">实现方式</h4><p>base64编码是<strong>基于64个可打印的字符来表示二进制的数据</strong>的一种方法，具体来讲是下面这64 个字符。 <figure class="highlight lasso"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-meta">[</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-params">...</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span><span class="hljs-meta">]</span> （26 + 26 + 10 + 2 = 64）<br></code></pre></td></tr></table></figure> 编码过程中，将待编码二进制数据按照 3个字节进行分组（6 和 8 的最小公倍数是24），24bit 的原始数据对应着 4个base64 编码（2 的 6 次方=64，即每 6bit 对应一个base64字符），即将3字节的原始数据映射为4 个base64 字符。</p><blockquote><p>参考：<br /><a href="https://zhuanlan.zhihu.com/p/268594663">密码学 |Base64是加密算法吗？</a><br /><ahref="https://juejin.cn/post/7013621623454433317">今天学到了什么｜终于搞明白base64编码了</a></p></blockquote><h3 id="sha-2">sha-2</h3><h4 id="作用">作用</h4><p>SHA-2 (Secure Hash Algorithm 2), 安全散列算法2</p><p>sha算法的作用就提现在名字上，其是一种hash算法。sha-2具有不可逆行，即无法通过哈希序列获得原始编码明文。</p><h3 id="对称加密和非对称加密">对称加密和非对称加密</h3><p>对称加密是指加解密双方要用同样的密钥；而非对称加密就是指加解密双方所用密钥不同，在非对称加密中，一个密钥对分为公钥和私钥，<strong>公钥用来加密，私钥用来解密。</strong></p><p>假设通信双方为小明和小红，小明要发数据给小红，通过非对称加密的通信过程大体如下：1. 数据<strong>接收方</strong>小红生成密钥对 2.数据接收方小红将<strong>公钥</strong>发送给小明 3.小明通过公钥对数据加密后将数据发送给小红 4.小红通过<strong>本地私钥</strong>对加密数据进行解密</p><p>因为公钥只能用来加密，因此公钥即使在网络传输过程中被劫持盗用，也无法将实际发送的数据的进行破解。</p><p>计算量上非对称加密要远高于对称加密，因此常常将对称加密的密钥，通过非对称加密方式进行传输，以保证密钥的安全性。</p><h3 id="rsa">RSA</h3><p>RSA 三个发明人的名字缩写，一种非对称加密算法</p><h3 id="aes">AES</h3><p>AES(Advanced Encryption Standard), 一种对称加密算法</p><h3 id="硬件加解密">硬件加解密</h3><p>加解密都需要很大的计算量，很多处理器上都有专用的硬件用来进行加解密，可以通过使用<code>cat /proc/cpuinfo</code>命令查看打印页中Features项是否包含aessha1 sha2来判断平台是否支持硬解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>machine_learning</title>
    <link href="/2023/08/04/machine-learning/"/>
    <url>/2023/08/04/machine-learning/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cuda_usage</title>
    <link href="/2023/08/04/cuda-usage/"/>
    <url>/2023/08/04/cuda-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="查看本机所支持的-nvidia-驱动">查看本机所支持的 nvidia 驱动</h3><p>ubuntu-drivers devices</p><p>recommend 可以直接用 apt 安装</p><div class="code-wrapper"><pre><code class="hljs">nvidia 驱动官网下载:https://www.nvidia.cn/Download/index.aspx?lang=cn#</code></pre></div><h3 id="安装cuda">安装cuda</h3><p>在nvidia官网选择需要的cuda版本下载https://developer.nvidia.com/cuda-10.2-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=Ubuntu&amp;target_version=1604&amp;target_type=runfilelocal</p><p>安装方式选择runfile</p><p>安装后 cuda路径为/usr/local/cuda-XXXX</p><h3 id="安装cudnn">安装cudnn</h3><p>在nvidia官网选择需要的cudnn版本下载https://developer.nvidia.com/rdp/cudnn-archive</p><p>下载解压后，将文件夹内cuda/include/里的所有文件拷贝到/usr/local/cuda-10.2/include/文件夹内，将cuda/lib64/里的所有文件拷贝到/usr/local/cuda-10.2/lib64/文件夹内</p>]]></content>
    
    
    
    <tags>
      
      <tag>cuda</tag>
      
      <tag>tensorrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qiniu 图床配置</title>
    <link href="/2023/08/02/qn-image-host/"/>
    <url>/2023/08/02/qn-image-host/</url>
    
    <content type="html"><![CDATA[<h3 id="图床">图床</h3><p>搜素“好用的图床”，搜索结果中随机对比了下，qiniu个人用户可以免费享受每月10GB的存储和流量，遂用之。</p><p><img src="http://qn.save.hansanf.space/qiniu_personal_count_free_credit.png" height="80%" width="80%"></p><p>qiniu的账户申请和配置省略，有很多教程，官方也有详细的引导和教程。<br />因为已经通过 hexo + githubpage有自己的播客了，之前简单理解只要把图片传到图床上就可以通过url访问的图片了，但是qiniu图床不提供域名，没有域名也就没有可以访问图片的外链，因此需要在qiniu上额外提供一个域名。先是尝试了直接将xxx.github.io作为qiniu外链域名，但是没法用。然后在阿里云上申请了个人域名，10 年才168。<br />下面介绍如何将个人域名绑定到githubpage，以及如何绑定图床的外链域名。</p><h3 id="准备工作">准备工作</h3><ol type="1"><li>github pages xxx.github.io可访问</li><li>qiniu 图床，可以上传图像</li><li>阿里云个人域名申请完成</li></ol><h3 id="github-page-绑定个人域名">github page 绑定个人域名</h3><p>教程：https://segmentfault.com/a/1190000011203711</p><p><strong>绑定域名需要在 域名解析服务商 和 github两边都进行操作</strong> 1.在域名解析服务商进行个人域名解析，将域名绑定到个人 github pages。<br /><img src="http://qn.save.hansanf.space/ali_domain_name_parse.jpeg" height="50%" width="50%"></p><ol start="2" type="1"><li>github pages 配置 CNAME 文件重定向到阿里云域名<br /><img src="http://qn.save.hansanf.space//github_cname.png" width="50%" height="50%"></li></ol><p>完成后，在浏览器中输入hansanf.space 即可访问原来的hansanf.github.io</p><h4 id="hexo-重新生成博客push到repo后-页面显示404">hexo重新生成博客push到repo后 页面显示404</h4><p>github page 设置cname后，重新生成博客的时候可能会将CNAME文件覆盖，浏览器访问博客会出现 404错误，可以将CNAME文件放在 “博客目录/source目录” 下<br />&gt; 参考：https://blog.csdn.net/Belingda/article/details/100635572</p><h3 id="提供域名给qiniu-作为图床外链">提供域名给qiniu 作为图床外链</h3><p>在左上角-》对象存储-》域名管理-》绑定域名<br />一定要在 <strong>自定义源站域名</strong> 栏绑定域名，一开始选择cdn的搞了半天都白搞了。<br /><img src="http://qn.save.hansanf.space//qiniu_cname.png" width="50%" height="50%"></p><p>输入域名前要先在阿里云域名解析处<strong>添加记录</strong>，即添加一个新的 cname, 修改<strong>主机记录</strong>(即添加域名前缀，比如qn.save)，然后将qn.save.hansanf.space 添加到qiniu 的域名中。<br /><img src="http://qn.save.hansanf.space/qn_input_parse_domain_name.png" width="50%" height="50%"></p><p>然后即可通过qiniu的外链访问到图像，即可以将外链作为博客图像的链接地址进行访问，本文的所有图像都是通过qiniu的外链进行访问的。</p><h3 id="补充知识">补充知识</h3><ol type="1"><li>什么是cname:</li></ol><p>在计算机网络中，CNAME是CanonicalName的缩写，即规范名。CNAME是DNS（Domain NameSystem）中的一种资源记录类型，用于建立域名的别名关系。</p><p>通常，一个域名可以有多个资源记录类型，例如A记录（指向IPv4地址）、AAAA记录（指向IPv6地址）、MX记录（指向邮件服务器）、TXT记录（用于存储任意文本信息）等。而CNAME记录允许将一个域名指向另一个域名，而不是直接指向IP地址。</p><p>举个例子，假设有两个域名：</p><p>www.example.com - 一个网站的主要域名，其A记录指向服务器的IPv4地址。www.example.net -另一个域名，希望将其指向和访问www.example.com相同的内容。</p><p>这时候，可以在www.example.net的DNS配置中添加一个CNAME记录，将它指向www.example.com。这样，当用户访问www.example.net时，DNS服务器会解析CNAME记录并将其转换为www.example.com，然后再查找www.example.com的A记录，最终将用户重定向到服务器的IPv4地址。</p><p>CNAME记录有一些限制和注意事项，例如不能在CNAME记录和其他记录（如MX记录、NS记录）之间共存。同时，CNAME记录的使用也可能会导致额外的DNS查询，稍微增加一些延迟，因为它需要进一步解析其他域名。因此，在使用CNAME记录时，需要仔细考虑其适用场景和潜在影响。</p><ol start="2" type="1"><li>什么是cdn</li></ol><p>CDN是Content DeliveryNetwork（内容分发网络）的缩写。它是一种用于加速互联网内容传输的技术架构。</p><p>在传统的网络架构中，当用户访问一个网站或下载某个文件时，请求会直接发送到该网站或文件所在的服务器，然后服务器将相应的内容传送给用户。如果用户和服务器之间的距离较远，网络拥塞或服务器负载较高，可能会导致传输速度较慢，延迟较高，影响用户体验。</p><p>CDN通过在全球范围内部署大量的服务器节点（也称为边缘节点），将网站的静态资源（例如图片、CSS、JavaScript、视频等）缓存到这些节点上。当用户请求访问网站内容时，CDN会自动将用户的请求路由到距离最近的边缘节点，从而加快内容的传输速度和加载时间。</p><p>CDN的工作原理如下：</p><p>缓存：CDN将网站的静态资源缓存在多个边缘节点上。<br />路由：当用户发起请求时，CDN会智能地选择距离用户最近的边缘节点，将请求路由到该节点。<br />传输：边缘节点直接向用户提供所需的内容，从而避免了长距离传输和网络拥塞。</p><p>简单来讲cdn 是为了访问加速，在qiniu中通过外链访问图片只需要提供一个可以访问的域名，而不是对所提供的域名进行访问加速，所以在提供域名给qiniu的时候要选择 <strong>自定义源站域名</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>图床</tag>
      
      <tag>域名</tag>
      
      <tag>cname</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>core文件设置</title>
    <link href="/2023/07/29/core-file/"/>
    <url>/2023/07/29/core-file/</url>
    
    <content type="html"><![CDATA[<h2 id="core-文件设置">core 文件设置</h2><h3 id="常规core文件设置">常规core文件设置</h3><h4 id="core-文件大小">core 文件大小</h4><p>查看：ulimit -c 临时设置： ulimit -c unlimited （当前终端有效）</p><h4 id="修改core文件路径">修改core文件路径</h4><ol type="1"><li><p>临时修改（重启后失效） 修改<code>/proc/sys/kernel/core_pattern</code><br /><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&#x27;/corefile/core_%e.%p&#x27;</span> | sudo tee <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br></code></pre></td></tr></table></figure></p></li><li><p>永久生效 修改 <code>/etc/sysctl.conf</code>, 在其中加入两行<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">kernel.core_pattern</span>=/corefile/core_%e.%p<br><span class="hljs-attr">kernel.core_uses_pid</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></p></li></ol><p>kernel.core_uses_pid 表示在core 文件结尾不加pid，因为已经有了%p，所以不需要再添加<br />执行<code>sudo sysctl -p /etc/sysctl.conf</code>, 使修改生效。</p><h3 id="apport-core-文件">apport core 文件</h3><p>在 /proc/sys/kernel/core_pattern 文件中写入 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E<br></code></pre></td></tr></table></figure>安装好apport 后可以通过apport对core进行收集，core文件保存在/var/lib/apport/coredump/ 目录下（应该可以设置，没找到在哪设置的）</p><p>注： Apport 并不直接用于分析 core文件。它主要用于收集和报告应用程序崩溃信息，并将其提交给开发人员或错误报告系统。使用 Apport 收集 core 文件有以下优点：</p><ol type="1"><li><p>自动收集和报告：Apport可以自动捕获应用程序的崩溃信息，并生成相应的崩溃报告。这样，你无需手动分析core 文件，而是可以直接获得一个包含崩溃信息的报告。</p></li><li><p>附带环境信息：Apport的崩溃报告通常会包含应用程序崩溃时的环境信息，如操作系统版本、软件包版本、硬件信息等。这些信息对于开发人员来说是非常有用的，可以帮助他们更好地理解和重现崩溃问题。</p></li><li><p>易于提交和跟踪：Apport 默认会将崩溃报告上传到错误报告系统（如Launchpad），使开发人员能够轻松地接收和跟踪报告。这样，开发人员可以更快地了解和解决崩溃问题。</p></li><li><p>用户友好：Apport的崩溃报告通常以用户友好的方式呈现，包含易于理解的错误消息、堆栈跟踪和其他相关信息。这使得用户能够更好地理解崩溃问题，并提供有用的反馈。</p></li></ol><h3 id="调试代码">调试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  *(<span class="hljs-type">int</span> *)<span class="hljs-number">0</span> = <span class="hljs-number">8</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="gdb加载core文件">gdb加载core文件</h3><div class="code-wrapper"><pre><code class="hljs">gdb app corefile</code></pre></div><p>不需要加 app 的 args</p><h3 id="dmesg-查看内核日志">dmesg 查看内核日志</h3><p>情景回顾：程序启动后直接被kill掉，没有core dump 等报错信息，通过dmesg查看内核日志发现是由于 OOM 被系统直接杀掉了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>core dump</tag>
      
      <tag>core file</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template_meta_program</title>
    <link href="/2023/02/14/template-meta-program/"/>
    <url>/2023/02/14/template-meta-program/</url>
    
    <content type="html"><![CDATA[<h3 id="enable_if">enable_if</h3><p>https://www.cnblogs.com/3d-gis/articles/14392648.html</p>]]></content>
    
    
    
    <tags>
      
      <tag>template</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>readthedoc_usage</title>
    <link href="/2023/02/14/readthedoc-usage/"/>
    <url>/2023/02/14/readthedoc-usage/</url>
    
    <content type="html"><![CDATA[<p>电子书搭建教程：<br />https://zhuanlan.zhihu.com/p/388640347</p><p>read the docs 官网：<br />https://readthedocs.org/?utm_source=testingpai.com</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>compile_runtime_error</title>
    <link href="/2023/02/14/compile-runtime-error/"/>
    <url>/2023/02/14/compile-runtime-error/</url>
    
    <content type="html"><![CDATA[<h3 id="编译时报错">编译时报错</h3><h4 id="找不到依赖库的头文件">找不到依赖库的头文件</h4><p>找不到依赖库的头文件，找不到依赖库中头文件所包含的头文件 bcloud引用依赖库时，头文件需要 HEADER 标签发布到output 中。</p><p>发布到output的头文件，如果包含了库中的其他头文件，也需要一起发布到output 中</p><p>为什么之前没有注意这个问题呢？因为一般头文件不会引用自己所不需要的头文件，只有其需要被引用时，才进行include。而如果将库中的头文件引用操作放在 .cc 文件，其所include的头文件的内容直接就编译到库中，在其他库所引用该库时，也就不会存头文件找不到另外一个头文件的问题了。</p><h4 id="undefined-reference-to-__atan2_finite">undefined reference to`__atan2_finite'</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-literal">[ERROR]</span> fail <span class="hljs-keyword">to</span> compile baidu/adu-lab/framework/output/bin/radar_fusion_app ip:<span class="hljs-number">10.61</span>.<span class="hljs-number">192.37</span><br> err:bc_out/baidu/adu-lab/framework/app/radar_fusion/baidu_adu-lab_framework_radar_fusion_app_app_radar_fusion.cpp.o: In <span class="hljs-keyword">function</span> `v2x::sensor::radar::radar_fusion::radar<span class="hljs-constructor">_msg_proc(<span class="hljs-params">int</span>, <span class="hljs-params">std</span>::<span class="hljs-params">shared_ptr</span>&lt;<span class="hljs-params">os</span>::<span class="hljs-params">v2x</span>::<span class="hljs-params">device</span>::RadarObstacles <span class="hljs-params">const</span>&gt; <span class="hljs-params">const</span>&amp;)</span>&#x27;:<br>/home/bcloud/bcloud_data/EE/BCLOUD_PROTOBUF/CompileServer/Task/bb84d71b78676b10f34e635275115abf/baidu/adu-lab/framework/app/radar_fusion/radar_fusion.cpp:<span class="hljs-number">118</span>: undefined reference <span class="hljs-keyword">to</span> `__atan2_finite&#x27;<br></code></pre></td></tr></table></figure><p>https://github.com/google/filament/issues/2875https://stackoverflow.com/questions/62334452/fast-math-cause-undefined-reference-to-pow-finitehttps://github.com/google/filament/issues/2146</p><p>1、去掉 fast-math<br />2、或加上 -fno-builtin +#include&lt;tgmath.h&gt;</p><h3 id="运行时报错">运行时报错</h3><h4 id="undefined-symbol">undefined symbol</h4><p>1、运行时报 undefined symbol，可能是编译该so时没有实际链接依赖库，只是使用了头文件，比如编libmsf_Ucommon_Umath.so时没有链接libopencv_core.so，但还是能编译通过，因为其在系统目录下找到了头文件，有些情况仅使用头文件就编译通过了。。</p><p>TODO：具体什么情况只需要头文件</p><p>2、 E1219 23:24:25.009349 7549 class_loader_utility.cc:218][mainboard]LibraryLoadException:/home/caros/work/airos_fusion/baidu/adu-lab/airos/output/3rd/libmodules_Sperception-fusion_Salgorithm_Sfusion_Utracker_Stracker_Sprocess_Slibmsf_Utracker_Uprocess.so:undefined symbol: _ZN9algorithm2ft5track14StateContainer9frequent_E</p><p>也是运行期间报 undefined symbol 问题，但<em>ZN9algorithm2ft5track14StateContainer9frequent_E这个符号在libmsf_Utracker_Uprocess.so 这个动态库里的，是作为其中一个类的静态成员变量， 其使用形式为这种： StateContainer() :vx_mean_filter</em>(frequent_), vy_mean_filter_(frequent_){};其使用静态成员变量在初始化列表中对成员变量进行初始化，因此报错，这种形式应该在一些编译参数的设置下是允许的。</p><p>3、undefined symbol也可能是因为编译链接的库和运行时链接的库版本不一致</p><h3 id="undefined-reference-googleisgooglelogginginited">undefinedreference google::isGoogleLoggingInited()</h3><p>从baidu/adu-3rd/glog 引用了glog库 但是本地也有glog库，</p><p>笨方法： 删掉本地库后就ok了</p><p>卸载glog的方法： <figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">//安装</span><br>sudo apt-<span class="hljs-built_in">get</span> install libgoogle-glog-<span class="hljs-built_in">dev</span><br><span class="hljs-comment">//卸载</span><br>sudo apt-<span class="hljs-built_in">get</span> remove libgoogle-glog-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure> 聪明方法：</p><p>使用 ldd命令查看当前所链接的库是哪一个，是否是想要链接的库，使用export命令把想要链接的库放在前面</p><h3 id="cpplint-报错">cpplint 报错</h3><h4 id="static-extern-typedef等要放在声明前">static externtypedef等要放在声明前</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">select_npy_type</span> &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">static</span> NPY_TYPES type = NPY_NOTYPE;<br>&#125;;  <span class="hljs-comment">// Default</span><br></code></pre></td></tr></table></figure><p>3行 : Storage-class specifier (static, extern, typedef, etc) shouldbe at the beginning of the declaration</p><p>static 放在 const 前面即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译报错</tag>
      
      <tag>运行报错</tag>
      
      <tag>cpplint报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv_usage</title>
    <link href="/2023/02/14/opencv-usage/"/>
    <url>/2023/02/14/opencv-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="保存图片">保存图片</h3><figure class="highlight zephir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs zephir">cv::Mat m(<span class="hljs-number">1080</span>, <span class="hljs-number">1920</span>, CV_8UC3);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* m_ptr = m.ptr&lt;<span class="hljs-keyword">uchar</span>&gt;(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fgq_n = <span class="hljs-number">0</span>;<br>memcpy((void*)m_ptr, image_blob-&gt;cpu_data(), <span class="hljs-number">1080</span> * <span class="hljs-number">1920</span> * <span class="hljs-number">3</span>);<br>cv::imwrite(<span class="hljs-string">&quot;/home/caros/work/tmp/&quot;</span> + std::to_string(fgq_n++) + <span class="hljs-string">&quot;.png&quot;</span>, m);<br></code></pre></td></tr></table></figure><h3 id="cvmat">cv::Mat</h3><h4 id="基础概念">基础概念</h4><p><ahref="https://zhuanlan.zhihu.com/p/507103729">OpenCV:Mat中的step、elemSize和任意内存访问</a></p><h4 id="判断是否连续">判断是否连续</h4><p>isContinuous() 方法可以判断一个 cv::Mat对象是否在内存中是连续的。</p><p>如果是连续的返回true，如果在每一行的结尾跳过一部分内存地址到达下一行，那么就会返回false。</p><p>所以很显然，1x1 和 1xN 的对象一定是连续的，因为只有一行数据。</p><p>使用 <code>cv::Mat::create</code>创建的对象也是连续的，表示直接开辟了一个连续的内存空间进行对象的创建。</p><p>但是，如果从一个 cv::Mat对象中截取了一部分数据，或者构造数据来自外部存储的数据，那么就不一定是连续的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::Mat newM = cv::Mat::<span class="hljs-built_in">zeros</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, CV_32FC1);<br><br>cout &lt;&lt; newM.<span class="hljs-built_in">isContinuous</span>() &lt;&lt; endl;<br><br>cv::Mat segM = newM.<span class="hljs-built_in">colRange</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>);<br><br>cout &lt;&lt; segM.<span class="hljs-built_in">isContinuous</span>() &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><h4 id="非连续mat-如何拷贝">非连续Mat 如何拷贝</h4><p>非连续是指行之间的地址是间断的，但是同一行的内存是连续，所以可以按行复制</p><p>下面是把非连续的 Mat 复制给vector.data(),把非连续变成了连续，如果不关注连续还是非连续，可以直接a_mat.copyTo(b_mat) <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// apollo</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BEVObstacleDetector::Mat2Vec</span><span class="hljs-params">(<span class="hljs-type">const</span> cv::Mat &amp;im, <span class="hljs-type">float</span> *data)</span> </span>&#123;<br>  <span class="hljs-built_in">ACHECK</span>(<span class="hljs-literal">nullptr</span> != data);<br>  <span class="hljs-type">int</span> rh = im.rows;<br>  <span class="hljs-type">int</span> rw = im.cols;<br>  <span class="hljs-type">int</span> rc = im.<span class="hljs-built_in">channels</span>();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rc; ++i) &#123;<br>    cv::<span class="hljs-built_in">extractChannel</span>(im, cv::<span class="hljs-built_in">Mat</span>(rh, rw, CV_32FC1, data + i * rh * rw), i);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 申请一块大内存</span><br><span class="hljs-function">Mat <span class="hljs-title">buffer</span><span class="hljs-params">(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">256</span>, <span class="hljs-number">5</span>, CV_32F)</span></span>;<br><br><span class="hljs-comment">// useful 是将要实际使用的行数</span><br><span class="hljs-comment">// rowRange 只是创建了个 mat 的 head，不会申请新的</span><br>handle = buffer.<span class="hljs-built_in">rowRange</span>(<span class="hljs-number">0</span>, useful)<br><span class="hljs-comment">// handle 相当于是 0 - useful 行的浅拷贝</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GLOG_usage</title>
    <link href="/2023/02/14/GLOG-usage/"/>
    <url>/2023/02/14/GLOG-usage/</url>
    
    <content type="html"><![CDATA[<h2 id="cpp-code">cpp code</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">头文件包含：<br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;glog/logging.h&quot;</span>   <span class="hljs-comment">// 添加头文件</span><br><br>初始化：<br>FLAGS_log_dir = <span class="hljs-string">&quot;./&quot;</span>;  <span class="hljs-comment">// 指定地址log文件路径，默认是在/tmp/</span><br>google::<span class="hljs-constructor">InitGoogleLogging(<span class="hljs-params">argv</span>[0])</span>;   <span class="hljs-comment">// 设置log文件名称，argv[0].INFO</span><br><br>记录信息：<br><span class="hljs-constructor">LOG(WARNING)</span> &lt;&lt; <span class="hljs-string">&quot;WARNING: this is a test for glog&quot;</span>; <br><span class="hljs-constructor">LOG(INFO)</span> &lt;&lt; <span class="hljs-string">&quot;INFO: this is a test for glog&quot;</span>;<br></code></pre></td></tr></table></figure><p>还有更高阶用法：https://rpg.ifi.uzh.ch/docs/glog.html</p><p>https://my.oschina.net/u/4320185/blog/3755592</p><h2 id="日志等级设置">日志等级设置</h2><h3 id="环境变量方式">环境变量方式</h3><p>通过export 设置 GLOG_alsologtostderr=1 error 和 fatal 输出到stderr<br />GLOG_logtostderr=1 所有log 都输出到stderr<br />GLOG_stderrthreshold=2<br />把严重等级&gt;=指定等级的log信息额外输出到stderr中(默认为2,即ERROR和FATAL)<br />### GFLAGS 方式glog支持的FLAGS：https://github.com/google/glog/blob/674283420118bb919f83ceb3d9dee31ef43ff3aa/src/logging.cc</p><p>VLOG(x) &lt;&lt; "message xxx";可以通过命令行"--v=n",来控制VLOG的输出,VLOG(x),x&lt;=n的情况,VLOG会输出,否则不输出.v默认为0,所以默认情况下VLOG(-1),VLOG(0)能够输出The default verbosity level for glog's VLOG is 0, which means that noverbose output will be generated unless the --v flag is used orgoogle::SetVLOGLevel() is called. <code>./my_program --v=2</code> or<code>google::SetVLOGLevel("my_file.cc", 2);</code></p><p>VLOG(level) 和 LOG(level) 记录的信息等级是相反的<br />VLOG 记录更详细的日志，INFO=&gt;WARNING=&gt;ERROR (v: 0=&gt;1=&gt;2),当level&lt;=v 时记录 LOG 记录更高级的日志，ERROR=&gt;WARNING=&gt;INFO(minloglevel 2=&gt;1=&gt;0), 当level&gt;=miniloglevel 时记录</p><p>日志文件写入没有标准错误写入及时</p>]]></content>
    
    
    
    <tags>
      
      <tag>glog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFLAG_usage</title>
    <link href="/2023/02/14/GFLAG-usage/"/>
    <url>/2023/02/14/GFLAG-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="gflag使用记录">GFLAG使用记录</h3><p>在main()中调用gflags::ParseCommandLineFlags(&amp;argc, &amp;argv,true)解析传入GFLAGS_xxx，在运行bin文件的时候，可以选择用命令传入flags参数，或者将参数放在一个文本文件中</p><p>示例： <figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gflags/gflags.h&quot;</span></span><br><span class="hljs-built_in">DEFINE_string</span>(local_ip, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;genenral local ip&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>    gflags::<span class="hljs-built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 解析GFLAS_XX </span><br>    std::cout &lt;&lt; FLAGS_local_ip &lt;&lt; std::endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>g++ main.cpp 生成a.out可执行文件后， 命令行传入FLAGS_local_ip:<code>./a.out --local_ip=127.0.0.2</code></p><p>文本文件传入： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> flags.txt<br>--local_ip=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure> ./a.out --flagfile=./flags.txt</p><p>如果不设置local_ip参数，默认打印 127.0.0.1；设置locol_ip参数后打印127.0.0.2</p><p><strong>Note</strong>:</p><p>define有且只能出现一次，所以当头文件会被多个文件包含时，一定不能定义在头文件中因此，DEFINE在cpp中，DECLARE在头文件中，若只想被一个.cpp文件使用，则只定义在此.cpp文件中而不在.h文件中声明</p>]]></content>
    
    
    
    <tags>
      
      <tag>gflag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bazel_usage</title>
    <link href="/2023/02/13/bazel-usage/"/>
    <url>/2023/02/13/bazel-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="bazel安装">bazel安装</h3><p>官方教程：https://bazel.build/install/ubuntu?hl=zh-cn</p><h3 id="基础教程">基础教程</h3><p>https://bazel.build/start/cpp?hl=zh-cn</p>]]></content>
    
    
    
    <tags>
      
      <tag>bazel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>orin_env</title>
    <link href="/2023/02/13/orin-env/"/>
    <url>/2023/02/13/orin-env/</url>
    
    <content type="html"><![CDATA[<h3 id="jetpack-sdk-安装">jetpack sdk 安装</h3><h4 id="确认nvidia-apt资源列表">确认nvidia apt资源列表</h4><p>cat /etc/apt/sources.list.d/nvidia-l4t-apt-source.list</p><p>确认是否为</p><p>deb https://repo.download.nvidia.com/jetson/common r35.1 main</p><p>deb https://repo.download.nvidia.com/jetson/t234 r35.1 main</p><h4 id="校正时间和时区">校正时间和时区</h4><p>修改系统时间和时区</p><p>系统时间不准确，可能无法连网、获取nvidia 安装包索引</p><h4 id="安装jetpack5.0.2">安装jetpack5.0.2</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">dist-upgrade</span><br><span class="hljs-keyword"></span>sudo reboot<br>sudo apt-<span class="hljs-keyword">cache </span><span class="hljs-keyword">show </span>nvidia-<span class="hljs-keyword">jetpack </span>查看<span class="hljs-keyword">jetpack </span>sdk 版本，确认为<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br>sudo apt <span class="hljs-keyword">install </span>nvidia-<span class="hljs-keyword">jetpack</span><br><span class="hljs-keyword"></span>````<br><br><span class="hljs-comment">#### 查看cuda、cudnn、tensorrt 版本</span><br></code></pre></td></tr></table></figure><p>cat /usr/loca/cuda/version.json<br />cuda 11.4.14 cat /usr/include/aarch64-linux-gnu/cudnn_version_v8.h cudnn8.4.1 cat /usr/include/aarch64-linux-gnu/NvInferVersion.h tensorrt8.4.1.5 <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 安装jtop<br></code></pre></td></tr></table></figure> sudo apt install python3-pip sudo -H pip3 install-U jetson-stats sudo jtop 验证是否可用 <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 开启最大性能<br></code></pre></td></tr></table></figure> sudo nvpmodel -m 0&amp;&amp; sudo jetson_clocks sudo jetson_clocks --fan jtop 查看 NVPower[0] 是否为MAXN 重启后失效 <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### wget 报错<br></code></pre></td></tr></table></figure> --2018-10-01 12:11:19--https://url Connecting to #:443... connected. OpenSSL:error:14082174:SSL routines:ssl3_check_cert_and_algorithm:dh key toosmall Unable to establish SSL connection. ```</p><p>Here's a simple workaround for wget: use wget --cipher 'DEFAULT:!DH'in place of wget.</p><p>https://stackoverflow.com/questions/52588948/problem-with-wget-command-ssl3-check-cert</p><h4 id="终端重复打印-message-xxx">终端重复打印 Message xxx</h4><p>终端报Message from syslogd kernel:unregister_netdevice: waiting foreth0 to become free</p><p>https://blog.51cto.com/xiao987334176/1910715 没有找到链接里说的#*.emerg</p><p>16 # provides UDP syslog reception<br />17 #module(load="imudp")<br />18 #input(type="imudp" port="514")<br />19<br />20 # provides TCP syslog reception<br />21 #module(load="imtcp")<br />22 #input(type="imtcp" port="514")<br />23<br />24 # provides kernel logging support and enable non-kernel klogmessages<br />25 #module(load="imklog" permitnonkernelfacility="on")</p><p>把25行注释掉 重启rsyslog服务 /etc/init.d/rsyslog restart</p>]]></content>
    
    
    
    <tags>
      
      <tag>orin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug_record</title>
    <link href="/2023/02/13/bug-record/"/>
    <url>/2023/02/13/bug-record/</url>
    
    <content type="html"><![CDATA[<h3 id="编译问题">编译问题</h3><h3 id="linux-环境问题">linux 环境问题</h3><p>问题描述：</p><p>程序有许多printf时，使用管道符或重定向到文件均比直接打印到标准输出的性能要好</p><p>原因: https://www.cnblogs.com/lhfcws/p/3197735.html</p><p>Console会给多个进程共享，因此对console操作时会存在进程同步和缓存问题。</p><p>ssh远程连接没有该问题，只有在本地运行才有</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++和shell脚本的输入参数设置</title>
    <link href="/2022/11/21/cpp-shell-input-args/"/>
    <url>/2022/11/21/cpp-shell-input-args/</url>
    
    <content type="html"><![CDATA[<h2 id="c-可执行文件输入参数">C++ 可执行文件输入参数</h2><h3 id="getopt_long函数">1. getopt_long()函数</h3><p>使用手册： https://linux.die.net/man/3/getopt_long</p><h3 id="设置参数选项">2. 设置参数选项</h3><p>参数选项的形式可以分为两种，一是 -n, 二是 --name</p><p>-n 这种需要设置短选项字符串；--name 这种需要设置长选项结构体。</p><h4 id="段选项字符串">2.1 段选项字符串</h4><p>书写规则： - 多个短选项可以连在一起 -如果某个要解析的选项需要一个参数，则在选项名后面跟一个冒号 -如果某个要解析的选项的参数可选，则在选项名后面跟两个冒号</p><p>一般如这种形式: <code>const char* short_options = "hx:t:c:"</code>该字符串解释为：</p><div class="code-wrapper"><pre><code class="hljs">-h -t t_arg-c c_arg</code></pre></div><p>细心的话为发现多了h后面还有一个x:没有被说明，因为h(help)后面不需要接参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* short_options = <span class="hljs-string">&quot;hx:n:h:&quot;</span>;    <span class="hljs-comment">// 带参数的，要使用的命令，需要在这里声明</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">option</span> long_options[] = &#123;<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;output&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;,<br>        &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg usage</title>
    <link href="/2022/09/02/ffmpeg-usage/"/>
    <url>/2022/09/02/ffmpeg-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="ffmpeg-命令行">ffmpeg 命令行</h3><blockquote><p><ahref="https://blog.csdn.net/avsuper/article/details/54918465?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-54918465-blog-119670672.pc_relevant_antiscanv2&amp;utm_relevant_index=6">FFMPEG命令行详细参数</a></p></blockquote><p>播放rgb格式的视频 <figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ffplay</span> -f rawvideo -pixel_format bgr24 -video_size <span class="hljs-number">1280</span>x1280 -framerate <span class="hljs-number">10</span> video_cuda_1.rgb <br></code></pre></td></tr></table></figure></p><p>播放 h264格式的视频 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ffplay</span> -f h264 -width <span class="hljs-number">1920</span> -height <span class="hljs-number">1080</span> record_424_sensor_ipcamera_h264_10_128_156_101.h264<br></code></pre></td></tr></table></figure></p><p>转码 h264 =&gt; mp4 <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ffmpeg <span class="hljs-literal">-i</span> Free_Test_Data_15MB_MP4.h264 <span class="hljs-literal">-framerate</span> <span class="hljs-number">30</span> <span class="hljs-literal">-vcodec</span> <span class="hljs-built_in">copy</span> <span class="hljs-operator">-f</span> mp4 output.mp4<br></code></pre></td></tr></table></figure></p><p>转码 mp4 =&gt; h264 <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ffmpeg -i Free_Test_Dat<span class="hljs-built_in">a_15MB</span>_MP4.mp4 -vcodec libx264 -acodec aac Free_Test_Dat<span class="hljs-built_in">a_15MB</span>_MP4.<span class="hljs-number">264</span><br></code></pre></td></tr></table></figure></p><p>yuv视频 =&gt; jpeg <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ffmpeg</span> -pix_fmt yuyv422 -s <span class="hljs-variable">$&#123;w&#125;</span>x<span class="hljs-variable">$&#123;h&#125;</span> -i <span class="hljs-variable">$&#123;name&#125;</span>.yuv <span class="hljs-variable">$&#123;name&#125;</span>.jpg<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>performace-test</title>
    <link href="/2022/08/30/performace-test/"/>
    <url>/2022/08/30/performace-test/</url>
    
    <content type="html"><![CDATA[<h3 id="perf">perf</h3><h4 id="perf-安装">perf 安装</h4><p>https://xiaoyanzhuo.github.io/2019/01/18/Perf-Tool.html <figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> update<br><span class="hljs-variable">$sudo</span> apt-<span class="hljs-built_in">get</span> install linux-tools-common linux-tools-generic linux-tools-`uname -r`<br></code></pre></td></tr></table></figure>#### orin上安装</p><p>下载 JP-x.x.x Driver Package Sources:https://developer.nvidia.com/embedded/l4t/r35_release_v1.0/sources/public_sources.tbz2</p><p>执行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">复制压缩包到orin<br><span class="hljs-built_in">cd</span>到 kernel/kernel-4.9/tools/perf<br>make<br>./perf --version<br></code></pre></td></tr></table></figure></p><h4 id="用法">用法</h4><p>基础教程：https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/common-perf-commands_getting-started-with-perf</p><p>用 perf 监控相关指标，生成报告，然后可以将报告用https://profiler.firefox.com/ 进行查看</p><p>步骤： <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>、sudo perf record -e cpu-<span class="hljs-keyword">clock </span>-g -p PID sleep <span class="hljs-number">10</span><br><span class="hljs-number">2</span>、perf <span class="hljs-keyword">script </span>-i perf<span class="hljs-meta">.data</span> &amp;&gt; perf.unfold<br></code></pre></td></tr></table></figure> 然后将 .unfold 文件在 profiler.firefox.com orspeedscope.app 网站上打开</p><h5 id="flame-graph生成火焰图">Flame Graph生成火焰图</h5><p>Flame Graph项目位于GitHub上：https://github.com/brendangregg/FlameGraph</p><p>git clone https://github.com/brendangregg/FlameGraph.git./FlameGraph/stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</p><h3 id="nvidia-system">nvidia-system</h3><p>orin上</p><p>/opt/nvidia/nsight-systems/2022.3.3/target-linux-tegra-armv8/nsysprofile -y 60 -d 20 --gpuctxsw=true -o out_file mainboard -d./dag/test.dag</p><p>程序开始运行60s后,记录20s.然后core dump 生成记录报告out_file</p>]]></content>
    
    
    
    <tags>
      
      <tag>nsight</tag>
      
      <tag>nsys</tag>
      
      <tag>sysbench</tag>
      
      <tag>perf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hhd-ssd-emmc</title>
    <link href="/2022/08/30/hhd-ssd-emmc/"/>
    <url>/2022/08/30/hhd-ssd-emmc/</url>
    
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>HDD，即硬盘驱动器（HardDiskDrive），一般指机械硬盘；多层盘，每层一个磁头SSD，即固态硬盘（Solid State Drives）； EMMC，(Embedded Multi MediaCard) 一种内嵌式存储器标准规格； NAND，即Nand-flash，闪存的一种。 SSD 和EMMC 都是基于NAND 的</p><h3 id="ssd-为什么越写越慢磁盘空间快慢时变慢">ssd为什么越写越慢?（磁盘空间快慢时变慢）</h3><p>http://www.ssdfans.com/?p=90902 因为垃圾回收机制</p><h3 id="hhd为什么随机读写很慢">hhd为什么随机读写很慢</h3><p>https://zhuanlan.zhihu.com/p/20085866 因为磁头要来来回回移动</p><h3 id="ssd的分类">ssd的分类</h3><p>https://www.kingston.com.cn/cn/community/articledetail/articleid/48543SSD 技术：NVMe、SATA、M.2 NVMe (Non-Volatile Memory Express)是一种通信接口和驱动程序，为基于 PCIe 的 SSD 定义了命令集和功能集PICe（NVMe） 比 SATA 更快</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssd</tag>
      
      <tag>emmc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-pip</title>
    <link href="/2022/08/28/python-pip/"/>
    <url>/2022/08/28/python-pip/</url>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>有条件直接使用 conda的虚拟环境</p><h3 id="miniconda">miniconda</h3><p>安装miniconda：https://www.jianshu.com/p/992cadf45994<figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> env list  查看已有的python 环境<br><span class="hljs-attribute">conda</span> create --name py36 python=<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> 指定 Python 版本创建虚拟环境<br><span class="hljs-attribute">conda</span> activate py36   激活 py36 的虚拟环境<br></code></pre></td></tr></table></figure></p><h3 id="python2安装pip">python2安装pip</h3><p>wget https://bootstrap.pypa.io/pip/2.7/get-pip.py 下载成功后执行python2 get-pip.py</p><p>指定python 安装numpy库： python2 -m pip install numpy</p><h3 id="python3安装-pip">python3安装 pip</h3><p>apt install python3-pip</p><h3 id="windows-启动-conda">windows 启动 conda</h3><p>$ source C:/Users/fgq/miniconda3/Scripts/activate base</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc 的标准库和头文件</title>
    <link href="/2022/07/19/gcc-so-include/"/>
    <url>/2022/07/19/gcc-so-include/</url>
    
    <content type="html"><![CDATA[<h3 id="libgcc_s.so.1是什么">libgcc_s.so.1是什么</h3><p><a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">The GCClow-level runtime library</a></p><p>会在有需要的时候自动启动的C运行时库，可以替代某些机器完成整数、浮点运算，还有一些其他的功能。</p><h3 id="运行时库">运行时库</h3><p>应用程序和操作系统之间的桥梁，对操作系统硬件的抽象，包括对IO操作、程序启动和程序退出、栈等的实现。不同的操作系统对应不同的运行时库，但提供的接口基本一致，比如windows和linux 的运行时库，都提供fread 功能，但是其实现应该是不一样的，fread就包括在运行时库中。</p><h3 id="编译参数顺序">编译参数顺序</h3><p>LINKFLAGS_AFTER_LIBS(False)决定cxxflags、ldflags（编译参数和链接参数）是放在库前还是库后，对cmake和bcloud 而言有用，对gcc而言没有所谓这些参数之分，都是编译参数，链接的库名也都是编译参数，但是编译参数之间的顺序可能会影响能否编译成功</p><h3 id="libc.so">libc.so</h3><p>/usr/lib/aarch64-linux-gnu/libc.so是个链接脚本，表示在链接时去链哪个库，可以根据需要选择动态库还是静态库</p><h3 id="符号集版本">符号集版本</h3><p>func@GLIBC_2.31</p><p>GLIBC_2.31表示符号集版本，向下兼容，即如果需要func@GLIBC_2.29时也没问题</p><h3 id="强符号和若符号">强符号和若符号</h3><p>符号表中的 STRONG 和 WEAK</p><p>强符号：全局且初始化的参数和默认的函数，都属于强符号，强符号全局只能唯一，找不到直接报undefined reference</p><p>弱符号：全局且未初始化的参数，也可以在代码中来指定。弱符号在链接时候找不到可以暂时用0地址代替，链接时不会报undefined，作为插件接口或用户自定义接口使用更加方便。</p><h3 id="gcc-安装">gcc 安装</h3><p>https://wenku.baidu.com/view/b73c43055a0102020740be1e650e52ea5418ce77.html?<em>wkts</em>=1676342805235</p><p>wget https://mirrors.ustc.edu.cn/gnu/gcc/gcc-7.5.0</p><p>Note: gcc 安装后 c 和 c++ 的标准库还是原来的版本</p><h3 id="添加系统头文件搜索路径">添加系统头文件搜索路径</h3><p>https://blog.csdn.net/yjk13703623757/article/details/83154578</p><p>gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）</p><h3 id="gcc-低版本问题">gcc 低版本问题</h3><p>gcc4 gcc5 不支持直接使用enum 作为map 的键指，需要自己指定hash方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>so</tag>
      
      <tag>include</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-usage</title>
    <link href="/2022/07/14/docker-usage/"/>
    <url>/2022/07/14/docker-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="docker-用法">docker 用法</h3><p>docker教程： https://yeasy.gitbook.io/docker_practice/image/build</p><h3 id="运行容器">运行容器</h3><p>初次运行<br /><code>docker run -itd image-id bash</code><br />//i 交互 t 终端 d 运行但不关闭，不进入docker</p><p><code>docker exec -it conatainer-id bash</code><br />// 进入docker,退出不关闭</p><p><code>docker run -id image-id bash</code><br />// 进入docker，退出关闭</p><h3 id="删除镜像和容器">删除镜像和容器</h3><p>https://chinese.freecodecamp.org/news/how-to-remove-images-in-docker/</p><p><code>docker stop container-id</code><br />// 关闭容器 <code>docker rm container-id</code> // 删除容器<code>docker rmi image-id</code><br />// 删除镜像 <code>docker stop $(docker ps -a -q)</code><br />// 停止所有容器运行 <code>docker rm $(docker ps -a -q)</code><br />// 删除所有容器</p><h3 id="根据dockerfile制作镜像">根据Dockerfile制作镜像</h3><p><code>docker buildx build -t hansanf/cuda-11.1:11.1.1-devel-cudnn-ubuntu18.04 --platform=x86_64  . --push</code><br />// buildx是制作多架构工具，可以不用 // -t tag, [仓库名]:[镜像tag] //--platform buildx要制作的哪个平台的镜像 // . Dockerfile的路径 // --push制作的镜像push到远程仓库，不会保留在本地，可以用 -o type=docker 替换</p><h3 id="pull和push">pull和push</h3><p><code>docker pull [仓库名]:[tag]</code></p><p><code>docker push [仓库名]:[tag]</code></p><h3 id="关闭打开和重启docker">关闭、打开和重启docker</h3><p>启动<br /><code>sudo systemctl start docker</code><br />关闭<br /><code>sudo  service docker stop</code></p><p>重启 <figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">sudo systemctl daemon-reload<span class="hljs-comment">;</span><br>sudo systemctl restart  docker<span class="hljs-comment">;</span><br>sudo sudo service docker restart<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p><h3 id="容器内进行可视化">容器内进行可视化</h3><p>设置 DISPLAY 环境变量，令 docker 内外一致, 比如均设置为 :1</p><p>冒号不能少</p><p>启动容器的时候加上： -e DISPLAY=$DISPLAY -v/tmp/.X11-unix/:/tmp/.X11-unix</p><h3 id="跨平台构建-docker-镜像">跨平台构建 Docker 镜像</h3><p>结论：在不使用nvidia的情况下，在开发机x86架构上构建arm64的docker镜像，在该镜像中进行开发，可以直接把程序移植到的arm盒子中运行</p><h4 id="跨-cpu-架构编译程序的方法">跨 CPU 架构编译程序的方法：</h4><h5 id="方法一直接在目标硬件上编译">方法一：直接在目标硬件上编译</h5><p>缺点：需每个人都直接操作目标硬件，在硬件资源不充足的情况下开发效率低。##### 方法二：模拟目标硬件 通过QEMU（quickemulator）模拟一个完整的操作系统，创建出通用的 ARM虚拟机，该虚拟机可以引导Linux，设置开发环境，也可以在虚拟机内编译程序。</p><p>缺点：模拟整个系统，包括计时器、内存控制器、总线控制器等硬件，但编译程序不需要这些硬件。##### 方法三：使用交叉编译器类似于方法一，只不过将编译过程放在开发机</p><h5id="方法四模拟目标硬件的用户空间">方法四：模拟目标硬件的用户空间</h5><p>QEMU 将通过binfmt_misc（Miscellaneous Binary Format）在 Linux内核中注册一个二进制转换处理程序，并在程序运行时动态翻译二进制文件，根据需要将系统调用从目标CPU 架构转换为当前系统的 CPU 架构。最终的效果看起来就像在本地运行目标CPU 架构的二进制文件。</p><h5id="跨平台构建docker就是方法四的演化">跨平台构建docker就是方法四的演化</h5><p>背景： 目前手上ARM盒子只有一个，资源有限；ARM盒子中，程序最终跑在docker里。</p><p>目标：以软件模拟的方式，实现开发机中使用ARM架构下的docker，使开发机中的docker环境和ARM盒子中的一样，从而在开发机中就可以进行移植。</p><figure><imgsrc="https://img-blog.csdnimg.cn/c39c902beb63427bb54f878b856fb08a.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h5 id="实现路线">实现路线：</h5><p>使用 buildx 命令(使用 BuildKit实现的)构建多种系统架构支持的 Docker镜像 BuildKit：镜像构建组件 <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs tcl">（<span class="hljs-number">1</span>）启动buildx插件<br>$ export DOCKER_CLI_EXPERIMENTAL=enabled<br>验证是否开启<br>$ docker buildx version<br>github.com/docker/buildx v0<span class="hljs-number">.3</span><span class="hljs-number">.1</span>-tp-docker <span class="hljs-number">6</span>db68d029599c6710a32aa7adcba8e5a344795a7<br><br>（<span class="hljs-number">2</span>）启动binfmt_misc<br>$ docker run --rm --privileged tonistiigi/binfmt:latest --install all<br>验证是 binfmt_misc 否开启：<br>$ ls -al /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/<br>总用量 0<br>总用量 0<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-aarch64</span>   // 支持arrch64架构<br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-arm</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-ppc64le</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> qemu-s390x</span><br>--w------- 1<span class="hljs-title"> root</span> root 0 11月 18 00:09<span class="hljs-title"> register</span><br>-rw-r--r-- 1<span class="hljs-title"> root</span> root 0 11月 18 00:12<span class="hljs-title"> status</span><br>验证是否启用了arrch64处理器：<br>$<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">enabled</span><br>interpreter /usr/bin/qemu-aarch64<span class="hljs-title"></span><br><span class="hljs-title">flags:</span> OCF<span class="hljs-title"></span><br><span class="hljs-title">offset</span> 0<span class="hljs-title"></span><br><span class="hljs-title">magic</span> 7f454c460201010000000000000000000200b7<span class="hljs-title"></span><br><span class="hljs-title">mask</span> ffffffffffffff00fffffffffffffffffeffff<br><br>(3)新建<span class="hljs-title"> builder</span> 实例<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> create</span> --use --name=mybuilder-cn --driver<span class="hljs-title"> docker-container</span> --driver-opt<span class="hljs-title"> image=dockerpracticesig/buildkit:master</span><br>启动构建器<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> inspect</span> mybuilder --bootstrap<br>[+]<span class="hljs-title"> Building</span> 5.0s (1/1)<span class="hljs-title"> FINISHED</span><br> =&gt; [internal]<span class="hljs-title"> booting</span> buildkit                                                                                                                          5.0s<br> =&gt; =&gt;<span class="hljs-title"> pulling</span> image<span class="hljs-title"> moby/buildkit:buildx-stable-1</span>                                                                                                       4.4s<br> =&gt; =&gt;<span class="hljs-title"> creating</span> container<span class="hljs-title"> buildx_buildkit_mybuilder0</span>                                                                                                     0.6s<span class="hljs-title"></span><br><span class="hljs-title">Name:</span> <span class="hljs-title">  mybuilder</span><br>Driver:<span class="hljs-title"> docker-container</span><br><span class="hljs-title"></span><br><span class="hljs-title">Nodes:</span><br>Name:<span class="hljs-title">      mybuilder0</span><br>Endpoint:<span class="hljs-title">  unix:///var/run/docker.sock</span><br>Status:<span class="hljs-title">    running</span><br>Platforms:<span class="hljs-title"> linux/amd64,</span> linux/arm64,<span class="hljs-title"> linux/ppc64le,</span> linux/s390x,<span class="hljs-title"> linux/386,</span> linux/arm/v7,<span class="hljs-title"> linux/arm/v6</span><br><br>(4）新建<span class="hljs-title"> Dockerfile</span> 文件<span class="hljs-title"></span><br><span class="hljs-title">FROM</span> --platform=$TARGETPLATFORM<span class="hljs-title"> alpine</span><br><span class="hljs-title"></span><br><span class="hljs-title">RUN</span> uname -a &gt; /os.txt<span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">CMD</span> cat /os.txt<br><br>(5)本地创建镜像<br>$<span class="hljs-title"> docker</span> buildx<span class="hljs-title"> build</span> -t<span class="hljs-title"> hello-arch-arm64</span> --platform=linux/arm64 -o<span class="hljs-title"> type=docker</span> .<br></code></pre></td></tr></table></figure></p><p>其他知识补充：</p><p>Qemu（quickemulator）是一个开源的托管虚拟机，通过纯软件来实现虚拟化模拟器，几乎可以模拟任何硬件设备。比如：Qemu可以模拟出一个ARM系统中的：CPU、内存、IO设备等，然后在这个模拟层之上，可以跑一台ARM虚拟机，这个ARM虚拟机认为自己在和硬件进行打交道，但实际上这些硬件都是Qemu模拟出来的。Qemu是使用纯软件模拟的，它的强项是模拟那些不涉及到外部的具体硬件设备的场景。因为QEMU是纯软件实现的，所有的指令都要经过QEMU，使得性能很差，而配合KVM则可以解决这一问题。</p><p>参考资料 https://cloud.tencent.com/developer/article/1543689https://yeasy.gitbook.io/docker_practice/buildx/multi-arch-imageshttps://www.cnblogs.com/sewain/p/14206365.html</p><h3 id="errors">ERRORS</h3><p>error-1 W: GPG error:https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu1804/x86_64InRelease: At least one invalid signature was encountered. E: Therepository'https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64InRelease' is not signed. N: Updating from such a repository can't bedone securely, and is therefore disabled by default. N: Seeapt-secure(8) manpage for repository creation and user configurationdetails. W: GPG error: http://security.ubuntu.com/ubuntu bionic-securityInRelease: At least one invalid signature was encountered. E: Therepository 'http://security.ubuntu.com/ubuntu bionic-security InRelease'is not signed. N: Updating from such a repository can't be donesecurely, and is therefore disabled by default. N: See apt-secure(8)manpage for repository creation and user configuration details. W: GPGerror: http://archive.ubuntu.com/ubuntu bionic InRelease: At least oneinvalid signature was encountered. E: The repository'http://archive.ubuntu.com/ubuntu bionic InRelease' is not signed. N:Updating from such a repository can't be done securely, and is thereforedisabled by default. N: See apt-secure(8) manpage for repositorycreation and user configuration details. W: GPG error:http://archive.ubuntu.com/ubuntu bionic-updates InRelease: At least oneinvalid signature was encountered. E: The repository'http://archive.ubuntu.com/ubuntu bionic-updates InRelease' is notsigned. N: Updating from such a repository can't be done securely, andis therefore disabled by default. N: See apt-secure(8) manpage forrepository creation and user configuration details. W: GPG error:http://archive.ubuntu.com/ubuntu bionic-backports InRelease: At leastone invalid signature was encountered. E: The repository'http://archive.ubuntu.com/ubuntu bionic-backports InRelease' is notsigned. N: Updating from such a repository can't be done securely, andis therefore disabled by default. N: See apt-secure(8) manpage forrepository creation and user configuration details.</p><p>硬盘空间不足了</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc-options</title>
    <link href="/2022/07/14/gcc-options/"/>
    <url>/2022/07/14/gcc-options/</url>
    
    <content type="html"><![CDATA[<h3 id="gcc-的编译选项">gcc 的编译选项</h3><p>gcc官方手册：https://gcc.gnu.org/onlinedocs/</p><p>7.5手册：https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/#toc-GCC-Command-Options</p><p>链接选项：https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gcc/Link-Options.html#Link-Options</p><h4 id="fpic-和-fpie">-fPIC 和-fPIE</h4><p>-fPIC 用在动态库的编译，产生位置无关的代码</p><p>-fPIE 用在可执行程序的编译</p><p>两者在效果上一样，都是把代码中的逻辑地址转为相对地址，但是作用上不一样。-fPIC一般是动态库编译必须设置的，因为可能在链接时，多个模块之间的重定向可能会出现冲突。而-fPIE在可执行程序的编译中可加可不加，其将绝对地址转为相对地址，在一定程度上提高了安全性，另外相对寻址的方式可能会让程序在启动速度慢一点。</p><p>PIE详解：https://www.redhat.com/en/blog/position-independent-executables-pie</p><h4 id="l-rpath和-rpath-link的区别">-L、-rpath和-rpath-link的区别</h4><p>-L 选项： -L 选项用于指定链接器在链接程序时查找库文件的路径。它告诉链接器在指定的路径中搜索库文件，以解析程序中的库依赖关系。通常，您可以使用 -L来指定非标准库目录，以便链接器能够找到您自己编译或第三方库的位置。示例：-L/path/to/custom/libraries</p><p>-rpath 选项： -rpath选项用于在可执行文件中嵌入运行时库的搜索路径。<br />它允许您指定在程序运行时查找共享库的路径，而不仅仅是在链接时。<br />运行时，程序将在指定的路径中搜索共享库，以满足依赖关系。<br />示例：-Wl,-rpath,/path/to/runtime/libs</p><p>-rpath-link 选项：<br />-rpath-link 选项类似于-rpath，但它用于在链接时将库搜索路径嵌入到可执行文件中，而不是运行时。<br />这可以用来解决在链接时将某个库链接到了其他共享库版本而不是预期版本的问题。<br />-rpath-link 可以影响到链接过程中的库搜索路径，但不会影响运行时。<br />示例：-Wl,-rpath-link,/path/to/runtime/libs</p><p>总结：<br />-L 用于链接时，指定库文件的搜索路径。 -rpath用于运行时，嵌入可执行文件中，指定共享库的搜索路径。 -rpath-link用于链接时，指定库文件的搜索路径，但不会影响运行时。这些选项通常用于处理库依赖关系，特别是当您有自定义库的位置或多个版本的库时，可以使用这些选项来确保链接器和运行时都能正确找到所需的库。</p><h4 id="l-和--l-的顺序问题">-L 和 -l 的顺序问题</h4><p>-L 搜索路径时有顺序，按照从前往后；-l 搜索库时没有顺序</p><h4 id="强制链接没有使用的库">强制链接没有使用的库</h4><p>-Wl,--no-as-needed</p><h4 id="只链接使用到的库默认">只链接使用到的库（默认）</h4><p>-Wl,--as-needed</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const_cast用法</title>
    <link href="/2022/07/11/cpp-const-cast/"/>
    <url>/2022/07/11/cpp-const-cast/</url>
    
    <content type="html"><![CDATA[<h2 id="const_cast">const_cast</h2><p>const_cast&lt;&gt; &lt;&gt;必须是指针或引用</p><h2 id="const-stdshared_ptr去-const">conststd::shared_ptr<const class_nam>去 const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; <span class="hljs-title">const_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(const_ptr).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">//ptr-&gt;x = 100; //error</span><br>        <span class="hljs-comment">//std::shared_ptr&lt;A&gt; ptr = const_cast&lt;std::shared_ptr&lt;A&gt;&gt;(const_ptr);  //error</span><br>        std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; ptr = <span class="hljs-keyword">const_cast</span>&lt;std::shared_ptr&lt;<span class="hljs-type">const</span> A&gt; &amp;&gt;(const_ptr); <span class="hljs-comment">//必须是const_cast&lt;&amp;&gt; 必须加引用</span><br><br>        A &amp;a = <span class="hljs-built_in">const_cast</span>&lt;A &amp;&gt;(*const_ptr); <span class="hljs-comment">// const_cast&lt;&amp;&gt; 必须加引用</span><br>        a.x = <span class="hljs-number">100</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a.x = &quot;</span> &lt;&lt; a.x &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;const_ptr-&gt;x = &quot;</span> &lt;&lt; const_ptr-&gt;x &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp_mutable</title>
    <link href="/2022/07/06/cpp-mutable/"/>
    <url>/2022/07/06/cpp-mutable/</url>
    
    <content type="html"><![CDATA[<h3 id="mutable-关键字">mutable 关键字</h3><p><a href="https://www.jianshu.com/p/b2883dbf3854">mutabel 介绍</a></p><h4 id="为什么stdmutex-前通常用mutable-修饰">为什么std::mutex前通常用mutable 修饰</h4><p>在const成员函数中，对mutex的加锁和释放锁操作会违背const的不可变语义，所以，只能将mutex定义为mutable，从而可以在const修饰的函数中加锁，实现线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cal</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Cal</span>(<span class="hljs-type">int</span> n) &#123;num = n;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc_num</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        ++num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <span class="hljs-comment">//const m 状态的改变会修改const 语义，但不报错？</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">mutable</span> std::mutex m;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Cal c&#123;<span class="hljs-number">0</span>&#125;;<br>    std::cout &lt;&lt; c.<span class="hljs-built_in">get_num</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_debug_tools</title>
    <link href="/2022/07/05/debug-tools/"/>
    <url>/2022/07/05/debug-tools/</url>
    
    <content type="html"><![CDATA[<h2 id="c-debug命令和工具">C++ Debug命令和工具</h2><h3 id="readelf">readelf</h3><p>查看可执行文件或库的符号表 <figure class="highlight ada"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ada">readelf -s ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure> 查看可执行文件或库的动态库表<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">readelf -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></p><h3 id="objdump">objdump</h3><p>查看汇编情况 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">objdump -d ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></p><h3 id="ldd">ldd</h3><p>查看动态库的链接情况 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ldd ./a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></p><h3 id="ld_preload">LD_PRELOAD</h3><p>在执行该文件前预加载库，要加具体的库名，LD_PRELOAD的值只在当前语句生效<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">env LD_PRELOAD=<span class="hljs-regexp">/home/</span>fenggq<span class="hljs-regexp">/libutil.so ./</span>a.out<br></code></pre></td></tr></table></figure></p><h3 id="查看系统默认链接的库路径">查看系统默认链接的库路径</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br>    # output: include /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">cat</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span>.d/*.<span class="hljs-keyword">conf</span><br>    # output: 所有的默认库路径<br></code></pre></td></tr></table></figure><h3 id="gdb">gdb</h3><p>使用gdb调试带输入参数的程序 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gdb --<span class="hljs-keyword">args</span> ./a.<span class="hljs-keyword">out</span> <span class="hljs-keyword">args</span><br></code></pre></td></tr></table></figure></p><h3 id="file查看文件属性">file查看文件属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file msf<br>msf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, stripped<br></code></pre></td></tr></table></figure><p>该文件被stripped ，去除掉了符号表信息</p><h3 id="strip-命令">strip 命令</h3><p>去掉符号表和调试等信息 <ahref="https://blog.51cto.com/u_15614325/5272498">https://blog.51cto.com/u_15614325/5272498</a></p><p>符号表和striphttps://xuanxuanblingbling.github.io/ctf/tools/2019/09/06/symbol/</p><p>tmp_LD_PRELOAD=<span class="math inline">\({LD_PRELOAD} unsetLD_PRELOAD nohup cyber_launch start fusion_tracker.launch &amp; exportLD_PRELOAD=\)</span>{tmp_LD_PRELOAD}</p><h3 id="core文件去哪了">core文件去哪了</h3><p><a href="http://www.hansanf.space/2023/07/29/core-file/">core文件设置</a> <ahref="https://www.jianshu.com/p/7317910210a4">core文件去哪了</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode tips</title>
    <link href="/2022/06/29/vscode-tips/"/>
    <url>/2022/06/29/vscode-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="code命令终端直接打开文件">code命令终端直接打开文件</h3><p>code 命令启动vscode</p><p>开启方式的 ctrl+shift+p 输入code，选择 install不好用的时候，uninstall 再 install 一遍</p><p><code>code [path]</code></p><p>https://blog.csdn.net/weixin_42881768/article/details/119635248</p><h3 id="vscode-正则表达式">vscode 正则表达式</h3><p>查找 // FGQ ******** QGF 的注释： <figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> [\w\s,;.]*?FGQ [\w\s,;.]*? QGF<br></code></pre></td></tr></table></figure></p><h3 id="c_cpp_properties.json-配置">c_cpp_properties.json 配置</h3><h4 id="控制宏的高亮">控制宏的高亮</h4><p>step1. 安装C++ intelligence 插件 step2. 设置里搜 Dim InactiveRegions，勾选该设置 step3. c_cpp_proerties.json 里 设置 defines</p><h4 id="设置头文件搜索路径">设置头文件搜索路径</h4><p>在 c_cpp_proerties.json 里设置 includePath</p><h4 id="完整c_cpp_proerties.json展示">完整c_cpp_proerties.json展示</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;/l4t/targetfs/usr/src/jetson_multimedia_api/**&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-string">&quot;USE_NVIDIA_TEGRA&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gcc&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c17&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;linux-gcc-x64&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span><br><br>    <span class="hljs-attr">&quot;C_Cpp.default.includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">// 上面的没法用时 用这个，应该和vscode 版本有关</span><br>      <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br>    <span class="hljs-attr">&quot;editor.bracketPairColorization.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 控制是否对括号着色</span><br>    <span class="hljs-attr">&quot;editor.bracketPairColorization.independentColorPoolPerBracketType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 各类括号着色等级不独立</span><br>    <span class="hljs-attr">&quot;editor.guides.bracketPairs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启用括号指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.bracketPairsHorizontal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;active&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启用水平括号指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.highlightActiveIndentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用高亮选中的缩进指导线</span><br>    <span class="hljs-attr">&quot;editor.guides.indentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用缩进指导线</span><br>    <span class="hljs-attr">&quot;editor.semanticHighlighting.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 颜色主题</span><br>    <span class="hljs-attr">&quot;editor.detectIndentation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁用自动检测文件缩进模式和缩进大小，即打开文件后自动将文件更改为 VSCode 配置的缩进格式</span><br>    <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 保存自动格式化代码</span><br>    <span class="hljs-attr">&quot;editor.formatOnPaste&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 粘贴自动格式化</span><br>      <span class="hljs-comment">// explorer</span><br>    <span class="hljs-attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 移动文件时无需确认</span><br>    <span class="hljs-attr">&quot;explorer.confirmDelete&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 删除文件确认</span><br>    <span class="hljs-attr">&quot;explorer.incrementalNaming&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;smart&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 粘贴同名文件时的重命名方式;smart: 在重复名称末尾智能地添加/递增数字</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="vscode-快捷键">vscode 快捷键</h3><p>ctrl+shift+{ 折叠内容</p><p>ctrl+shift+} 展开内容</p><p>设置中搜索forward backward 关键字可以设置前进、后退快捷键</p><p>control + q 左侧功能栏选择 control + w vscode打开窗口切换，关键字搜索 切换窗口</p><h3 id="vscode-插件合集">vscode 插件合集</h3><ol type="1"><li>git：gitlen; gitblame; git graph;</li><li>Bracket Select 通过快捷键 alt+a 和 alt+z 选中和取消括号包含内容</li><li>Bracket Lens 在 } 的后面标示 { 的位置</li><li>indent rainbow 相同缩进的为统一颜色</li><li>blockman 将代码块高亮显示</li><li>Peacock 改变边框颜色</li></ol><h3 id="vscode-浏览-gitlab仓库">vscode 浏览 gitlab仓库</h3><ol type="1"><li>安装 gitlab workflow 插件</li><li>配置个人token，在gitlab个人设置界面 access token =&gt; 勾选 read_api和 read_repository</li><li>ctrl+shift+p Gitlab: Add Account to VS Code</li><li>ctrl+shift+p Gitlab: Open Remote read_repository可能需要一点时间认证？ 过了一会才能浏览 repository 的,先输入个a试下</li></ol><h3 id="vscode-调试c">vscode 调试C++</h3><p>step1. 安装 gdb debug step2. 点击左侧调试按钮，创建 launch.json<br />note: 断点调试需要编译时加 -g <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br>  <span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br>  <span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//配置名称，显示在配置下拉菜单中</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//配置类型</span><br>          <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//请求配置类型，可以是启动或者是附加</span><br>          <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//程序可执行文件的完整路径，$&#123;workspaceFolder&#125;表示远程连接的初始路径</span><br>          <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//传递给程序的命令行参数</span><br>          <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//可选参数，如果为true,调试程序应该在入口（main）处停止</span><br>          <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//目标的工作目录</span><br>          <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//表示要预设的环境变量</span><br>          <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><span class="hljs-comment">//如果为true，则为调试对象启动控制台</span><br>          <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//要连接到的控制台启动程序</span><br>          <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">//为了安装基础调试程序而执行的一个或多个GDB/LLDB命令</span><br>              <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>              <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>远程调试配置 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-regexp">//</span> 使用 IntelliSense 了解相关属性。 <br>  <span class="hljs-regexp">//</span> 悬停以查看现有属性的描述。<br>  <span class="hljs-regexp">//</span> 欲了解更多信息，请访问: https:<span class="hljs-regexp">//g</span>o.microsoft.com<span class="hljs-regexp">/fwlink/</span>?linkid=<span class="hljs-number">830387</span><br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>  <span class="hljs-string">&quot;configurations&quot;</span>: [<br>      &#123;<br>          <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;(gdb) 启动&quot;</span>, <span class="hljs-regexp">//</span>配置名称，显示在配置下拉菜单中<br>          <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>, <span class="hljs-regexp">//</span>配置类型<br>          <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>, <span class="hljs-regexp">//</span>请求配置类型，可以是启动或者是附加<br>          <span class="hljs-string">&quot;program&quot;</span>: <span class="hljs-string">&quot;/home/guoqing.feng/code/perception-bev/build_aarch64_orin/output/test/bin/test_main&quot;</span>, <span class="hljs-regexp">//</span>程序可执行文件的完整路径，<span class="hljs-variable">$&#123;workspaceFolder&#125;</span>表示远程连接的初始路径<br>          <span class="hljs-string">&quot;args&quot;</span>: [<br>            <span class="hljs-string">&quot;--flagfile=config/flags.conf&quot;</span><br>          ], <span class="hljs-regexp">//</span>传递给程序的命令行参数<br>          <span class="hljs-string">&quot;stopAtEntry&quot;</span>: true,<span class="hljs-regexp">//</span>可选参数，如果为true,调试程序应该在入口（main）处停止<br>          <span class="hljs-string">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>, <span class="hljs-regexp">//</span>目标的工作目录<br>          <span class="hljs-string">&quot;environment&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;LD_LIBRARY_PATH&quot;</span>,<br>                <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;/mnt/data0/guoqing.feng/perception/output/test/../third_party/lib:/mnt/data0/guoqing.feng/perception/output/test/../third_party:/mnt/data0/guoqing.feng/perception/output/test/../lib:/usr/local/cuda-11.4/lib64&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;GLOG_v&quot;</span>,<br>                <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;5&quot;</span><br>            &#125;<br>        ],<br>          <span class="hljs-string">&quot;externalConsole&quot;</span>: false,<span class="hljs-regexp">//</span>如果为true，则为调试对象启动控制台<br>          <span class="hljs-string">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,<span class="hljs-regexp">//</span>要连接到的控制台启动程序<br>          <span class="hljs-string">&quot;setupCommands&quot;</span>: [ <span class="hljs-regexp">//</span>为了安装基础调试程序而执行的一个或多个GDB/LLDB命令<br>              &#123;<br>                  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,<br>                  <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                  <span class="hljs-string">&quot;ignoreFailures&quot;</span>: true<br>              &#125;<br>          ],<br>          <span class="hljs-string">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;/l4t/toolchain/bin/aarch64-linux-gdb&quot;</span>,<br>          <span class="hljs-string">&quot;miDebuggerServerAddress&quot;</span>:<span class="hljs-string">&quot;10.31.1.173:12399&quot;</span><br>      &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure> 板子上执行: gdbserver 10.31.1.172:10099exec_file args</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yuv2rgb</title>
    <link href="/2022/06/29/yuv2rgb/"/>
    <url>/2022/06/29/yuv2rgb/</url>
    
    <content type="html"><![CDATA[<h1 id="yuv详解">YUV详解</h1><h3 id="yuv分类">YUV分类</h3><h5 id="按采样方式分类">1、按采样方式分类</h5><p>（1） YUV444: 全量UV，类似于RGB，每个像素点都有一套自己的YUV <imgsrc="https://img-blog.csdnimg.cn/000b2132c524457583a034fcb2bd787c.png#pic_center"alt="在这里插入图片描述" /> （2） YUV422:50%的UV，与全量相比，UV数量减少一半，每行中由 2 个 Y 分量共用一套 UV分量。 <imgsrc="https://img-blog.csdnimg.cn/eea18cfb6599473aab6374a6cc7b1fc2.png#pic_center"alt="在这里插入图片描述" /></p><p>（3）YUV420: 25%的UV， UV的数量减少到1/4，每行两个Y、每列两个Y，共由4 个 Y 分量共用一套 UV 分量。<imgsrc="https://img-blog.csdnimg.cn/e01002399f09464e8916f4421fa5e8c0.png#pic_center"alt="在这里插入图片描述" /> ##### 2、按内存中排列方式分类 （1）PlanarYUV 三个分量分开存放 （2）Semi-Planar Y 分量单独存放，UV 分量交错存放（3）Packed YUV 三个分量全部交错存放</p><p>以YUV420为例：</p><h5 id="ffmpeg中h264解码后的yuv格式">3、ffmpeg中h264解码后的YUV格式</h5><h3 id="yuv转rgb">YUV转RGB</h3><p>色彩空间： 公式：</p><h5 id="ffmpeg接口">ffmpeg接口</h5><h5 id="cuda实现">cuda实现</h5><p>参考： <ahref="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a><ahref="https://cloud.tencent.com/developer/article/1612357">https://cloud.tencent.com/developer/article/1612357</a><ahref="https://juejin.cn/post/6920848468797816846">https://juejin.cn/post/6920848468797816846</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf</title>
    <link href="/2022/06/29/protobuf/"/>
    <url>/2022/06/29/protobuf/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是protobuf">什么是protobuf</h2><p>Protocol Buffers(简称Protobuf) ，是Google出品的序列化框架。简单来讲，就是支持序列化与反序列化，用于数据的存储、传输。protobuf将数据接口定义在.proto文件中，然后再利用protoc翻译为所需要的程序语言代码（类似于接口描述语言？）</p><p><ahref="https://developers.google.com/protocol-buffers/docs/cpptutorial">官方Guide</a>## 怎么用protobuf ### 安装 ...省略 ### C++使用 #### 数据类型定义 <ahref="https://blog.csdn.net/wangchong_fly/article/details/47614699">数据类型对应关系</a>#### demo step-1定义.proto <figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// demo_msg.proto</span><br>syntax = <span class="hljs-string">&quot;proto2&quot;</span>; <span class="hljs-comment">//版本选择，proto2 or proto3</span><br>package fgq.demo; <span class="hljs-comment">// C++中的namespace,用.分隔</span><br><br>message PersonalInfo &#123;<br>required bytes name = <span class="hljs-number">1</span>;<br>optional bytes address = <span class="hljs-number">2</span>;<br>repeated bytes friends = <span class="hljs-number">3</span>;<br>&#125;;<br><span class="hljs-comment">//等号后面是field number,从1开始计数</span><br><span class="hljs-comment">//C++中字段名不区分大小写，即name和Name，在C++接口中都是name</span><br></code></pre></td></tr></table></figure> step-2将.proto翻译为.cpp和.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc -I= demo_msg.proto的目录 --cpp_out=存放.cpp和.h的目录 demo_msg.proto的路径<br></code></pre></td></tr></table></figure><p>-I参数和gcc的-I参数类似？</p><p>step-3 .cpp中引入.pb.h头文件，就可以使用protobuf所提供的cpp接口了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;demo_msg.pb.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">g++ main.cpp -I [--cpp_out所指定的目录]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>atomic</title>
    <link href="/2022/06/29/atomic/"/>
    <url>/2022/06/29/atomic/</url>
    
    <content type="html"><![CDATA[<h3 id="内存模型">内存模型</h3><p>内存模型：指令执行顺序的模型</p><p>现代的处理器基本是并发式处理机器指令的,在一个cpu 时钟 issue多条指令。</p><p>指令若总是严格按照书写顺序执行的，则称这样的内存模型为强顺序的(strongordered),按照一定规则允许乱序的，称为弱顺序的(weak ordered)。</p><p>内存模型详细介绍：</p><ul><li><p><ahref="https://www.zhihu.com/question/24301047">https://www.zhihu.com/question/24301047</a></p></li><li><p><ahref="https://www.zhihu.com/question/24301047">https://zhuanlan.zhihu.com/p/264975254</a></p></li></ul><h3 id="c-atomix-内存顺序">C++ atomix 内存顺序</h3><p>根据允许指令的混乱程度，C++为原子操作指定了内存顺序（memory_order），其包含6种：- momory_order_relaxed, - memory_order_consume, - memory_order_acquire,- memory_order_release, - memory_order_acq_rel, -memory_order_seq_cst.</p><figure><imgsrc="https://img-blog.csdnimg.cn/56a139b6a7184bd5af35c4df4610a9aa.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>虽然共有 6 个选项,但它们表示的是三种内存模型:</p><p><strong>sequential consistent</strong>: memory_order_seq_cst</p><p>如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行。相当于所有的线程都用同一份内存，对同一个变量保持时刻可见</p><p><a href="https://www.zhihu.com/question/24301047">使用示例</a></p><p><strong>relaxed</strong>: memory_order_seq_cst</p><p>在同一线程内对同一变量的操作仍保持happens-before关系，但这与别的线程无关。在 relaxed ordering中唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排。</p><p><strong>acquire release</strong>: memory_order_consume,memory_order_acquire, memory_order_release, memory_order_acq_rel</p><p>在这种序列模型下,原子 load 操作是 acquire 操作(memory_order_acquire),原子 store 操作是release操作(memory_order_release).</p><p>原子read_modify_write操作(如fetch_add(), exchange())可以是 acquire,release 或两者皆是(memory_order_acq_rel).</p><p>同步是成对出现的,它出现在一个进行 release 操作和一个进行 acquire操作的线程间。</p><h3 id="c-atomic-用法">C++ atomic 用法</h3><h3 id="atomic-和-mutex-区别">atomic 和 mutex 区别</h3><p>atomic 可以实现数据结构的无锁设计，为什么还要用 mutex 呢？</p><p>std::atomic原子操作，主要是保护一个变量，互斥量的保护范围更大，可以一段代码或一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>callback</title>
    <link href="/2022/06/15/callback/"/>
    <url>/2022/06/15/callback/</url>
    
    <content type="html"><![CDATA[<h2 id="c回调函数">C++回调函数</h2><h3 id="函数指针">函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(* func)(<span class="hljs-type">int</span>)<br>返回值类型(* 函数指针变量名)(参数)<br></code></pre></td></tr></table></figure><h3 id="stdfunction">std::function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;<br>             &lt;返回值类型 (参数) &gt;<br></code></pre></td></tr></table></figure><h3 id="常见用法">常见用法</h3><p>1、普通函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(<span class="hljs-type">void</span>(* cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-comment">// std::function</span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">register_func1</span>(callback);<br>    <span class="hljs-built_in">register_func2</span>(callback);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2、成员函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func1</span><span class="hljs-params">(A a, <span class="hljs-type">void</span>(A::*cb)(<span class="hljs-type">int</span>))</span></span>&#123;<br>    (a.*cb)(<span class="hljs-number">100</span>); <span class="hljs-comment">// Note: 要用括号; 要带*</span><br>&#125;<br><br><span class="hljs-comment">// std::function </span><br><span class="hljs-keyword">using</span> Callback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_func2</span><span class="hljs-params">(Callback cb)</span></span>&#123;<br>    <span class="hljs-built_in">cb</span>(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    A a;<br>    <span class="hljs-built_in">register_func1</span>(a, &amp;A::callback); <span class="hljs-comment">// 要传入两个参数</span><br><br>    <span class="hljs-keyword">auto</span> cb = std::<span class="hljs-built_in">bind</span>(&amp;A::callback, &amp;a, std::placeholders::_1); <span class="hljs-comment">// 使用std::bind将对象地址绑定到this位置。placehoders::_1 待传入参数的占位符。</span><br>    <span class="hljs-built_in">register_func2</span>(cb);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="summary">Summary</h3><p>1、函数指针是C中定义的实际函数的地址. std ::function是一个包装器,可以容纳任何类型的可调用对象(可以像函数一样使用的对象)</p><p>2、函数指针也可以和std::bind配合使用，但是std::function功能更强大，和std::bind配合更方便</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回调函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_usage</title>
    <link href="/2022/05/06/hexo-usage/"/>
    <url>/2022/05/06/hexo-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="部署hexo环境">部署hexo环境</h3><ol type="1"><li>首先安装node.js和Git <figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>node.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br><span class="hljs-comment">#查看安装的版本</span><br>node -v<br>git --version<br></code></pre></td></tr></table></figure></li><li>安装hexo <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure></li><li>创建博客目录，初始化 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>hexo init<br></code></pre></td></tr></table></figure></li></ol><h3 id="移植到另一台电脑">移植到另一台电脑</h3><ol type="1"><li>备份好原来的 blog 目录 =&gt; old_blog</li><li>新电脑配置好 hexo 环境，并新建好blog 目录 =&gt; new_blog</li><li>将 old_blog 目录下的 _conifg.yml、source、和themes 复制到 new_blog目录 Note：可以将blog 目录直接备份在github repo中，可以很方便的进行移植。</li><li>验证本地版本是否可用：<code>hexo g; hexo s</code><br /></li><li>此时还不能远程推送到git repo, 需要安装hexo-deployer-git插件<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li>如果是ssh 方式登录github 需要上传新电脑公钥到github</li><li>Work Done</li></ol><h3 id="hexo集成到docker镜像">hexo集成到docker镜像</h3><p><ahref="https://gitee.com/LakeVilladom/docker-hexo">docker-hexo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug记录：常量值截断(truncation of constant value)</title>
    <link href="/2022/05/05/bug-truncation-of-constant-value/"/>
    <url>/2022/05/05/bug-truncation-of-constant-value/</url>
    
    <content type="html"><![CDATA[<h3 id="char和unsigned-char">char和unsigned char</h3><p><strong>char的取值范围</strong>：-128~127   -128: 16进制0x80二进制1000 0000   -127: 16进制0xff  二进制11111111，注意第一位是符号位，0111 1111是127</p><p><strong>unsigned char的取值范围</strong>：0~255，16进制0x00 ~0xff</p><h3 id="内存中的0xf0-1111-0000">内存中的0xf0: 1111 0000</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x = <span class="hljs-number">0xf0</span>; <span class="hljs-comment">// 十进制数大小为240，超出了127，导致常量值截断</span><br><span class="hljs-keyword">if</span>(<span class="hljs-number">0xf0</span> == x)&#123; <span class="hljs-comment">// x86机器上判断为false，arm机器上可能判断为true</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;x == 0xf0&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout&lt;&lt; <span class="hljs-string">&quot;char x= &quot;</span> &lt;&lt; x <br>&lt;&lt; <span class="hljs-string">&quot;\tunsigned char x = &quot;</span> &lt;&lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)x <br>&lt;&lt; <span class="hljs-string">&quot;\tint x = &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)x &lt;&lt; std::endl; <span class="hljs-comment">// 在不同机器上可能出现不同值</span><br></code></pre></td></tr></table></figure><p>mac(m1 arm64)打印结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">-16</span>  <br></code></pre></td></tr></table></figure><p>linux(x86)打印结果和上面一致</p><p>arm盒子(arm64)打印结果： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> x= �<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x = �<span class="hljs-type">int</span> x = <span class="hljs-number">240</span><br></code></pre></td></tr></table></figure>      char和unsignedchar乱码，直接看int，一个取值-16，一个取值240</p><p><strong>取值为-16的情况：</strong></p><p>     int类型时，-16的二进制为 1000 0000| 0000 0000| 0000 0000| 00010000，最后一个字节是0001 0000</p><p>     而1111 0000 取反为 0000 11111，加1正好是00010000，即0xf0的补码是00010000，因此在将(char)0xf0变为int类型时的十进制数-16，至于为什么是这样的规则我也不知道。<strong>取值为240的情况：</strong></p><p>     int类型时，240的二进制为 0000 0000| 0000 0000| 0000 0000| 11110000，最后一个字节就是1111 0000</p><p>    综上，有些机器在处理常量截断时是取补码，而有些机器是取正码，即不变。实际上，<code>char x = 0xf0</code>这种用法本身就是错误的，不应该使用，对二进制字节比较时最好选用<code>unsigned char</code>类型。</p><p>    不过，在对内存中的二进制字节进行判断时，也可以使用 if(x ==(char)0xf0)这种形式。</p><p><strong>Note &amp; 猜测:</strong></p><p>     <code>char x = 0xf0</code>虽然发生了常量截断，但是内存中的值确实是0xf0，只不过在从内存中读取出来时不同类型有不同的取值。</p><p>参考：</p><p><ahref="http://www.cplusplus.com/forum/beginner/48577/">http://www.cplusplus.com/forum/beginner/48577/</a><ahref="https://zhidao.baidu.com/question/533897399.html">https://zhidao.baidu.com/question/533897399.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_in_mac</title>
    <link href="/2022/05/04/test-in-mac/"/>
    <url>/2022/05/04/test-in-mac/</url>
    
    <content type="html"><![CDATA[<p>a test for mac hexo second test</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git_ssh_usage</title>
    <link href="/2021/11/26/git-ssh-usage/"/>
    <url>/2021/11/26/git-ssh-usage/</url>
    
    <content type="html"><![CDATA[<h3 id="git在线练习平台">git在线练习平台</h3><p><ahref="https://learngitbranching.js.org">https://learngitbranching.js.org</a></p><p><ahref="https://mp.weixin.qq.com/s/sp1YUQ2vnQaIGH4tO3j1Vw">git常用命令和基本概念</a></p><h3 id="代码托管平台push-时需要的-ssh-密钥">代码托管平台push 时需要的ssh 密钥</h3><h4 id="ssh-密钥生成">ssh 密钥生成</h4><ol type="1"><li>生成ssh密钥 ssh-keygen -t rsa 可以直接一路回车</li><li>打印密钥内容 cat ~/.ssh/id_rsa.pub</li><li>复制密钥到托管平台</li><li>查看.ssh/config文件，是否配置了你的ssh，没有配置不会被使用（在多人使用的情况下要注意）</li></ol><h4 id="ssh-配置">ssh 配置</h4><h5id="多个用户时指定用户在代码托管平台所用的密钥">多个用户时，指定用户在代码托管平台所用的密钥</h5><p>ssh-keygen 生成密钥时指定名称，比如加个后缀.github来表示该密钥是用于github</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">Host github.com<br>    User hansanf<br>    IdentityFile ~/.ssh/id_rsa.github<br></code></pre></td></tr></table></figure><h6 id="ssh-连接远程主机时别名登录和免密登录">ssh连接远程主机时别名登录和免密登录</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 Host fgq<br>2     HostName 主机端ip<br>3     User 主机端用户名<br>4     Port 22<br>5     IdentityFile ~/.ssh/id_rsa.remote  <span class="hljs-comment"># 连接主机所用的密钥，需要将公钥放在主机端</span><br></code></pre></td></tr></table></figure><p>将公钥放在主机端 ~/.ssh/ 目录下使用<code>ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22 username@192.168.11.11</code>，或scp传输到 .ssh 目录下, 然后就可以通过 <code>ssh fgq</code>登录远程主机了</p><h6 id="ssh-通过跳板机登录远程主机">ssh 通过跳板机登录远程主机</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host fgq<br>    HostName 192.168.2.100<br>    User caros<br>    Port 22<br>    ProxyCommand ssh middle@relay  %h:%p<br><br>Host relay<br>    HostName 192.168.1.10<br>    User middle<br>    Port 22<br></code></pre></td></tr></table></figure><p>上述配置实现<code>ssh fgq</code>时先登录relay 机器，然后再登录到 fgq主机。</p><h3 id="github登录方式">github登录方式</h3><p><ahref="https://blog.csdn.net/nbaDWde/article/details/80360836?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https和ssh两种</a><ahref="https://baijiahao.baidu.com/s?id=1717846683433344604&amp;wfr=spider&amp;for=pc">https密码设置</a></p><h3 id="配置文件">配置文件</h3><h4 id="全局配置文件">全局配置文件</h4><p>全局配置文件有<code>~/.gitconfig</code>和<code>~/.git-credentials</code>两个</p><p><code>~/.gitconfig</code>对应着<code>git config --global</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">//查<br>git config --global --list<br> <br>git config --global user.name<br> <br>//增<br>git config  --global --add user.name fgq<br> <br>//删<br>git config  --global --<span class="hljs-built_in">unset</span> user.name<br> <br>//改<br>git config --global user.name fgq<br></code></pre></td></tr></table></figure><p>比如修改GitHub账号名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config  --global  user.name hansanf<br></code></pre></td></tr></table></figure><p><code>~/.gitconfig</code>文件就会相应的做出修改 <imgsrc="https://img-blog.csdnimg.cn/6e26501083b945e1a65f2c225387b949.png"alt="在这里插入图片描述" /></p><p><code>~/.git-credentials</code>中文是资格证书，里面保存github的token，使每次登陆都可以免密,该部分应该是https token,也可以直接使用上面介绍的 ssh 配置。</p><p>需要注意的是, 在hexo 的 deploy (_config.yml) 中, <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:hansanf/hansanf.github.io.git</span>    <span class="hljs-comment"># ssh 方式, 需要设置 ssh</span><br>    <span class="hljs-comment">#repo: https://github.com/hansanf/hansanf.github.io   #https 方式, 需要设置 git-credentials </span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure> repo的地址可以在 github 的 repo 页面，点击 Code, 查看对应的 https 地址和ssh地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://GitHub用户名:具体的token@github.com<br></code></pre></td></tr></table></figure><h4 id="局部配置文件">局部配置文件</h4><p>在使用<code>git init 文件目录</code>命令配置的git工作区中，即<code>文件目录/.git/config</code>，是局部配置文件，对应着<code>git config --local</code>命令。</p><p><code>.gitignore</code>也是只对当前工作区起作用，可以把要忽略的文件名填进去，然后Git就会自动忽略这些文件</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有.开头的隐藏文件:</span><br>.*<br><span class="hljs-comment"># 忽略所有.class文件:</span><br>*.class<br><br><span class="hljs-comment"># 不忽略.gitignore和App.class:</span><br>!.gitignore<br>!App.class<br></code></pre></td></tr></table></figure><h3 id="git-命令">git 命令</h3><h4id="把修改删除新建文件添加到暂存区">把修改/删除/新建文件添加到暂存区</h4><ul><li>修改和删除的 <code>git add -u</code> --update</li><li>修改和新建的 <code>git add .</code></li><li>修改、删除和新建的 <code>git add -A</code> -ALL</li></ul><h4 id="add后的东西撤销">add后的东西撤销</h4><ul><li><code>git status</code> 查看暂存区有哪些文件</li><li><code>git reset HEAD</code> 撤销暂存区所有文件到工作区 =&gt;所有绿变红</li><li><code>git reset HEAD /XXX/XXX.cpp</code>撤销暂存区特定的文件到工作区 =&gt; 特定绿变红</li><li><code>git checkout --  路径或文件</code>只能用于已经被索引的文件，从工作区撤销，路径可以是 . =&gt; 红变无</li><li><code>git checkout -- .</code> =&gt; 所有文件红变无</li></ul><p>没有被索引的文件，意味着其是新文件，想红变无直接用 rm 即可</p><p>恢复到前一个commit, 并且将当前commit 的提交全部变为 绿色<code>git reset --soft HEAD^</code></p><p>恢复到前一个commit，并且将当前commit 的提交全部变为 红色<code>git reset --mixed HEAD^</code></p><p>--soft 和 --mixed 不会修改文件内容，只会修改文件在仓库的状态</p><p>将某个文件从当前提交中删除, 有一条删除该文件的修改，但文件内容不会变<code>git rm --cache test.txt</code></p><h4 id="提交到本地仓库repository">提交到本地仓库（repository）</h4><p><code>git commit -m "记录版本信息"</code> 提交暂存区文件到本地仓库<code>git log</code> 查看commit-id和所有的版本信息</p><h4id="提交仓库后再次修改而不保留上次commit信息">提交仓库后，再次修改而不保留上次commit信息</h4><ul><li><code>git commit --amend</code>在本地仓库内容没有合并入远程分支时，可以给上次commit的内容打补丁。打完补丁后，上次的commit-id和其版本信息都被本次的amend所覆盖加上 --no-edit 可直接跳过修改comment</li></ul><h4 id="推到远程仓库合入master">推到远程仓库，合入master</h4><ul><li><code>git push origin HEAD:refs/for/master</code>origin是远程仓库的代名词 master远程仓库的分支</li></ul><h4id="避免push到远程合入时有冲突先拉远程最新分支">避免push到远程合入时有冲突，先拉远程最新分支</h4><ul><li><code>git stash</code> 把本地修改的内容保存到堆栈中</li><li><code>git pull</code> 拉取远程最新代码，并merge到本地HEAD<code>git pull = git fetch ; git merge</code></li><li><code>git stash pop</code> 修改内容从堆栈弹出 然后再add，commit。这样可以基于当前的最新内容进行更改</li></ul><h4id="merge时有冲突手动修改冲突内容">merge时有冲突，手动修改冲突内容</h4><p>打开冲突文件 <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><span class="hljs-section">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-section">=======</span><br>Creating a new branch is quick AND simple.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<br></code></pre></td></tr></table></figure> =======是两个版本的冲突内容，上面是当前版本，下面是别的分支修改后的版本，删掉不需要的内容，和所有==、&gt;&gt;·HEAD。</p><p>TODO: 怎么用还不太确定 自动修改冲突，使用 git checkout --ours 或者git checkout --theirs</p><h4 id="单独克隆一个分支">单独克隆一个分支</h4><p>git clone --branch 分支名 --depth 分支深度 单独克隆一个分支后gitpull只能拉取当前分支的内容，若需要其他分支，需要先fetch到本地：git fetchorigin [remote-branch]:[local-branch]</p><h4 id="打补丁">打补丁</h4><p>制作补丁：git diff &gt; xxx.patch 检查patch文件：git apply --statxxx.patch 查看补丁是否能够干净顺利地应用到当前分支中: git apply --checkxxx.patch 将补丁合入当前分支 git apply xxx.patch</p><h3 id="git-error-解决">git error 解决</h3><h4 id="fatal-refusing-to-merge-unrelated-histories">fatal: refusing tomerge unrelated histories</h4><p>https://www.educative.io/answers/the-fatal-refusing-to-merge-unrelated-histories-git-error</p><p><code>git pull origin master --allow-unrelated-histories</code></p><p>参考： <ahref="https://blog.csdn.net/themagickeyjianan/article/details/79683980?spm=1001.2014.3001.5506">修改gitconfig配置文件</a></p><p><ahref="https://blog.csdn.net/Lakers2015/article/details/111990909">Git中的.gitignore文件的作用及配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量</title>
    <link href="/2021/11/25/linux-environment-path/"/>
    <url>/2021/11/25/linux-environment-path/</url>
    
    <content type="html"><![CDATA[<h2 id="环境变量">环境变量</h2><h3 id="三个文件">三个文件</h3><h4 id="etcprofile">1. <code>/etc/profile</code></h4><p>系统级别，可以所有用户起作用，网上有说是在用户登录时读取的。但在我电脑上使用<code>source /etc/profile</code>后只在当前终端起作用，新建终端仍不生效，为了以后在每个终端上都生效可以在<code>~/.bashrc</code>中添加<code>source /etc/profile</code>。注意<code>~/.bashrc</code>和<code>/etc/profile</code>中还包括对终端其他方面的设置，比如显示格式、颜色</p><h4 id="etcenvironment">2. <code>/etc/environment</code></h4><p>系统级别，应该是专门用于设置环境变量的，据说优先级高于<code>/etc/profile</code>，没验证过。#### 3. <code>~/.bashrc</code>只对当前用户生效，在个人电脑上直接修改这个文件即可，简单省事。</p><h3 id="环境变量书写格式">环境变量书写格式</h3><p>最好在文件末尾添加 <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin:/usr/bin<br></code></pre></td></tr></table></figure></p><p><code>PATH</code>表示环境变量，等号两边不要有空格（shell语法，赋值时等号两边不能有空格）<code>$PATH</code>表示取变量值，即如果上面定义了<code>PATH</code>，可以直接引用上面定义好的环境变量，所以这也是为什么要加在文件末尾<code>:</code>为分隔符，每一个环境变量的路径都要用<code>:</code>分开</p><p>上面这段代码等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#其他内容</span><br>PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin<br>PATH=<span class="hljs-variable">$PATH</span>:/usr/bin<br></code></pre></td></tr></table></figure><p>修改好后，使用source使其生效</p><h3 id="export命令">3.export命令</h3><p>export命令使环境变量在当前终端生效，关闭终端后失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:环境变量路径<br></code></pre></td></tr></table></figure><p>注意，一定要加上<code>$PATH</code>,否则会使已有的环境变量全都失效，只剩下新添加的</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ln命令</title>
    <link href="/2021/11/25/cmd-ln/"/>
    <url>/2021/11/25/cmd-ln/</url>
    
    <content type="html"><![CDATA[<h3 id="ln命令">ln命令</h3><h4 id="格式和参数">格式和参数</h4><p>语法格式： ln [参数] **[源**文件或目录][<strong>目标</strong>文件或目录]<br />ln a b a=&gt;b</p><table><thead><tr class="header"><th>参数</th><th>全称</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>空</td><td>hard</td><td>对源文件建立硬链接</td></tr><tr class="even"><td>-s</td><td>soft</td><td>对源文件建立软连接（符号链接）</td></tr><tr class="odd"><td>-f</td><td>force</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr class="even"><td>-b</td><td>backup</td><td>强制创建链接，即使目标文件已经存在</td></tr><tr class="odd"><td>-i</td><td>Interactive</td><td>交互模式，若目标文件已经存在，则提示用户确认进行覆盖</td></tr><tr class="even"><td>-v</td><td>verbose</td><td>详细信息模式，输出指令的详细执行过程</td></tr><tr class="odd"><td>-d</td><td>direction</td><td>此选项允许“root”用户建立目录的硬链接</td></tr></tbody></table><h4 id="软连接硬链接和拷贝的区别">软连接、硬链接和拷贝的区别</h4><p><strong>软连接：</strong> -链接文件内存储的是原文件的inode，也就是说是用来指向原文件文件，这<strong>两个文件的inode是不一样</strong>的- 软链接以路径的形式存在，类似于Windows操作系统中的快捷方式。 -删除软链接的链接文件，被链接文件不会受到任何影响，但是修改软链接文件内容，被链接文件内容也会被修改- 软链接可以跨文件系统 ，硬链接不可以。 -软链接可以对一个不存在的文件名进行链接，硬链接不可以。 -软链接可以对目录进行链接，硬链接不可以。 -删除软链接的被链接文件，链接文件会变成红色，这时打开链接文件会报错，报找不到被链接的文件这种错误</p><p><strong>硬连接：</strong>-硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件，这两个文件的<strong>inode号是同一个</strong>（ls-i） - 硬链接以文件副本的形式存在，但不占用实际空间。 -硬链接不允许普通用户给目录创建硬链接。 -硬链接只有在同一个文件系统中才能创建。</p><blockquote><p>A硬链B 删除B后A依然存在，且可用。 A软链B删除B后A存在，但不可用了（相当于Windows下快捷方式指向的目标不存在了）</p></blockquote><p><strong>拷贝：</strong></p><ul><li>拷贝产生的文件是一个独立的文件，有自己的元信息和inode节点</li></ul><blockquote><p>软连接和硬链接在使用时用哪一个，主要看是否需要链接目录，是否依赖相对路径，没有限制条件两者应该都可以使用。</p></blockquote><p>参考： <a href="https://www.linuxcool.com/ln">linux命令大全</a> <ahref="https://blog.csdn.net/geerniya/article/details/79093301">软链接、硬链接与复制的区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++可变参数</title>
    <link href="/2021/11/24/cpp-variable-arguments/"/>
    <url>/2021/11/24/cpp-variable-arguments/</url>
    
    <content type="html"><![CDATA[<h3 id="参数列表的...">参数列表的...</h3><p>... 表示函数的参数个数可变，典型的如<code>printf()</code><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * szFormat, ...)</span></span>;<br></code></pre></td></tr></table></figure>第一个参数是一个格式化字符串，后面是与格式化字符串中的代码相对应的不同类型的多个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br><span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ; <br></code></pre></td></tr></table></figure><h3id="使用...实现变参数函数的两种场景">使用...实现变参数函数的两种场景</h3><h4 id="格式化字符串">1. 格式化字符串</h4><blockquote><p><strong>使用场景：</strong>类似于实现一个printf，输入一串格式化的字符串，经过处理后可以将 %s %f%d等占位符替换为对应的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, va_list ap)</span>  </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* buf = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> len = <span class="hljs-built_in">vasprintf</span>(&amp;buf, format, ap); <br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> buf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>  <span class="hljs-comment">// 重载了func函数，不重载也行</span></span><br><span class="hljs-function"></span>&#123;<br>    va_list ap;<br>    <span class="hljs-type">char</span> *res = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-built_in">va_start</span>(ap, format);<br>    res = <span class="hljs-built_in">func</span>(format, ap);  <br>    <span class="hljs-built_in">va_end</span>(ap);<br>    <span class="hljs-keyword">return</span> res ;  <br>&#125;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;fgq&quot;</span>;<br>    <span class="hljs-type">int</span> age = <span class="hljs-number">18</span>; <br>    <span class="hljs-type">char</span>* str = <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;info &#123;name:%s, age:%d&#125;\n&quot;</span>,name, age) ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %s \n&quot;</span>, str) ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果<br>result: info &#123;name:fgq, age:<span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>上面func()函数重载了，如果不是类成员函数，要注意函数定义的顺序，在func(constchar* format,...)里要调用<code>func(const char* format, va_list ap)</code>，因此<code>func(const char* format, ...)</code>要定义在后面。类内成员函数则可以是任意顺序。</p></blockquote><p>实际上完成占位符替换为数据的是<code>int vasprintf (char **buf, const char *format, va_list ap)</code>函数：<code>buf</code>：一个用于保存结果的字符串缓冲区<code>format</code>：一个格式化字符串 <code>ap</code>:va_list类型的变量,va_list是一个宏，和va_start(va_list, arg)、va_arg(va_list,type)、va_end(va_list)这些宏在定义在头文件stdarg.h中，下面详细介绍通过这些宏来实现可变参数函数</p><h4 id="执行时指定可变参数类型">2.执行时指定可变参数类型</h4><blockquote><p><strong>使用场景：</strong>将n个数进行相加，此时n是不确定的，如果用重载方法，可能要重载很多次，如下面的例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例子：<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2, <span class="hljs-type">double</span> d3)</span></span>;<br>...<span class="hljs-comment">//还需要重载更多类似函数</span><br></code></pre></td></tr></table></figure><p>使用可变参数的方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> </span>&#123;  <span class="hljs-comment">//格式:count代表参数个数, ...代表n个参数</span><br> <br>va_list ap;  <span class="hljs-comment">//声明一个va_list变量</span><br><span class="hljs-built_in">va_start</span>(ap, count);  <span class="hljs-comment">//第二个参数表示形参的个数</span><br> <br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <span class="hljs-comment">// 按顺序返回参数列表中的参数</span><br>res += <span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>);   <span class="hljs-comment">//第二个参数表示形参类型</span><br>&#125;<br><br><span class="hljs-built_in">va_end</span>(ap);  <span class="hljs-comment">//用于清理</span><br> <br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">输出结果：<br>6<br></code></pre></td></tr></table></figure><h3id="使用initializer_list实现变参函数">使用initializer_list实现变参函数</h3><p><code>initializer_list</code>是一个列表初始化容器，声明在initializer_list头文件中，可以采用迭代器的方式来遍历参数列表，克服了<code>...</code>需要指定参数个数的缺点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initializerSum</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; il)</span> </span>&#123;<br>   <br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = il.<span class="hljs-built_in">begin</span>(); ptr != il.<span class="hljs-built_in">end</span>(); ptr++)  <span class="hljs-comment">//类似于容器的操作</span><br>&#123;<br>sum += *ptr;<br>&#125;<br> <br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">initializerSum</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) ;  <span class="hljs-comment">// 初始化 initializer_list&lt;int&gt;</span><br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; il &#123;<span class="hljs-number">1</span>&#125; ;<br>    res = <span class="hljs-built_in">initializerSum</span>(il);<br>    cout&lt;&lt;res&lt;&lt;endl; <br><br>    <span class="hljs-function">std::initializer_list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ill</span> <span class="hljs-params">(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)</span> </span>;<br>    res = <span class="hljs-built_in">initializerSum</span>(ill);<br>    cout&lt;&lt;res&lt;&lt;endl; <br>    <br>    <span class="hljs-keyword">auto</span> illl = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    res = <span class="hljs-built_in">initializerSum</span>(illl);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><p>参考： <ahref="http://en.cppreference.com/w/cpp/utility/initializer_list">cppreference对inittializer_list的介绍</a></p><p><ahref="https://blog.csdn.net/baidu_15952103/article/details/105886761">va_list函数学习（va_start，va_end,vasprintf）</a></p><p><ahref="https://blog.csdn.net/alex1997222/article/details/78639991">C++可变参数的两种方法</a></p><p><ahref="https://blog.csdn.net/anye3000/article/details/6593551">printf,sprintf,vsprintf区别</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++宏的使用技巧</title>
    <link href="/2021/11/23/cpp-marco-tips/"/>
    <url>/2021/11/23/cpp-marco-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="宏的使用技巧">宏的使用技巧</h3><blockquote><p>1、在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义2、 用来换行 3、 # 把变量变为字符串</p></blockquote><h3 id="在switch中使代码更简洁">1.在switch中使代码更简洁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br><span class="hljs-keyword">switch</span>(level)&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XX(i,name) \</span><br><span class="hljs-meta">case i: \</span><br><span class="hljs-meta">return name; \</span><br><span class="hljs-meta"></span><br><span class="hljs-built_in">XX</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;DEBUG&quot;</span>) ; <br><span class="hljs-built_in">XX</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;INFO&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;WARN&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;ERROR&quot;</span>) ;<br><span class="hljs-built_in">XX</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;FATAL&quot;</span>) ;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> XX</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW&quot;</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="把变量变为字符串">2.把变量变为字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(<span class="hljs-number">1</span>)&lt;&lt;endl;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1000</span> ; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(a)&lt;&lt;endl; <br>cout&lt;&lt;<span class="hljs-built_in">STRING</span>(b)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输出结果：<br><span class="hljs-number">1</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><h3 id="打印宏定义内容">3.打印宏定义内容</h3><p>通过预处理指令 #pragma message(宏)，将宏定义内容打印到标准输出,由于宏定义只是一种文本表示，并不是字符串类型，因此如果宏定义的内容为“v0.0.1” 这种形式，message 会有如下报错： <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;command-line&gt;: <span class="hljs-keyword">error</span>: too many decimal points <span class="hljs-keyword">in</span> <span class="hljs-built_in">number</span><br></code></pre></td></tr></table></figure>因此需要将宏的内容转为字符串类型，所以 #pragma message 通常与<ahref="#2把变量变为字符串">把变量变为字符串</a>搭配使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING(x) (#x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(STRING(PROJETCT_VERSION));</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板模式</title>
    <link href="/2021/11/19/template_pattern/"/>
    <url>/2021/11/19/template_pattern/</url>
    
    <content type="html"><![CDATA[<h3 id="模板模式">模板模式</h3><p><strong>意图:</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决:</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p><blockquote><p><strong>例子</strong>建造房子的流程都是一样的，比如：打地基-&gt;砌砖头-&gt;盖屋顶但是不同种类的房子，比如茅草房和别墅，在这三个步骤中所要做的具体事情不一样此时就可以应用模板模式，在接口类（基类）中抽象出统一的流程，在子类中再重写具体步骤的方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std ; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IGame</span>&#123;  <span class="hljs-comment">// 接口类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-comment">//模板：固定不变的部分，定义统一的游戏流程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">initialize</span>();<br>        <span class="hljs-built_in">startPlay</span>();<br>        <span class="hljs-built_in">endPlay</span>(); <br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IGame</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basketball</span>:<span class="hljs-keyword">public</span> IGame&#123;  <br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Basketball endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Basketball</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Football</span>:<span class="hljs-keyword">public</span> IGame&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// 重写接口类中游戏流程中的具体方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football initialize&quot;</span>&lt;&lt;endl; <br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">startPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football startPlay&quot;</span>&lt;&lt;endl;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">endPlay</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Football endPlay&quot;</span>&lt;&lt;endl ; <br>    &#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Football</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    IGame *pb ;  <br>    Basketball basketball ; <br>    Football Football ; <br>    pb = &amp;basketball ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    pb = &amp;Football ; <br>    pb-&gt;<span class="hljs-built_in">play</span>() ; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">打印输出：<br><br><span class="hljs-keyword">Basketball </span>initialize<br><span class="hljs-keyword">Basketball </span>startPlay<br><span class="hljs-keyword">Basketball </span>endPlay<br>Football initialize<br>Football startPlay<br>Football endPlay<br></code></pre></td></tr></table></figure><hr /><p><strong>总结：</strong>模板模式在类库的设计中很常见，在模板模式中，库设计者会给使用者提供固定的流程和需要重写的接口，使用者通常只需要：1、继承父类； 2、重写某一个或某几个接口；3、调用包含了所有流程的方法，比如<code>play()</code></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的设计原则和分类</title>
    <link href="/2021/11/19/design-pattern-priciple-classification/"/>
    <url>/2021/11/19/design-pattern-priciple-classification/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式的设计原则和分类">设计模式的设计原则和分类</h2><h3 id="设计原则">设计原则</h3><h4 id="依赖倒置原则dip">1、依赖倒置原则（DIP）</h4><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul><h4 id="开放封闭原则ocp">2、开放封闭原则（OCP）</h4><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><h4 id="单一职责原则srp">3、单一职责原则（SRP）</h4><ul><li>一个类应该仅有一个引起他变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><h4 id="liskov替换原则lsp">4、Liskov替换原则（LSP）</h4><ul><li>子类必须能够替换他们的基类（IS-A）。</li><li>继承表达类型抽象。</li></ul><h4 id="接口隔离原则isp">5、接口隔离原则（ISP）</h4><ul><li>不应该强迫客户程序依赖他们不用的方法。</li><li>接口应该小而完备。</li></ul><h4 id="迪米特洛原则最少知识原则">6、迪米特洛原则（最少知识原则）</h4><ul><li>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</li><li>优先使用对象组合，而不是类继承。类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><h4 id="封装变化点">7、封装变化点</h4><ul><li>使用封装来创建对象之间的分解层，让设计者可以在分层的一侧进行修改，而不会对另一侧产生不良的影响，减少层次间的耦合。</li></ul><h4id="针对接口抽象类编程而不是针对实现编程">8、针对接口（抽象类）编程，而不是针对实现编程</h4><ul><li>不将变量类型生命为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无须获知对象的具体类型，只需要知道对象所具有的接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”。</li><li>和依赖倒置原则相辅相成。</li></ul><h3 id="分类">分类</h3><p>三分类：<ahref="https://www.runoob.com/design-pattern/design-pattern-intro.html">https://www.runoob.com/design-pattern/design-pattern-intro.html</a></p><p>李建忠老师的九分类：</p><table><thead><tr class="header"><th>模式分类</th><th>包括</th></tr></thead><tbody><tr class="odd"><td><strong>组件协作</strong></td><td>模板模式<br>策略模式<br>观察者模式</td></tr><tr class="even"><td><strong>单一职责</strong></td><td>装饰者模式<br> 桥接模式</td></tr><tr class="odd"><td><strong>对象创建</strong></td><td>工厂模式<br>抽象工厂模式<br>原型模式<br>建造者模式</td></tr><tr class="even"><td><strong>对象性能</strong></td><td>单例模式<br>享元模式</td></tr><tr class="odd"><td><strong>接口隔离</strong></td><td>门面模式<br>代理模式<br>适配器模式<br>中介者模式</td></tr><tr class="even"><td><strong>状态变化</strong></td><td>状态模式<br>备忘录模式</td></tr><tr class="odd"><td><strong>数据结构</strong></td><td>组合模式<br>迭代器模式<br>职责链模式</td></tr><tr class="even"><td><strong>行为变化</strong></td><td>命令模式<br>访问器模式</td></tr><tr class="odd"><td><strong>领域问题</strong></td><td>解析器模式</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode_opencv</title>
    <link href="/2021/11/12/vscode-opencv/"/>
    <url>/2021/11/12/vscode-opencv/</url>
    
    <content type="html"><![CDATA[<h3 id="win10-vscode-加载opencv库">win10 vscode 加载opencv库</h3><p>从头到尾的配置： 1、Visual Studio Code 配置 2、openCV 配置 3、MinGw配置 4、cmake 配置 完整过程参考：<ahref="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>如果使用vscode已经可以编译c++程序了，即可以省略掉大部分vscode和的MinGW的配置过程（只要vscode中配置好opencv的头文件路径和库路径即可）</p><p>opencv的配置过程，实际上就是库的加载过程，如果是已经编译好的opencv库，只要配置好头文件路径和库文件路径即可，如果是下载的源文件，则需要通过cmake进行编译。cmake编译opencv参考：<ahref="https://blog.csdn.net/zhaiax672/article/details/88971248">https://blog.csdn.net/zhaiax672/article/details/88971248</a></p><p>opencv已经编译好了之后，把头文件路径和库文件路径加到系统的环境变量中。</p><p>最后配置vscode的三个.json文件：<code>launch.json</code>、<code>tasks.json</code>、<code>c_cpp_properties.json</code></p><p>各自的配置如下：<code>launch.json</code>：主要注意<strong>miDebuggerPath</strong>和<strong>program</strong>两项<figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">Use</span> <span class="hljs-string">IntelliSense</span> <span class="hljs-string">to</span> <span class="hljs-string">learn</span> <span class="hljs-string">about</span> <span class="hljs-string">possible</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">Hover</span> <span class="hljs-string">to</span> <span class="hljs-string">view</span> <span class="hljs-string">descriptions</span> <span class="hljs-string">of</span> <span class="hljs-string">existing</span> <span class="hljs-string">attributes.</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">For</span> <span class="hljs-string">more</span> <span class="hljs-string">information</span>, <span class="hljs-attr">visit:</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;0.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        <br>        <br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;(gdb) Launch&quot;</span>,<br>            <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;cppdbg&quot;</span>,<br>            <span class="hljs-attr">&quot;request&quot;:</span> <span class="hljs-string">&quot;launch&quot;</span>,<br>            <span class="hljs-attr">&quot;program&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,<br>            <span class="hljs-attr">&quot;args&quot;:</span> [],<br>            <span class="hljs-attr">&quot;stopAtEntry&quot;:</span> <span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">&quot;cwd&quot;:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,<br>            <span class="hljs-attr">&quot;environment&quot;:</span> [],<br>            <span class="hljs-attr">&quot;externalConsole&quot;:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">&quot;MIMode&quot;:</span> <span class="hljs-string">&quot;gdb&quot;</span>,<br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gdb.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;preLaunchTask&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>            <span class="hljs-attr">&quot;setupCommands&quot;:</span> [<br>                &#123;<br>                    <span class="hljs-attr">&quot;description&quot;:</span> <span class="hljs-string">&quot;Enable pretty-printing for gdb&quot;</span>,<br>                    <span class="hljs-attr">&quot;text&quot;:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,<br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;:</span> <span class="hljs-literal">true</span><br>                &#125;<br>            ]<br>        &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure> <code>tasks.json</code>：主要修改<strong>args</strong>中大i、大L和小l 这里实际上就是g++ -I头文件路径 -L 库文件路径 -l 库文件名注意实际库文件的命名和这里写库文件名的区别实际库文件名=lib库文件名.dll.a <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-string">//</span> <span class="hljs-string">See</span> <span class="hljs-string">https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">for</span> <span class="hljs-string">the</span> <span class="hljs-string">documentation</span> <span class="hljs-string">about</span> <span class="hljs-string">the</span> <span class="hljs-string">tasks.json</span> <span class="hljs-string">format</span><br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-string">&quot;2.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;command&quot;:</span> <span class="hljs-string">&quot;g++&quot;</span>,<br>    <span class="hljs-attr">&quot;args&quot;:</span> [<br>        <span class="hljs-string">&quot;-g&quot;</span>, <br>        <span class="hljs-string">&quot;-std=c++11&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;file&#125;&quot;</span>, <br>        <span class="hljs-string">&quot;-o&quot;</span>, <br>        <span class="hljs-string">&quot;$&#123;fileBasenameNoExtension&#125;.o&quot;</span>,  <br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>        <span class="hljs-string">&quot;-I&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>,<br>        <span class="hljs-string">&quot;-L&quot;</span>, <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\x64\\MinGW\\lib&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_core3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_dnn3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_features2d3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_flann3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_highgui3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgcodecs3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_imgproc3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ml3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_objdetect3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_photo3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_shape3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_stitching3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_superres3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_video3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videoio3416&quot;</span>, <br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_videostab3416&quot;</span>,<br>        <span class="hljs-string">&quot;-l&quot;</span>,<span class="hljs-string">&quot;opencv_ts3416&quot;</span><br><br>  <br>    ],<span class="hljs-string">//</span> <span class="hljs-string">编译命令参数</span><br>    <span class="hljs-string">&quot;problemMatcher&quot;</span><span class="hljs-string">:</span>&#123;<br>        <span class="hljs-attr">&quot;owner&quot;:</span> <span class="hljs-string">&quot;cpp&quot;</span>,<br>        <span class="hljs-string">&quot;fileLocation&quot;</span><span class="hljs-string">:</span>[<br>            <span class="hljs-string">&quot;relative&quot;</span>,<br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;pattern&quot;</span><span class="hljs-string">:</span>[<br>            &#123;<br>                <span class="hljs-attr">&quot;regexp&quot;:</span> <span class="hljs-string">&quot;^([^\\\\s].*)\\\\((\\\\d+,\\\\d+)\\\\):\\\\s*(.*)$&quot;</span>,<br>                <span class="hljs-attr">&quot;file&quot;:</span> <span class="hljs-number">1</span>,<br>                <span class="hljs-attr">&quot;location&quot;:</span> <span class="hljs-number">2</span>,<br>                <span class="hljs-attr">&quot;message&quot;:</span> <span class="hljs-number">3</span><br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">&quot;group&quot;:</span> &#123;<br>        <span class="hljs-attr">&quot;kind&quot;:</span> <span class="hljs-string">&quot;build&quot;</span>,<br>        <span class="hljs-attr">&quot;isDefault&quot;:</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure></p><p><code>c_cpp_properties.json</code>：主要修改<strong>includePath</strong>和<strong>compilerPath</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">&quot;configurations&quot;:</span> [<br>        &#123;<br>            <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;win&quot;</span>,<br>            <span class="hljs-attr">&quot;includePath&quot;:</span> [<br>                <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv2&quot;</span>,<br>                <span class="hljs-string">&quot;D:\\Program Files\\opencv\\opencv\\build\\include\\opencv&quot;</span>         <br>            ],<br>            <span class="hljs-attr">&quot;defines&quot;:</span> [],<br>            <span class="hljs-attr">&quot;compilerPath&quot;:</span> <span class="hljs-string">&quot;C:/Program Files/mingw-w64/x86_64-5.3.0-posix-seh-rt_v4-rev0/mingw64/bin/gcc.exe&quot;</span>,<br>            <span class="hljs-attr">&quot;cStandard&quot;:</span> <span class="hljs-string">&quot;c11&quot;</span>,<br>            <span class="hljs-attr">&quot;cppStandard&quot;:</span> <span class="hljs-string">&quot;c++17&quot;</span>,<br>            <span class="hljs-attr">&quot;intelliSenseMode&quot;:</span> <span class="hljs-string">&quot;clang-x64&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;version&quot;:</span> <span class="hljs-number">4</span><br>&#125;<br><br></code></pre></td></tr></table></figure> 如果不是完全照搬上述的配置，需要注意：</p><ul><li><code>launch.json</code>的<strong>preLaunchTask</strong>和<code>tasks.json</code>中的<strong>label</strong>内容需要一致，否则报错，比如修改<code>launch.json</code>的<strong>preLaunchTask</strong>为g++.exe，则会报错<imgsrc="https://img-blog.csdnimg.cn/0539074e59fe455882f429a521c318b4.png"alt="在这里插入图片描述" /> 三个json文件的作用： <code>tasks.json</code>(build instructions) <code>launch.json</code> (debugger settings)<code>c_cpp_properties.json</code> (compiler path and IntelliSensesettings</li></ul><p>vscode配置官方教程：<ahref="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之类图表示</title>
    <link href="/2021/11/07/UML/"/>
    <url>/2021/11/07/UML/</url>
    
    <content type="html"><![CDATA[<h3 id="类图属性">类图属性</h3><p>一个大矩形里面分三层： - 类名 - 成员名：可见性 名称 ：类型 [ =默认值] - 方法名：可见性 名称(参数列表) [ ： 返回类型] <imgsrc="https://img-blog.csdnimg.cn/c59f02761f6b4d5c926297de49d48cfa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /></p><p>可见性： - +：表示public - -：表示private -#：表示protected（friendly也归入这类）</p><h3 id="类之间关系">类之间关系</h3><h4 id="依赖">1、依赖</h4><p>依赖关系使用<strong>带箭头的虚线</strong>来表示，箭头从使用类指向被依赖的类。</p><p><strong>人依赖手机：</strong> <imgsrc="https://img-blog.csdnimg.cn/f53bd1f094a946b9a8121fe7f7c3beb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" />依赖（Dependency）关系是一种<strong>使用关系</strong>，它是对象之间耦合度最弱的一种关联方式，被使用对象的有无，不影响使用对象，是临时性的关联。</p><h4 id="关联">2、关联</h4><p>依赖关系使用<strong>带箭头的实线</strong>来表示，箭头从使用类指向被关联的类，可以单向关联，也可以双向关联。</p><p>双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示。</p><p><strong>老师和学生双向关联：</strong>每个老师可以教多个学生，每个学生也可向多个老师学<imgsrc="https://img-blog.csdnimg.cn/59ed529d91fb40fcb133824a7fc0f59b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" />关联（Association）关系是对象之间的一种<strong>引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。被引用者不存在时，引用者可以存在，但是没有意义。</p><h4 id="聚合">3、聚合</h4><p>聚合关系可以用<strong>带空心菱形的实线</strong>来表示，菱形指向整体。</p><p><strong>大学包含教师：</strong> <imgsrc="https://img-blog.csdnimg.cn/5979cb34f002423bb819274d3a3798d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /></p><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是<strong>整体和部分之间的关系</strong>，是has-a的关系。当部分类不存在，整体类也不能存在，但是部分可以脱离整体而独立存在。比如大学不能脱离教师而存在，但是没有大学教师依然能够独立存在。</p><h4 id="组合">4、组合</h4><p>组合关系用<strong>带实心菱形的实线来表示</strong>，菱形指向整体<strong>头和嘴：</strong> <imgsrc="https://img-blog.csdnimg.cn/9accac46ce1d4eb382cdf8d1c00623b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /></p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象也不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><h4 id="泛化">5、泛化</h4><p>泛化关系用<strong>带空心三角箭头的实线</strong>来表示，箭头从子类指向父类。</p><p><strong>人和学生、老师：</strong> <imgsrc="https://img-blog.csdnimg.cn/b27b8f34dcfd4134b179533991d8d045.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /></p><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是<strong>父类与子类之间的关系，是一种继承关系</strong>，是is-a 的关系。</p><h4 id="实现">6、实现</h4><p>实现关系使用<strong>带空心三角箭头的虚线来表示</strong>，箭头从实现类指向接口</p><p><strong>鸟和飞：</strong> <imgsrc="https://img-blog.csdnimg.cn/2380c43ba2dc4c07b395882e3930059c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_15,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /></p><p>实现（Realization）关系是<strong>接口与实现类之间的关系</strong>。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。可以将实现类看做方法。</p><p>参考： <ahref="https://www.cnblogs.com/shindo/p/5579191.html">https://www.cnblogs.com/shindo/p/5579191.html</a><ahref="https://blog.csdn.net/sinat_21107433/article/details/102576624">https://blog.csdn.net/sinat_21107433/article/details/102576624</a><ahref="http://c.biancheng.net/view/1319.html">http://c.biancheng.net/view/1319.html</a><ahref="https://www.jianshu.com/p/641682f9c918">https://www.jianshu.com/p/641682f9c918</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update_nodejs</title>
    <link href="/2021/11/01/update-nodejs/"/>
    <url>/2021/11/01/update-nodejs/</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu升级nodejs">Ubuntu升级nodejs</h2><h3 id="下载nodejs压缩文件">下载nodejs压缩文件</h3><p>打开nodejs官网，打开<code>DOWNLOADS</code>页面，选择一个版本，右键复制链接地址，然后使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">wget https://nodejs.org/dist/v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><p>下载到本地 ### 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf v16.13.0/node-v16.13.0-linux-x64.tar.xz <br></code></pre></td></tr></table></figure><h3 id="将node和npm设置为全局">将node和npm设置为全局</h3><p>将新的node可执行文件<strong>硬链接</strong>到/usr/local/bin/node,如果提示连接已存在，可将/usr/local/bin/node删掉，再重新连接(删除前建议先备份)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/node /usr/local/bin/node<br> <br>sudo <span class="hljs-built_in">ln</span> 解压后路径/node-v16.13.0-linux-x64/bin/npm /usr/local/bin/npm  <br></code></pre></td></tr></table></figure> <strong>/bin/usr和/bin/local/usr的区别：</strong>   /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。   /usr/local/bin目录是给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件。  /如果两个目录下有相同的可执行程序，谁优先执行受到PATH环境变量的影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">fgq@ubuntu:~/hexo_blog$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin<br></code></pre></td></tr></table></figure><p>   这里/usr/local/bin优先于/usr/bin, 一般都是如此</p><p><strong>另外一种设为全局的方法：使用别名alias</strong></p><p>当前终端生效： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> node=解压后路径/node-v16.13.0-linux-x64/bin/node<br><span class="hljs-built_in">alias</span> npm=解压后路径/node-v16.13.0-linux-x64/bin/npm<br></code></pre></td></tr></table></figure> 永久生效：  修改主目录下.bashrc文件(~/.bashrc)，添加上述两句    然后<code>source  ~/.bashrc</code> <strong>note:</strong>等号两边没有空格</p><blockquote><p>node和nodejs之间没有区别，node全称就是nodejs。nodejs是一个基于ChromeV8引擎的JavaScript运行环境</p></blockquote><p>参考： <ahref="https://blog.csdn.net/qq_37035946/article/details/99451703">1、https://blog.csdn.net/qq_37035946/article/details/99451703</a><ahref="https://blog.csdn.net/nzjdsds/article/details/88345400">2、https://blog.csdn.net/nzjdsds/article/details/88345400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux_tips</title>
    <link href="/2021/11/01/linux-tips/"/>
    <url>/2021/11/01/linux-tips/</url>
    
    <content type="html"><![CDATA[<h3 id="linux">linux</h3><p>for linux tips</p><h5 id="格式化环境变量">格式化环境变量</h5><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span>|awk -F<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123;for(i=1;i&lt;=NF;i++)print <span class="hljs-variable">$i</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="清空共享内存">清空共享内存</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">ipcs|awk &#x27;</span><span class="hljs-template-variable">&#123;print $1&#125;</span><span class="language-xml">&#x27;|xargs -I </span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"> sudo ipcrm -M </span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><h5 id="查看系统启动时间">查看系统启动时间</h5><p><code>ps -p PID -o lstart</code></p><p>top 的 TIME 是占用 cpu 时间</p><p>(加sudo 权限)修改系统时间和时区:https://www.cnblogs.com/ljy2013/p/4615149.html</p><h5 id="磁盘u盘-挂载">磁盘/U盘 挂载</h5><p>查看磁盘列表 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo fdisk -l</span><br></code></pre></td></tr></table></figure></p><p>挂载 mount</p><p>卸载 umount <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mount 磁盘名称 挂载路径<br>sudo umount 磁盘名称<br>比如: <br>sudo mount <span class="hljs-regexp">/dev/</span>sda1 <span class="hljs-regexp">/home/</span>work/<br>sudo umount <span class="hljs-regexp">/dev/</span>sda1    <br></code></pre></td></tr></table></figure></p><p>不小心拔下在复制数据的移动硬盘出现无法加载的错误 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MFTMirrdoesnotmatchMFTMirrdoesnotmatchMFT (<span class="hljs-built_in">record</span> <span class="hljs-number">0</span>).<br>Failed <span class="hljs-keyword">to</span> mount &#x27;/dev/sda1&#x27;: Input/output <span class="hljs-keyword">error</span><br>NTFS <span class="hljs-keyword">is</span> either inconsistent, <span class="hljs-keyword">or</span> there <span class="hljs-keyword">is</span> a hardware fault, <span class="hljs-keyword">or</span> <span class="hljs-keyword">it</span>&#x27;s a<br>SoftRAID/FakeRAID hardware. In <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> case <span class="hljs-built_in">run</span> chkdsk /f <span class="hljs-keyword">on</span> Windows<br><span class="hljs-keyword">then</span> reboot <span class="hljs-keyword">into</span> Windows twice. The usage <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> /f parameter <span class="hljs-keyword">is</span> very<br>important! If <span class="hljs-keyword">the</span> device <span class="hljs-keyword">is</span> a SoftRAID/FakeRAID <span class="hljs-keyword">then</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">activate</span><br><span class="hljs-keyword">it</span> <span class="hljs-keyword">and</span> mount a different device under <span class="hljs-keyword">the</span> /dev/mapper/ directory, (e.g.<br>/dev/mapper/nvidia_eahaabcc1). Please see <span class="hljs-keyword">the</span> &#x27;dmraid&#x27; documentation<br><span class="hljs-keyword">for</span> more details.<br></code></pre></td></tr></table></figure>LINUX下<code>sudo ntfsfix /dev/sda1</code></p><h5 id="输出重定向">输出重定向</h5><p>标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2</p><p>2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出.</p><p>&amp;&gt;file 意思是把标准输出 和 标准错误输出都重定向到文件file中</p><h5 id="磁盘分区和安装文件系统">磁盘分区和安装文件系统</h5><p>https://blog.csdn.net/qq_43527718/article/details/122850052</p><p>sudo fdisk /dev/nvme0n1</p><p>n 添加分区</p><p>p 打印分区表 查看分区成功否</p><p>w 保存</p><p>mkfs -t ext4 /dev/nvme0n1p1 给第一个分区安装文件系统</p><p>sudo blkid /dev/nvme0n1p1 查看nvme0n1p1属性</p><h5 id="命令行启动向日葵">命令行启动向日葵</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">ps -ef | <span class="hljs-keyword">grep</span> sun<br>root       <span class="hljs-number">836</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">18</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/oray_rundaemon -m server<br>root       <span class="hljs-number">856</span>   <span class="hljs-number">836</span>  <span class="hljs-number">1</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">08</span>:<span class="hljs-number">43</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sunlogin/</span>bin/sunloginclient -m service<br><br>杀掉两个进程后执行<br>(开机自启动服务):<br>sudo systemctl start runsunloginclient.service<br>sudo systemctl enable runsunloginclient.service<br></code></pre></td></tr></table></figure><h5 id="apt">apt</h5><p>apt 的目录 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/</span>apt/<span class="hljs-keyword">source</span>.list 源列表，apt update 所使用的源<br><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists index 位置，即 apt update所更新的包的标签<br><span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/apt/</span>archive  apt-get install 下载安装包的路径<br></code></pre></td></tr></table></figure></p><p>命令 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">apt-cache show 包名，展示的是<span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists 目录下所对应的标签的信息<br>apt list 当前所使用的源所能获取到的软件包(deb)<br>apt install 包<br>apt remove 包<br></code></pre></td></tr></table></figure> 小 tip：当编译提示缺少什么库的时候的，aptlist|grep 库 试下, 一般是 libxxx-dev，可以试下 apt installlibxxx-dev</p><h4 id="wget">wget</h4><p>wget 下载目录 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -r -np -nH -R index.html http:<span class="hljs-regexp">//u</span>rl<span class="hljs-regexp">/including/</span>files/you<br></code></pre></td></tr></table></figure>https://zhuanlan.zhihu.com/p/380793959</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@j5dvb</span><span class="hljs-symbol">:/map/guoqing</span>.feng/multiperception<span class="hljs-comment"># wget  https://www.xxx.io/output.tar</span><br><span class="hljs-symbol">wget:</span> bad address <span class="hljs-string">&#x27;www.xxx.io&#x27;</span><br></code></pre></td></tr></table></figure><p>修改域名解析配置 /etc/resolv.conf，没有则新建，格式如下:<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">127.0.0.53</span><br></code></pre></td></tr></table></figure></p><h3 id="tar传输文件">tar传输文件</h3><p>tar cf - src_dir | ssh user@ip "tar xf - -C dst_path"<br />会节省4次磁盘操作，提升一下开发效率。</p><h3 id="export-当前所有目录下的动态库">export当前所有目录下的动态库</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> `<span class="hljs-built_in">find</span> -name <span class="hljs-string">&quot;*.so&quot;</span>|xargs -I &#123;&#125; realpath &#123;&#125; | xargs -I &#123;&#125; dirname &#123;&#125;`; <span class="hljs-keyword">do</span> <span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:$p; done<br></code></pre></td></tr></table></figure><h3 id="vim">vim</h3><h4 id="块模式">块模式</h4><p>windows 快捷键 ctrl+v<br />mac 快捷键 shift+control+v<br />进入visual block 后，上下选择行的范围 -&gt; 输入内容 -&gt; 按 I -&gt; 按ESC -&gt; 完成多行的一起修改</p><h4 id="section"></h4><p>行首输入 I<br />行尾输入</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类和对象的内存布局</title>
    <link href="/2021/11/01/cpp-memory-layout/"/>
    <url>/2021/11/01/cpp-memory-layout/</url>
    
    <content type="html"><![CDATA[<h3 id="用g查看内存布局的方法">用g++查看内存布局的方法：</h3><p>  g++ 版本&gt;8.0：<code>g++ -fdump-lang-class vptr.cpp</code>   g++版本&lt;8.0：<code>g++ -fdump-class-hierarchy vptr.cpp</code> <ahref="https://blog.csdn.net/Ineedapassward/article/details/118417116">参考：https://blog.csdn.net/Ineedapassward/article/details/118417116</a></p><h3 id="类的内存布局">类的内存布局</h3><p><ahref="https://blog.csdn.net/shichao1470/article/details/91563282">参考：https://blog.csdn.net/shichao1470/article/details/91563282</a></p><h3 id="菱形继承下对象的内存布局">菱形继承下对象的内存布局</h3><p><ahref="https://blog.csdn.net/j4ya_/article/details/80177897">参考：https://blog.csdn.net/j4ya_/article/details/80177897</a></p><h3 id="菱形继承下类的内存布局">菱形继承下类的内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;X::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Y::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">funcY</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span>: <span class="hljs-keyword">public</span> X,  <span class="hljs-keyword">public</span> Y&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Z::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(Base)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(X)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Y)&lt;&lt;endl<br>        &lt;&lt;<span class="hljs-built_in">sizeof</span>(Z)&lt;&lt;endl ; <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>64位系统下运行，sizeof(int *) 等于8，输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">8<br>8<br>8<br>16<br></code></pre></td></tr></table></figure><p><strong>问题：</strong>   类Base的size为8，是因为有一个虚表指针，  类X和类Y的size也为8，也是因为各自只有一个虚表指针？  类Z的size为16，是为甚？不采用虚继承的时候结果不变，为甚？ 使用g++查看内存布局，结果如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Vtable <span class="hljs-keyword">for</span> Z<br>Z::_ZTV1Z: <span class="hljs-number">6</span> entries<br><span class="hljs-number">0</span>     (int <span class="hljs-comment">(*)(...))0</span><br><span class="hljs-comment">8     (int (*)</span>(...))(&amp; _ZTI1Z)<br><span class="hljs-number">16</span>    (int <span class="hljs-comment">(*)(...))Z::func</span><br><span class="hljs-comment">24    (int (*)</span>(...))-<span class="hljs-number">8</span><br><span class="hljs-number">32</span>    (int <span class="hljs-comment">(*)(...))(&amp; _ZTI1Z)</span><br><span class="hljs-comment">40    (int (*)</span>(...))Z::_ZThn8_N1Z4funcEv<br><br><span class="hljs-keyword">Class</span> Z<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br>Z (<span class="hljs-number">0</span>x0x3feb780) <span class="hljs-number">0</span><br>    vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">16</span>)<br>  X (<span class="hljs-number">0</span>x0x3feb7c0) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>      primary-<span class="hljs-keyword">for</span> Z (<span class="hljs-number">0</span>x0x3feb780)<br>    Base (<span class="hljs-number">0</span>x0x3fdca48) <span class="hljs-number">0</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> X (<span class="hljs-number">0</span>x0x3feb7c0)<br>  Y (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>      vptr=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>    Base (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-<span class="hljs-keyword">empty</span><br>        primary-<span class="hljs-keyword">for</span> Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>为啥</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Y</span> (<span class="hljs-number">0</span>x0x3feb800) <span class="hljs-number">8</span> nearly-empty<br>    <span class="hljs-attribute">vptr</span>=((&amp; Z::_ZTV1Z) + <span class="hljs-number">40</span>)<br>  <span class="hljs-attribute">Base</span> (<span class="hljs-number">0</span>x0x3fdca80) <span class="hljs-number">8</span> nearly-empty<br>      <span class="hljs-attribute">primary</span>-for Y (<span class="hljs-number">0</span>x0x3feb800)<br></code></pre></td></tr></table></figure><p>这里是什么东西啊？</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error_non_const_lvalue</title>
    <link href="/2021/10/31/error-non-const-lvalue/"/>
    <url>/2021/10/31/error-non-const-lvalue/</url>
    
    <content type="html"><![CDATA[<h4id="errorcannot-bind-non-const-lvalue-reference-of-type-xxx-to-an-rvalue-of-type-xxx">error：cannotbind non-const lvalue reference of type ‘xxx&amp;‘ to an rvalue of type‘xxx‘</h4><p>非常量左值引用不能赋给右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base()&quot;</span>&lt;&lt;endl ; <br>    &#125;; <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">const</span> Base &amp;other)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base(Base &amp;other)&quot;</span>&lt;&lt;endl ; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Base::func()&quot;</span>&lt;&lt;endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    Base b0 ; <br>    <span class="hljs-comment">// 三种调用拷贝构造创建对象的方式</span><br>    <span class="hljs-function">Base <span class="hljs-title">b1</span><span class="hljs-params">(b0)</span> </span>;  <br>    Base b2 = b0 ; <br>    Base b3 = <span class="hljs-built_in">Base</span>(b0) ;   <span class="hljs-comment">// 当拷贝构造函数为 Base(Base &amp;other) 而不是Base(const Base &amp;other)时，报错</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原因：</strong>   如果一个参数是以非const引用传入，c++编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。但如果你把一个临时变量当作非const引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，<strong>c++编译器加入了临时变量不能作为非const引用的这个语义限制。</strong></p><p><ahref="https://blog.csdn.net/digitalkee/article/details/105092400">参考：https://blog.csdn.net/digitalkee/article/details/105092400</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缺少模板参数列表</title>
    <link href="/2021/10/28/template_typename_T/"/>
    <url>/2021/10/28/template_typename_T/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://img-blog.csdnimg.cn/da1fd3f3cf3244ecac3814f3e1ed0f0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFx55av5ZWm55av5ZWm,size_20,color_FFFFFF,t_70,g_se,x_16"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/* data */</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">vector</span>(<span class="hljs-comment">/* args */</span>);<br>    ~ <span class="hljs-built_in">vector</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T <span class="hljs-type">const</span>&amp; )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// 不加这一行 会报错：“缺少模板参数列表”</span><br><span class="hljs-type">void</span> vector&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>参考 <ahref="https://blog.csdn.net/u013891092/article/details/51583666/">https://blog.csdn.net/u013891092/article/details/51583666/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
